// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace cowl
{
    /// <summary>Pointer type.</summary>
    /// <summary>Byte type.</summary>
    /// <summary>@}</summary>
    public unsafe partial class unumber
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint16_floor2@@YAGG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort UlibUint16Floor2(ushort x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint32_floor2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUint32Floor2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint64_floor2@@YA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong UlibUint64Floor2(ulong x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint16_ceil2@@YAGG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort UlibUint16Ceil2(ushort x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint32_ceil2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUint32Ceil2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint64_ceil2@@YA_K_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong UlibUint64Ceil2(ulong x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint16_log2@@YAIG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUint16Log2(ushort x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint32_log2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUint32Log2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint64_log2@@YAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUint64Log2(ulong x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint_floor2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUintFloor2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint_ceil2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUintCeil2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint_log2@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUintLog2(uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_float_prev@@YANN@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UlibFloatPrev(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_float_next@@YANN@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UlibFloatNext(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint_pow2@@YAIE@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibUintPow2(byte x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_uint_is_pow2@@YA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibUintIsPow2(uint x);
        }

        /// <summary>@{</summary>
        public static ushort UlibUint16Floor2(ushort x)
        {
            var ___ret = __Internal.UlibUint16Floor2(x);
            return ___ret;
        }

        public static uint UlibUint32Floor2(uint x)
        {
            var ___ret = __Internal.UlibUint32Floor2(x);
            return ___ret;
        }

        public static ulong UlibUint64Floor2(ulong x)
        {
            var ___ret = __Internal.UlibUint64Floor2(x);
            return ___ret;
        }

        public static ushort UlibUint16Ceil2(ushort x)
        {
            var ___ret = __Internal.UlibUint16Ceil2(x);
            return ___ret;
        }

        public static uint UlibUint32Ceil2(uint x)
        {
            var ___ret = __Internal.UlibUint32Ceil2(x);
            return ___ret;
        }

        public static ulong UlibUint64Ceil2(ulong x)
        {
            var ___ret = __Internal.UlibUint64Ceil2(x);
            return ___ret;
        }

        public static uint UlibUint16Log2(ushort x)
        {
            var ___ret = __Internal.UlibUint16Log2(x);
            return ___ret;
        }

        public static uint UlibUint32Log2(uint x)
        {
            var ___ret = __Internal.UlibUint32Log2(x);
            return ___ret;
        }

        public static uint UlibUint64Log2(ulong x)
        {
            var ___ret = __Internal.UlibUint64Log2(x);
            return ___ret;
        }

        /// <summary>@{</summary>
        public static uint UlibUintFloor2(uint x)
        {
            var ___ret = __Internal.UlibUintFloor2(x);
            return ___ret;
        }

        public static uint UlibUintCeil2(uint x)
        {
            var ___ret = __Internal.UlibUintCeil2(x);
            return ___ret;
        }

        public static uint UlibUintLog2(uint x)
        {
            var ___ret = __Internal.UlibUintLog2(x);
            return ___ret;
        }

        /// <summary>@{</summary>
        public static double UlibFloatPrev(double x)
        {
            var ___ret = __Internal.UlibFloatPrev(x);
            return ___ret;
        }

        public static double UlibFloatNext(double x)
        {
            var ___ret = __Internal.UlibFloatNext(x);
            return ___ret;
        }

        /// <summary>Returns two to the power of `x`.</summary>
        /// <param name="x">Exponent.</param>
        /// <returns>Two to the power of `x`.</returns>
        public static uint UlibUintPow2(byte x)
        {
            var ___ret = __Internal.UlibUintPow2(x);
            return ___ret;
        }

        /// <summary>Checks whether `x` is a power of two.</summary>
        /// <param name="x">Unsigned integer.</param>
        /// <returns>True if `x` is a power of two, false otherwise.</returns>
        public static bool UlibUintIsPow2(uint x)
        {
            var ___ret = __Internal.UlibUintIsPow2(x);
            return ___ret;
        }
    }

    public unsafe partial class ubit
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_count_set_8@@YAIE@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitCountSet8(byte mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_count_set_16@@YAIG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitCountSet16(ushort mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_count_set_32@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitCountSet32(uint mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_count_set_64@@YAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitCountSet64(ulong mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_first_set_8@@YAIE@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitFirstSet8(byte mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_first_set_16@@YAIG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitFirstSet16(ushort mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_first_set_32@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitFirstSet32(uint mask);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ubit_first_set_64@@YAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUbitFirstSet64(ulong mask);
        }

        public static uint PUbitCountSet8(byte mask)
        {
            var ___ret = __Internal.PUbitCountSet8(mask);
            return ___ret;
        }

        public static uint PUbitCountSet16(ushort mask)
        {
            var ___ret = __Internal.PUbitCountSet16(mask);
            return ___ret;
        }

        public static uint PUbitCountSet32(uint mask)
        {
            var ___ret = __Internal.PUbitCountSet32(mask);
            return ___ret;
        }

        public static uint PUbitCountSet64(ulong mask)
        {
            var ___ret = __Internal.PUbitCountSet64(mask);
            return ___ret;
        }

        public static uint PUbitFirstSet8(byte mask)
        {
            var ___ret = __Internal.PUbitFirstSet8(mask);
            return ___ret;
        }

        public static uint PUbitFirstSet16(ushort mask)
        {
            var ___ret = __Internal.PUbitFirstSet16(mask);
            return ___ret;
        }

        public static uint PUbitFirstSet32(uint mask)
        {
            var ___ret = __Internal.PUbitFirstSet32(mask);
            return ___ret;
        }

        public static uint PUbitFirstSet64(ulong mask)
        {
            var ___ret = __Internal.PUbitFirstSet64(mask);
            return ___ret;
        }
    }

    /// <summary>Return codes.</summary>
    public enum UhashRet
    {
        /// <summary>
        /// <para>The operation failed.</para>
        /// <para>As of right now, it can only happen if memory cannot be allocated.</para>
        /// </summary>
        UHASH_ERR = -1,
        /// <summary>The operation succeeded.</summary>
        UHASH_OK = 0,
        /// <summary>The key is already present.</summary>
        UHASH_PRESENT = 0,
        /// <summary>The key has been inserted (it was absent).</summary>
        UHASH_INSERTED = 1
    }

    /// <summary>Return codes.</summary>
    /// <summary>Return codes.</summary>
    public enum UlibRet
    {
        /// <summary>The operation succeeded.</summary>
        ULIB_OK = 0,
        /// <summary>The operation failed due to a memory error.</summary>
        ULIB_ERR_MEM = 1,
        /// <summary>The operation failed due to an unspecified error.</summary>
        ULIB_ERR = 2
    }

    /// <summary>Return codes.</summary>
    public unsafe partial class ustring_raw
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_char_is_upper@@YA_ND@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibCharIsUpper(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_char_is_lower@@YA_ND@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibCharIsLower(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_char_to_upper@@YADD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte UlibCharToUpper(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_char_to_lower@@YADD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte UlibCharToLower(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_equals@@YA_NPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibStrEquals([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string lhs, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_str_dup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* UlibStrDup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_str_flength", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong UlibStrFlength([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_is_upper@@YA_NPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibStrIsUpper([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_is_lower@@YA_NPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UlibStrIsLower([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_to_upper@@YAXPEADPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UlibStrToUpper(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_to_lower@@YAXPEADPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UlibStrToLower(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_to_int@@YAHPEBDPEAPEADI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UlibStrToInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, sbyte** end, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_to_uint@@YAIPEBDPEAPEADI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibStrToUint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, sbyte** end, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_str_to_float@@YANPEBDPEAPEAD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UlibStrToFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, sbyte** end);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_mem_chr_last", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UlibMemChrLast(__IntPtr haystack, int c, ulong h_len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_mem_mem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UlibMemMem(__IntPtr haystack, ulong h_len, __IntPtr needle, ulong n_len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_mem_mem_last", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UlibMemMemLast(__IntPtr haystack, ulong h_len, __IntPtr needle, ulong n_len);
        }

        /// <summary>Checks if the specified character is an uppercase letter.</summary>
        /// <param name="c">Character.</param>
        /// <returns>True if the character is an uppercase letter, false otherwise.</returns>
        public static bool UlibCharIsUpper(sbyte c)
        {
            var ___ret = __Internal.UlibCharIsUpper(c);
            return ___ret;
        }

        /// <summary>Checks if the specified character is a lowercase letter.</summary>
        /// <param name="c">Character.</param>
        /// <returns>True if the character is a lowercase letter, false otherwise.</returns>
        public static bool UlibCharIsLower(sbyte c)
        {
            var ___ret = __Internal.UlibCharIsLower(c);
            return ___ret;
        }

        /// <summary>Converts the given character to uppercase.</summary>
        /// <param name="c">Character to convert.</param>
        /// <returns>Uppercase character.</returns>
        public static sbyte UlibCharToUpper(sbyte c)
        {
            var ___ret = __Internal.UlibCharToUpper(c);
            return ___ret;
        }

        /// <summary>Converts the given character to lowercase.</summary>
        /// <param name="c">Character to convert.</param>
        /// <returns>Lowercase character.</returns>
        public static sbyte UlibCharToLower(sbyte c)
        {
            var ___ret = __Internal.UlibCharToLower(c);
            return ___ret;
        }

        /// <summary>Checks whether two strings are equal.</summary>
        /// <param name="lhs">First string.</param>
        /// <param name="rhs">Second string.</param>
        /// <returns>True if the two strings are equal, false otherwise.</returns>
        public static bool UlibStrEquals(string lhs, string rhs)
        {
            var ___ret = __Internal.UlibStrEquals(lhs, rhs);
            return ___ret;
        }

        /// <summary>Duplicates the specified string.</summary>
        /// <param name="string">String to duplicate.</param>
        /// <param name="length">Length of the string to duplicate.</param>
        /// <returns>Duplicated string.</returns>
        public static sbyte* UlibStrDup(string @string, ulong length)
        {
            var ___ret = __Internal.UlibStrDup(@string, length);
            return ___ret;
        }

        /// <summary>Returns the length of the specified formatted string.</summary>
        /// <param name="format">Format string.</param>
        /// <param name="...">Format arguments.</param>
        /// <returns>Length of the formatted string.</returns>
        public static ulong UlibStrFlength(string format)
        {
            var ___ret = __Internal.UlibStrFlength(format);
            return ___ret;
        }

        /// <summary>Checks if the string does not contain lowercase characters.</summary>
        /// <param name="string">String.</param>
        /// <param name="length">String length.</param>
        /// <returns>True if the string does not contain lowercase characters, false otherwise.</returns>
        public static bool UlibStrIsUpper(string @string, ulong length)
        {
            var ___ret = __Internal.UlibStrIsUpper(@string, length);
            return ___ret;
        }

        /// <summary>Checks if the string does not contain uppercase characters.</summary>
        /// <param name="string">String.</param>
        /// <param name="length">String length.</param>
        /// <returns>True if the string does not contain uppercase characters, false otherwise.</returns>
        public static bool UlibStrIsLower(string @string, ulong length)
        {
            var ___ret = __Internal.UlibStrIsLower(@string, length);
            return ___ret;
        }

        /// <summary>Converts the given string to uppercase.</summary>
        /// <param name="dst">Destination string.</param>
        /// <param name="src">Source string.</param>
        /// <param name="length">Length of the source string.</param>
        /// <remarks>`dst` and `src` can be equal.</remarks>
        public static void UlibStrToUpper(sbyte* dst, string src, ulong length)
        {
            __Internal.UlibStrToUpper(dst, src, length);
        }

        /// <summary>Converts the given string to lowercase.</summary>
        /// <param name="dst">Destination string.</param>
        /// <param name="src">Source string.</param>
        /// <param name="length">Length of the source string</param>
        /// <remarks>`dst` and `src` can be equal.</remarks>
        public static void UlibStrToLower(sbyte* dst, string src, ulong length)
        {
            __Internal.UlibStrToLower(dst, src, length);
        }

        /// <summary>Converts the given string into an integer.</summary>
        /// <param name="src">Source string.</param>
        /// <param name="end">End pointer.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Integer.</returns>
        /// <remarks>
        /// <para>Size-appropriate wrapper for{strtol()} and{strtoll()}.</para>
        /// <para>Refer to their documentation for extended information (e.g. error handling).</para>
        /// </remarks>
        public static int UlibStrToInt(string src, sbyte** end, uint @base)
        {
            var ___ret = __Internal.UlibStrToInt(src, end, @base);
            return ___ret;
        }

        /// <summary>Converts the given string into an unsigned integer.</summary>
        /// <param name="src">Source string.</param>
        /// <param name="end">End pointer.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Unsigned integer.</returns>
        /// <remarks>
        /// <para>Size-appropriate wrapper for{strtoul()} and{strtoull()}.</para>
        /// <para>Refer to their documentation for extended information (e.g. error handling).</para>
        /// </remarks>
        public static uint UlibStrToUint(string src, sbyte** end, uint @base)
        {
            var ___ret = __Internal.UlibStrToUint(src, end, @base);
            return ___ret;
        }

        /// <summary>Converts the given string into a float.</summary>
        /// <param name="src">Source string.</param>
        /// <param name="end">End pointer.</param>
        /// <returns>Float.</returns>
        /// <remarks>
        /// <para>Size-appropriate wrapper for{strtof()} and{strtod()}.</para>
        /// <para>Refer to their documentation for extended information (e.g. error handling).</para>
        /// </remarks>
        public static double UlibStrToFloat(string src, sbyte** end)
        {
            var ___ret = __Internal.UlibStrToFloat(src, end);
            return ___ret;
        }

        /// <summary>Finds the last occurrence of a character.</summary>
        /// <param name="haystack">Memory area.</param>
        /// <param name="c">Character to find.</param>
        /// <param name="h_len">Length of the memory area.</param>
        /// <returns>Pointer to the first occurrence of the character, or NULL.</returns>
        public static __IntPtr UlibMemChrLast(__IntPtr haystack, int c, ulong h_len)
        {
            var ___ret = __Internal.UlibMemChrLast(haystack, c, h_len);
            return ___ret;
        }

        /// <summary>Finds the first occurrence of the specified substring.</summary>
        /// <param name="haystack">Memory area.</param>
        /// <param name="h_len">Length of the memory area.</param>
        /// <param name="needle">Substring.</param>
        /// <param name="n_len">Length of the substring.</param>
        /// <returns>Pointer to the first occurrence of the substring, or NULL.</returns>
        public static __IntPtr UlibMemMem(__IntPtr haystack, ulong h_len, __IntPtr needle, ulong n_len)
        {
            var ___ret = __Internal.UlibMemMem(haystack, h_len, needle, n_len);
            return ___ret;
        }

        /// <summary>Finds the last occurrence of the specified substring.</summary>
        /// <param name="haystack">Memory area.</param>
        /// <param name="h_len">Length of the memory area.</param>
        /// <param name="needle">Substring.</param>
        /// <param name="n_len">Length of the substring.</param>
        /// <returns>Pointer to the last occurrence of the substring, or NULL.</returns>
        public static __IntPtr UlibMemMemLast(__IntPtr haystack, ulong h_len, __IntPtr needle, ulong n_len)
        {
            var ___ret = __Internal.UlibMemMemLast(haystack, h_len, needle, n_len);
            return ___ret;
        }
    }

    /// <summary>An immutable string.</summary>
    public unsafe partial class PUstringSizing : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _s;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_ustring_sizing@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUstringSizing> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUstringSizing>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUstringSizing managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUstringSizing managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool ___d_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static PUstringSizing __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUstringSizing(native.ToPointer(), skipVTables);
        }

        internal static PUstringSizing __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUstringSizing)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUstringSizing __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUstringSizing(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUstringSizing(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUstringSizing(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUstringSizing()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUstringSizing.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUstringSizing(global::cowl.PUstringSizing _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUstringSizing.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUstringSizing.__Internal*) __Instance) = *((global::cowl.PUstringSizing.__Internal*) _0.__Instance);
            if (_0.___d_OwnsNativeMemory)
                this.D = _0.D;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (___d_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->_d);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string D
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_d);
            }

            set
            {
                if (___d_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->_d);
                ___d_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->_d = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->_d = (__IntPtr) __bytePtr0;
            }
        }

        public uint S
        {
            get
            {
                return ((__Internal*)__Instance)->_s;
            }

            set
            {
                ((__Internal*)__Instance)->_s = value;
            }
        }
    }

    public unsafe partial class PUstringLarge : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal fixed byte _flags[8];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_ustring_large@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUstringLarge> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUstringLarge>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUstringLarge managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUstringLarge managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool ___data_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static PUstringLarge __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUstringLarge(native.ToPointer(), skipVTables);
        }

        internal static PUstringLarge __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUstringLarge)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUstringLarge __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUstringLarge(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUstringLarge(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUstringLarge(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUstringLarge()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUstringLarge.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUstringLarge(global::cowl.PUstringLarge _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUstringLarge.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUstringLarge.__Internal*) __Instance) = *((global::cowl.PUstringLarge.__Internal*) _0.__Instance);
            if (_0.___data_OwnsNativeMemory)
                this.Data = _0.Data;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (___data_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->_data);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_data);
            }

            set
            {
                if (___data_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->_data);
                ___data_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->_data = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->_data = (__IntPtr) __bytePtr0;
            }
        }

        public byte[] Flags
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_flags, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->_flags[i] = value[i];
                }
            }
        }
    }

    /// <summary>An immutable string.</summary>
    public unsafe partial class UString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUstringLarge.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ustring_large_size@@YAIUp_ustring_large@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUstringLargeSize(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_size@@YAIUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringSize(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_length@@YAIUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringLength(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_assign", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringAssign(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_copy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringCopy(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_wrap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringWrap(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* Ustring(__IntPtr @string, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_assign_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringAssignBuf(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_copy_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringCopyBuf(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_wrap_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringWrapBuf(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_dup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringDup(__IntPtr @return, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_with_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringWithFormat(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_range@@YA?AUUString@@U1@II@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringRange(__IntPtr @return, __IntPtr str, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_concat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringConcat(__IntPtr @return, __IntPtr strings, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_join", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringJoin(__IntPtr @return, __IntPtr strings, uint count, __IntPtr sep);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_repeating", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringRepeating(__IntPtr @return, __IntPtr @string, uint times);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_replacing_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringReplacingChar(__IntPtr @return, __IntPtr @string, sbyte needle, sbyte replacement);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_is_upper@@YA_NUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringIsUpper(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_is_lower@@YA_NUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringIsLower(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_to_upper", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringToUpper(__IntPtr @return, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_to_lower", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringToLower(__IntPtr @return, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_index_of", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringIndexOf(__IntPtr @string, sbyte needle);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_index_of_last", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringIndexOfLast(__IntPtr @string, sbyte needle);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_find", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringFind(__IntPtr @string, __IntPtr needle);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_find_last", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringFindLast(__IntPtr @string, __IntPtr needle);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_starts_with", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringStartsWith(__IntPtr @string, __IntPtr prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_ends_with", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringEndsWith(__IntPtr @string, __IntPtr suffix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_equals", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringEquals(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_precedes", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringPrecedes(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_compare", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UstringCompare(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_hash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UstringHash(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_to_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UlibRet UstringToInt(__IntPtr @string, int* @out, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_to_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UlibRet UstringToUint(__IntPtr @string, uint* @out, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_to_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UlibRet UstringToFloat(__IntPtr @string, double* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstringDeinit(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustring_deinit_return_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* UstringDeinitReturnData(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_is_null@@YA_NUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringIsNull(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ustring_is_empty@@YA_NUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UstringIsEmpty(__IntPtr @string);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UString(native.ToPointer(), skipVTables);
        }

        internal static UString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UString(global::cowl.UString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UString.__Internal*) __Instance) = *((global::cowl.UString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static uint PUstringLargeSize(global::cowl.PUstringLarge @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.PUstringLargeSize(__arg0);
            return ___ret;
        }

        /// <summary>Returns the size of the string.</summary>
        /// <param name="string">String.</param>
        /// <returns>String size.</returns>
        public static uint UstringSize(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringSize(__arg0);
            return ___ret;
        }

        /// <summary>Returns the length of the string, excluding the null terminator.</summary>
        /// <param name="string">String.</param>
        /// <returns>String length.</returns>
        public static uint UstringLength(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringLength(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Initializes a new string by taking ownership of the specified buffer,</para>
        /// <para>which must have been dynamically allocated.</para>
        /// </summary>
        /// <param name="buf">String buffer.</param>
        /// <param name="length">Length of the string (excluding the null terminator).</param>
        /// <returns>New string.</returns>
        /// <remarks>
        /// <para>The buffer must be null-terminated.</para>
        /// <para>Due to the internals of{#UString}, you must not attempt to access the buffer</para>
        /// <para>after calling this function as it may have been deallocated.</para>
        /// </remarks>
        public static global::cowl.UString UstringAssign(string buf, ulong length)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringAssign(new IntPtr(&___ret), buf, length);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Initializes a new string by copying the specified buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <param name="length">Length of the string (excluding the null terminator).</param>
        /// <returns>New string.</returns>
        public static global::cowl.UString UstringCopy(string buf, ulong length)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringCopy(new IntPtr(&___ret), buf, length);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Initializes a new string by wrapping the specified buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <param name="length">Length of the string (excluding the null terminator).</param>
        /// <returns>New string.</returns>
        /// <remarks>
        /// <para>The buffer must be null-terminated.</para>
        /// <para>If the buffer has been dynamically allocated, you are responsible for its deallocation.</para>
        /// <para>You must not call{#ustring_deinit()} on a string initialized with this function.</para>
        /// </remarks>
        public static global::cowl.UString UstringWrap(string buf, ulong length)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringWrap(new IntPtr(&___ret), buf, length);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>
        /// <para>Initializes a new string of the specified length and returns its underlying buffer.</para>
        /// <para>This allows direct initialization of the buffer, avoiding unnecessary allocations or copies.</para>
        /// </summary>
        /// <param name="string">String to initialize.</param>
        /// <param name="length">Length of the string (excluding the null terminator).</param>
        /// <returns>Underlying buffer.</returns>
        /// <remarks>The returned buffer is null-terminated but otherwise uninitialized.</remarks>
        public static sbyte* Ustring(global::cowl.UString @string, ulong length)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.Ustring(__arg0, length);
            return ___ret;
        }

        /// <summary>
        /// <para>Initializes a new string by taking ownership of the specified buffer,</para>
        /// <para>which must have been dynamically allocated.</para>
        /// </summary>
        /// <param name="buf">String buffer.</param>
        /// <returns>New string.</returns>
        /// <remarks>
        /// <para>The buffer must be null-terminated.</para>
        /// <para>Due to the internals of{#UString}, you must not attempt to access the buffer</para>
        /// <para>after calling this function as it may have been deallocated.</para>
        /// </remarks>
        public static global::cowl.UString UstringAssignBuf(string buf)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringAssignBuf(new IntPtr(&___ret), buf);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Initializes a new string by copying the specified buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <returns>New string.</returns>
        /// <remarks>The buffer must be null-terminated.</remarks>
        public static global::cowl.UString UstringCopyBuf(string buf)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringCopyBuf(new IntPtr(&___ret), buf);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Initializes a new string by wrapping the specified buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <returns>New string.</returns>
        /// <remarks>
        /// <para>The buffer must be null-terminated.</para>
        /// <para>If the buffer has been dynamically allocated, you are responsible for its deallocation.</para>
        /// <para>You must not call{#ustring_deinit()} on a string initialized with this function.</para>
        /// </remarks>
        public static global::cowl.UString UstringWrapBuf(string buf)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringWrapBuf(new IntPtr(&___ret), buf);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Duplicates the specified string.</summary>
        /// <param name="string">String to duplicate.</param>
        /// <returns>Duplicated string.</returns>
        public static global::cowl.UString UstringDup(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringDup(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Initializes a new string with the specified format.</summary>
        /// <param name="format">Format string.</param>
        /// <param name="...">Format arguments.</param>
        /// <returns>New string.</returns>
        public static global::cowl.UString UstringWithFormat(string format)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringWithFormat(new IntPtr(&___ret), format);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a new string containing the characters in a range of the specified string.</summary>
        /// <param name="str">String.</param>
        /// <param name="start">Range start.</param>
        /// <param name="len">Range length.</param>
        /// <returns>New string.</returns>
        public static global::cowl.UString UstringRange(global::cowl.UString str, uint start, uint len)
        {
            if (ReferenceEquals(str, null))
                throw new global::System.ArgumentNullException("str", "Cannot be null because it is passed by value.");
            var __arg0 = str.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringRange(new IntPtr(&___ret), __arg0, start, len);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Concatenates the specified strings.</summary>
        /// <param name="strings">Strings to concatenate.</param>
        /// <param name="count">Number of strings.</param>
        /// <returns>Concatenation of the specified strings.</returns>
        public static global::cowl.UString UstringConcat(global::cowl.UString strings, uint count)
        {
            var __arg0 = strings is null ? __IntPtr.Zero : strings.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringConcat(new IntPtr(&___ret), __arg0, count);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Joins the specified strings with a separator.</summary>
        /// <param name="strings">Strings to join.</param>
        /// <param name="count">Number of strings.</param>
        /// <param name="sep">Separator.</param>
        /// <returns>Strings joined with the specified separator.</returns>
        public static global::cowl.UString UstringJoin(global::cowl.UString strings, uint count, global::cowl.UString sep)
        {
            var __arg0 = strings is null ? __IntPtr.Zero : strings.__Instance;
            if (ReferenceEquals(sep, null))
                throw new global::System.ArgumentNullException("sep", "Cannot be null because it is passed by value.");
            var __arg2 = sep.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringJoin(new IntPtr(&___ret), __arg0, count, __arg2);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a new string obtained by repeating the specified string.</summary>
        /// <param name="string">String to repeat.</param>
        /// <param name="times">Number of repetitions.</param>
        /// <returns>New string.</returns>
        public static global::cowl.UString UstringRepeating(global::cowl.UString @string, uint times)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringRepeating(new IntPtr(&___ret), __arg0, times);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a new string obtained by replacing all occurrences of a character with another.</summary>
        /// <param name="string">String.</param>
        /// <param name="needle">Character to replace.</param>
        /// <param name="replacement">Replacement character.</param>
        /// <returns>New string.</returns>
        public static global::cowl.UString UstringReplacingChar(global::cowl.UString @string, sbyte needle, sbyte replacement)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringReplacingChar(new IntPtr(&___ret), __arg0, needle, replacement);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Checks if the string does not contain lowercase characters.</summary>
        /// <param name="string">String.</param>
        /// <returns>True if the string does not contain lowercase characters, false otherwise.</returns>
        public static bool UstringIsUpper(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIsUpper(__arg0);
            return ___ret;
        }

        /// <summary>Checks if the string does not contain uppercase characters.</summary>
        /// <param name="string">String.</param>
        /// <returns>True if the string does not contain uppercase characters, false otherwise.</returns>
        public static bool UstringIsLower(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIsLower(__arg0);
            return ___ret;
        }

        /// <summary>Converts the given string to uppercase.</summary>
        /// <param name="string">String to convert.</param>
        /// <returns>Uppercase string.</returns>
        public static global::cowl.UString UstringToUpper(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringToUpper(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Converts the given string to lowercase.</summary>
        /// <param name="string">String to convert.</param>
        /// <returns>Lowercase string.</returns>
        public static global::cowl.UString UstringToLower(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstringToLower(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns the index of the first occurrence of the specified character.</summary>
        /// <param name="string">String to search into.</param>
        /// <param name="needle">Character to find.</param>
        /// <returns>
        /// <para>Index of the first occurrence of the specified character.</para>
        /// <para>If it cannot be found, returns an index greater than or equal to the string's length.</para>
        /// </returns>
        public static uint UstringIndexOf(global::cowl.UString @string, sbyte needle)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIndexOf(__arg0, needle);
            return ___ret;
        }

        /// <summary>Returns the index of the last occurrence of the specified character.</summary>
        /// <param name="string">String to search into.</param>
        /// <param name="needle">Character to find.</param>
        /// <returns>
        /// <para>Index of the last occurrence of the specified character.</para>
        /// <para>If it cannot be found, returns an index greater than or equal to the string's length.</para>
        /// </returns>
        public static uint UstringIndexOfLast(global::cowl.UString @string, sbyte needle)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIndexOfLast(__arg0, needle);
            return ___ret;
        }

        /// <summary>Returns the index of the first occurrence of the specified string.</summary>
        /// <param name="string">String to search into.</param>
        /// <param name="needle">String to find.</param>
        /// <returns>
        /// <para>Index of the first occurrence of the specified string.</para>
        /// <para>If it cannot be found, returns an index greater than or equal to the string's length.</para>
        /// </returns>
        public static uint UstringFind(global::cowl.UString @string, global::cowl.UString needle)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            if (ReferenceEquals(needle, null))
                throw new global::System.ArgumentNullException("needle", "Cannot be null because it is passed by value.");
            var __arg1 = needle.__Instance;
            var ___ret = __Internal.UstringFind(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Returns the index of the last occurrence of the specified string.</summary>
        /// <param name="string">String to search into.</param>
        /// <param name="needle">String to find.</param>
        /// <returns>
        /// <para>Index of the last occurrence of the specified string.</para>
        /// <para>If it cannot be found, returns an index greater than or equal to the string's length.</para>
        /// </returns>
        public static uint UstringFindLast(global::cowl.UString @string, global::cowl.UString needle)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            if (ReferenceEquals(needle, null))
                throw new global::System.ArgumentNullException("needle", "Cannot be null because it is passed by value.");
            var __arg1 = needle.__Instance;
            var ___ret = __Internal.UstringFindLast(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Checks whether the string starts with the specified prefix.</summary>
        /// <param name="string">String.</param>
        /// <param name="prefix">Prefix.</param>
        /// <returns>True if the string starts with the specified prefix, false otherwise.</returns>
        public static bool UstringStartsWith(global::cowl.UString @string, global::cowl.UString prefix)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            if (ReferenceEquals(prefix, null))
                throw new global::System.ArgumentNullException("prefix", "Cannot be null because it is passed by value.");
            var __arg1 = prefix.__Instance;
            var ___ret = __Internal.UstringStartsWith(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Checks whether the string ends with the specified suffix.</summary>
        /// <param name="string">String.</param>
        /// <param name="suffix">Suffix.</param>
        /// <returns>True if the string ends with the specified suffix, false otherwise.</returns>
        public static bool UstringEndsWith(global::cowl.UString @string, global::cowl.UString suffix)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            if (ReferenceEquals(suffix, null))
                throw new global::System.ArgumentNullException("suffix", "Cannot be null because it is passed by value.");
            var __arg1 = suffix.__Instance;
            var ___ret = __Internal.UstringEndsWith(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Checks whether two strings are equal.</summary>
        /// <param name="lhs">First string.</param>
        /// <param name="rhs">Second string.</param>
        /// <returns>True if the two strings are equal, false otherwise.</returns>
        public static bool UstringEquals(global::cowl.UString lhs, global::cowl.UString rhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg1 = rhs.__Instance;
            var ___ret = __Internal.UstringEquals(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Checks whether lhs precedes rhs in lexicographic order.</summary>
        /// <param name="lhs">First string.</param>
        /// <param name="rhs">Second string.</param>
        /// <returns>True if `lhs` precedes `rhs`, False otherwise.</returns>
        public static bool UstringPrecedes(global::cowl.UString lhs, global::cowl.UString rhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg1 = rhs.__Instance;
            var ___ret = __Internal.UstringPrecedes(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Compares lhs and rhs in lexicographic order.</summary>
        /// <param name="lhs">First string.</param>
        /// <param name="rhs">Second string.</param>
        /// <returns>-1 if `lhs` comes before `rhs`, 0 if they are equal, 1 if `lhs` comes after `rhs`.</returns>
        public static int UstringCompare(global::cowl.UString lhs, global::cowl.UString rhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg1 = rhs.__Instance;
            var ___ret = __Internal.UstringCompare(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Returns the hash of the specified string.</summary>
        /// <param name="string">String.</param>
        /// <returns>Hash.</returns>
        public static uint UstringHash(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringHash(__arg0);
            return ___ret;
        }

        /// <summary>Converts the string into an integer.</summary>
        /// <param name="string">String.</param>
        /// <param name="out">Converted value.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UlibRet UstringToInt(global::cowl.UString @string, ref int @out, uint @base)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            fixed (int* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.UstringToInt(__arg0, __arg1, @base);
                return ___ret;
            }
        }

        /// <summary>Converts the string into an unsigned integer.</summary>
        /// <param name="string">String.</param>
        /// <param name="out">Converted value.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UlibRet UstringToUint(global::cowl.UString @string, ref uint @out, uint @base)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            fixed (uint* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.UstringToUint(__arg0, __arg1, @base);
                return ___ret;
            }
        }

        /// <summary>Converts the string into a float.</summary>
        /// <param name="string">String.</param>
        /// <param name="out">Converted value.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UlibRet UstringToFloat(global::cowl.UString @string, ref double @out)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            fixed (double* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.UstringToFloat(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Deinitializes the specified string.</summary>
        /// <param name="string">String to deinitialize.</param>
        public static void UstringDeinit(global::cowl.UString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            __Internal.UstringDeinit(__arg0);
        }

        /// <summary>Deinitializes the specified string, returning its underlying buffer.</summary>
        /// <param name="string">String to deinitialize.</param>
        /// <returns>Buffer.</returns>
        public static sbyte* UstringDeinitReturnData(global::cowl.UString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.UstringDeinitReturnData(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the string has a NULL buffer.</summary>
        /// <param name="string">String instance.</param>
        /// <returns>True if the string has a NULL buffer, false otherwise.</returns>
        public static bool UstringIsNull(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIsNull(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the string is empty.</summary>
        /// <param name="string">String instance.</param>
        /// <returns>True if the string is empty, false otherwise.</returns>
        /// <remarks>The null string is considered empty.</remarks>
        public static bool UstringIsEmpty(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.UstringIsEmpty(__arg0);
            return ___ret;
        }

        public global::cowl.PUstringLarge L
        {
            get
            {
                return global::cowl.PUstringLarge.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUstringLarge.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ustring
    {
        public partial struct __Internal
        {
        }

        /// <summary>String with a NULL buffer.</summary>
        public static global::cowl.UString UstringNull
        {
            get
            {
                var __ptr = (global::cowl.UString.__Internal*)global::cowl.__Symbols.cowl._ustring_null;
                return global::cowl.UString.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        /// <summary>Empty string.</summary>
        public static global::cowl.UString UstringEmpty
        {
            get
            {
                var __ptr = (global::cowl.UString.__Internal*)global::cowl.__Symbols.cowl._ustring_empty;
                return global::cowl.UString.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class uhash_func
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_ulib_hash_int64@@YAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUlibHashInt64(ulong key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_hash_kr2@@YAIPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibHashKr2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_hash_mem_kr2@@YAIIPEBX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibHashMemKr2(uint init, __IntPtr buf, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_hash_djb2@@YAIPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibHashDjb2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_hash_djb2_mem@@YAIIPEBX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibHashDjb2Mem(uint init, __IntPtr buf, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?ulib_hash_combine@@YAIII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UlibHashCombine(uint h1, uint h2);
        }

        public static uint PUlibHashInt64(ulong key)
        {
            var ___ret = __Internal.PUlibHashInt64(key);
            return ___ret;
        }

        /// <summary>
        /// <para>Hash function for strings.</para>
        /// <para>K&amp;R2nd edition hash function.</para>
        /// </summary>
        /// <param name="key">Pointer to a NULL-terminated string.</param>
        /// <returns>Hash value.</returns>
        public static uint UlibHashKr2(string key)
        {
            var ___ret = __Internal.UlibHashKr2(key);
            return ___ret;
        }

        /// <summary>
        /// <para>Hash function for memory buffers.</para>
        /// <para>K&amp;R2nd edition hash function.</para>
        /// </summary>
        /// <param name="init">Hash initialization constant.</param>
        /// <param name="buf">Pointer to the start of the buffer.</param>
        /// <param name="size">Size of the buffer.</param>
        /// <returns>Hash value.</returns>
        public static uint UlibHashMemKr2(uint init, __IntPtr buf, ulong size)
        {
            var ___ret = __Internal.UlibHashMemKr2(init, buf, size);
            return ___ret;
        }

        /// <summary>
        /// <para>Hash function for strings.</para>
        /// <para>Daniel J. Bernstein's &quot;djb2&quot; hash function.</para>
        /// </summary>
        /// <param name="key">Pointer to a NULL-terminated string.</param>
        /// <returns>Hash value.</returns>
        public static uint UlibHashDjb2(string key)
        {
            var ___ret = __Internal.UlibHashDjb2(key);
            return ___ret;
        }

        /// <summary>
        /// <para>Hash function for memory buffers.</para>
        /// <para>Daniel J. Bernstein's &quot;djb2&quot; hash function.</para>
        /// </summary>
        /// <param name="init">Hash initialization constant.</param>
        /// <param name="buf">Pointer to the start of the buffer.</param>
        /// <param name="size">Size of the buffer.</param>
        /// <returns>Hash value.</returns>
        public static uint UlibHashDjb2Mem(uint init, __IntPtr buf, ulong size)
        {
            var ___ret = __Internal.UlibHashDjb2Mem(init, buf, size);
            return ___ret;
        }

        /// <summary>Combines two hashes.</summary>
        /// <param name="h1">First hash.</param>
        /// <param name="h2">Second hash.</param>
        /// <returns>Combined hash.</returns>
        public static uint UlibHashCombine(uint h1, uint h2)
        {
            var ___ret = __Internal.UlibHashCombine(h1, h2);
            return ___ret;
        }
    }

    public unsafe partial class UHash_ulib_int : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint _size;
            internal uint _occupied;
            internal uint _count;
            internal __IntPtr _flags;
            internal __IntPtr _keys;
            internal __IntPtr _vals;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_int> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_int>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHash_ulib_int managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHash_ulib_int managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHash_ulib_int __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHash_ulib_int(native.ToPointer(), skipVTables);
        }

        internal static UHash_ulib_int __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHash_ulib_int)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHash_ulib_int __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHash_ulib_int(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHash_ulib_int(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHash_ulib_int(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHash_ulib_int()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHash_ulib_int(global::cowl.UHash_ulib_int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHash_ulib_int.__Internal*) __Instance) = *((global::cowl.UHash_ulib_int.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->_size;
            }

            set
            {
                ((__Internal*)__Instance)->_size = value;
            }
        }

        public uint Occupied
        {
            get
            {
                return ((__Internal*)__Instance)->_occupied;
            }

            set
            {
                ((__Internal*)__Instance)->_occupied = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public uint* Flags
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_flags;
            }

            set
            {
                ((__Internal*)__Instance)->_flags = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_int} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_int) UHash(ulib_int);</remarks>
        public int* Keys
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->_keys;
            }

            set
            {
                ((__Internal*)__Instance)->_keys = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_int} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_int) UHash(ulib_int);</remarks>
        public __IntPtr* Vals
        {
            get
            {
                return (__IntPtr*) ((__Internal*)__Instance)->_vals;
            }

            set
            {
                ((__Internal*)__Instance)->_vals = (__IntPtr)value;
            }
        }
    }

    public unsafe partial class UHashLoop_ulib_int : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr h;
            internal __IntPtr key;
            internal __IntPtr val;
            internal uint i;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_Loop_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_int> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_int>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashLoop_ulib_int managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashLoop_ulib_int managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashLoop_ulib_int __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashLoop_ulib_int(native.ToPointer(), skipVTables);
        }

        internal static UHashLoop_ulib_int __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashLoop_ulib_int)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashLoop_ulib_int __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashLoop_ulib_int(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashLoop_ulib_int(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashLoop_ulib_int(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashLoop_ulib_int()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashLoop_ulib_int(global::cowl.UHashLoop_ulib_int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashLoop_ulib_int.__Internal*) __Instance) = *((global::cowl.UHashLoop_ulib_int.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.UHash_ulib_int H
        {
            get
            {
                var __result0 = global::cowl.UHash_ulib_int.__GetOrCreateInstance(((__Internal*)__Instance)->h, false);
                return __result0;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_int} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_int) UHash(ulib_int);</remarks>
        public int* Key
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_int} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_int) UHash(ulib_int);</remarks>
        public __IntPtr* Val
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }
    }

    public unsafe partial class UHash_ulib_uint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint _size;
            internal uint _occupied;
            internal uint _count;
            internal __IntPtr _flags;
            internal __IntPtr _keys;
            internal __IntPtr _vals;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_uint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_uint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHash_ulib_uint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHash_ulib_uint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHash_ulib_uint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHash_ulib_uint(native.ToPointer(), skipVTables);
        }

        internal static UHash_ulib_uint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHash_ulib_uint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHash_ulib_uint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHash_ulib_uint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHash_ulib_uint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHash_ulib_uint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHash_ulib_uint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHash_ulib_uint(global::cowl.UHash_ulib_uint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHash_ulib_uint.__Internal*) __Instance) = *((global::cowl.UHash_ulib_uint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->_size;
            }

            set
            {
                ((__Internal*)__Instance)->_size = value;
            }
        }

        public uint Occupied
        {
            get
            {
                return ((__Internal*)__Instance)->_occupied;
            }

            set
            {
                ((__Internal*)__Instance)->_occupied = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public uint* Flags
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_flags;
            }

            set
            {
                ((__Internal*)__Instance)->_flags = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_uint} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_uint) UHash(ulib_uint);</remarks>
        public uint* Keys
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_keys;
            }

            set
            {
                ((__Internal*)__Instance)->_keys = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_uint} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_uint) UHash(ulib_uint);</remarks>
        public __IntPtr* Vals
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_vals;
            }

            set
            {
                ((__Internal*)__Instance)->_vals = (__IntPtr)value;
            }
        }
    }

    public unsafe partial class UHashLoop_ulib_uint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr h;
            internal __IntPtr key;
            internal __IntPtr val;
            internal uint i;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_Loop_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_uint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_uint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashLoop_ulib_uint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashLoop_ulib_uint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashLoop_ulib_uint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashLoop_ulib_uint(native.ToPointer(), skipVTables);
        }

        internal static UHashLoop_ulib_uint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashLoop_ulib_uint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashLoop_ulib_uint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashLoop_ulib_uint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashLoop_ulib_uint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashLoop_ulib_uint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashLoop_ulib_uint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashLoop_ulib_uint(global::cowl.UHashLoop_ulib_uint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashLoop_ulib_uint.__Internal*) __Instance) = *((global::cowl.UHashLoop_ulib_uint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.UHash_ulib_uint H
        {
            get
            {
                var __result0 = global::cowl.UHash_ulib_uint.__GetOrCreateInstance(((__Internal*)__Instance)->h, false);
                return __result0;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_uint} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_uint) UHash(ulib_uint);</remarks>
        public uint* Key
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_uint} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(ulib_uint) UHash(ulib_uint);</remarks>
        public __IntPtr* Val
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }
    }

    public unsafe partial class UHash_ulib_ptr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint _size;
            internal uint _occupied;
            internal uint _count;
            internal __IntPtr _flags;
            internal __IntPtr _keys;
            internal __IntPtr _vals;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_ptr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHash_ulib_ptr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHash_ulib_ptr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHash_ulib_ptr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHash_ulib_ptr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHash_ulib_ptr(native.ToPointer(), skipVTables);
        }

        internal static UHash_ulib_ptr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHash_ulib_ptr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHash_ulib_ptr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHash_ulib_ptr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHash_ulib_ptr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHash_ulib_ptr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHash_ulib_ptr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHash_ulib_ptr(global::cowl.UHash_ulib_ptr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHash_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHash_ulib_ptr.__Internal*) __Instance) = *((global::cowl.UHash_ulib_ptr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->_size;
            }

            set
            {
                ((__Internal*)__Instance)->_size = value;
            }
        }

        public uint Occupied
        {
            get
            {
                return ((__Internal*)__Instance)->_occupied;
            }

            set
            {
                ((__Internal*)__Instance)->_occupied = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public uint* Flags
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_flags;
            }

            set
            {
                ((__Internal*)__Instance)->_flags = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_ptr} keys and{#ulib_ptr} values.</summary>
        /// <remarks>
        /// <para>Expects pointers used as keys to have an alignment of</para>
        /// <para>typedef struct UHash(ulib_ptr) UHash(ulib_ptr);</para>
        /// </remarks>
        public __IntPtr* Keys
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_keys;
            }

            set
            {
                ((__Internal*)__Instance)->_keys = (__IntPtr)value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_ptr} keys and{#ulib_ptr} values.</summary>
        /// <remarks>
        /// <para>Expects pointers used as keys to have an alignment of</para>
        /// <para>typedef struct UHash(ulib_ptr) UHash(ulib_ptr);</para>
        /// </remarks>
        public __IntPtr* Vals
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_vals;
            }

            set
            {
                ((__Internal*)__Instance)->_vals = (__IntPtr)value;
            }
        }
    }

    public unsafe partial class UHashLoop_ulib_ptr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr h;
            internal __IntPtr key;
            internal __IntPtr val;
            internal uint i;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_Loop_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_ptr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoop_ulib_ptr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashLoop_ulib_ptr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashLoop_ulib_ptr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashLoop_ulib_ptr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashLoop_ulib_ptr(native.ToPointer(), skipVTables);
        }

        internal static UHashLoop_ulib_ptr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashLoop_ulib_ptr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashLoop_ulib_ptr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashLoop_ulib_ptr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashLoop_ulib_ptr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashLoop_ulib_ptr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashLoop_ulib_ptr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashLoop_ulib_ptr(global::cowl.UHashLoop_ulib_ptr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoop_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashLoop_ulib_ptr.__Internal*) __Instance) = *((global::cowl.UHashLoop_ulib_ptr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.UHash_ulib_ptr H
        {
            get
            {
                var __result0 = global::cowl.UHash_ulib_ptr.__GetOrCreateInstance(((__Internal*)__Instance)->h, false);
                return __result0;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_ptr} keys and{#ulib_ptr} values.</summary>
        /// <remarks>
        /// <para>Expects pointers used as keys to have an alignment of</para>
        /// <para>typedef struct UHash(ulib_ptr) UHash(ulib_ptr);</para>
        /// </remarks>
        public __IntPtr* Key
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = (__IntPtr)value;
            }
        }

        /// <summary>{#UHash(T)} with{#ulib_ptr} keys and{#ulib_ptr} values.</summary>
        /// <remarks>
        /// <para>Expects pointers used as keys to have an alignment of</para>
        /// <para>typedef struct UHash(ulib_ptr) UHash(ulib_ptr);</para>
        /// </remarks>
        public __IntPtr* Val
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }
    }

    public unsafe partial class UHashUString : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint _size;
            internal uint _occupied;
            internal uint _count;
            internal __IntPtr _flags;
            internal __IntPtr _keys;
            internal __IntPtr _vals;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashUString(native.ToPointer(), skipVTables);
        }

        internal static UHashUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashUString(global::cowl.UHashUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashUString.__Internal*) __Instance) = *((global::cowl.UHashUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->_size;
            }

            set
            {
                ((__Internal*)__Instance)->_size = value;
            }
        }

        public uint Occupied
        {
            get
            {
                return ((__Internal*)__Instance)->_occupied;
            }

            set
            {
                ((__Internal*)__Instance)->_occupied = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public uint* Flags
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_flags;
            }

            set
            {
                ((__Internal*)__Instance)->_flags = (__IntPtr) value;
            }
        }

        /// <summary>{#UHash(T)} with{#UString} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(UString) UHash(UString);</remarks>
        public global::cowl.UString Keys
        {
            get
            {
                var __result0 = global::cowl.UString.__GetOrCreateInstance(((__Internal*)__Instance)->_keys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_keys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>{#UHash(T)} with{#UString} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(UString) UHash(UString);</remarks>
        public __IntPtr* Vals
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_vals;
            }

            set
            {
                ((__Internal*)__Instance)->_vals = (__IntPtr)value;
            }
        }
    }

    public unsafe partial class UHashLoopUString : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr h;
            internal __IntPtr key;
            internal __IntPtr val;
            internal uint i;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_Loop_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoopUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoopUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashLoopUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashLoopUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashLoopUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashLoopUString(native.ToPointer(), skipVTables);
        }

        internal static UHashLoopUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashLoopUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashLoopUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashLoopUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashLoopUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashLoopUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashLoopUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoopUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashLoopUString(global::cowl.UHashLoopUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoopUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashLoopUString.__Internal*) __Instance) = *((global::cowl.UHashLoopUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.UHashUString H
        {
            get
            {
                var __result0 = global::cowl.UHashUString.__GetOrCreateInstance(((__Internal*)__Instance)->h, false);
                return __result0;
            }
        }

        /// <summary>{#UHash(T)} with{#UString} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(UString) UHash(UString);</remarks>
        public global::cowl.UString Key
        {
            get
            {
                var __result0 = global::cowl.UString.__GetOrCreateInstance(((__Internal*)__Instance)->key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>{#UHash(T)} with{#UString} keys and{#ulib_ptr} values.</summary>
        /// <remarks>typedef struct UHash(UString) UHash(UString);</remarks>
        public __IntPtr* Val
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }
    }

    public unsafe partial class uhash_builtin
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_deinit_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeinitUlibInt(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyUlibInt(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_as_set_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyAsSetUlibInt(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_clear_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashClearUlibInt(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_get_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashGetUlibInt(__IntPtr h, int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_resize_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashResizeUlibInt(__IntPtr h, uint new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_put_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashPutUlibInt(__IntPtr h, int key, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_delete_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeleteUlibInt(__IntPtr h, uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapUlibInt(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_get_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhmapGetUlibInt(__IntPtr h, int key, __IntPtr if_missing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_set_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapSetUlibInt(__IntPtr h, int key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_add_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapAddUlibInt(__IntPtr h, int key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_replace_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapReplaceUlibInt(__IntPtr h, int key, __IntPtr value, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapRemoveUlibInt(__IntPtr h, int key, int* r_key, __IntPtr* r_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetUlibInt(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertUlibInt(__IntPtr h, int key, int* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_all_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertAllUlibInt(__IntPtr h, int* items, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_replace_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetReplaceUlibInt(__IntPtr h, int key, int* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetRemoveUlibInt(__IntPtr h, int key, int* removed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_is_superset_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetIsSupersetUlibInt(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_union_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetUnionUlibInt(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_intersect_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetIntersectUlibInt(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_hash_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetHashUlibInt(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_get_any_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UhsetGetAnyUlibInt(__IntPtr h, int if_empty);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_is_map_ulib_int@@YA_NPEBUUHash_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhashIsMapUlibInt(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_move_ulib_int@@YA?AUUHash_ulib_int@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashMoveUlibInt(__IntPtr @return, __IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_next_ulib_int@@YAIPEBUUHash_ulib_int@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashNextUlibInt(__IntPtr h, uint i);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhset_equals_ulib_int@@YA_NPEBUUHash_ulib_int@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetEqualsUlibInt(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uhash_occupied_ulib_int@@YAIPEBUUHash_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUhashOccupiedUlibInt(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_deinit_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeinitUlibUint(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyUlibUint(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_as_set_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyAsSetUlibUint(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_clear_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashClearUlibUint(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_get_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashGetUlibUint(__IntPtr h, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_resize_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashResizeUlibUint(__IntPtr h, uint new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_put_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashPutUlibUint(__IntPtr h, uint key, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_delete_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeleteUlibUint(__IntPtr h, uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapUlibUint(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_get_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhmapGetUlibUint(__IntPtr h, uint key, __IntPtr if_missing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_set_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapSetUlibUint(__IntPtr h, uint key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_add_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapAddUlibUint(__IntPtr h, uint key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_replace_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapReplaceUlibUint(__IntPtr h, uint key, __IntPtr value, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapRemoveUlibUint(__IntPtr h, uint key, uint* r_key, __IntPtr* r_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetUlibUint(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertUlibUint(__IntPtr h, uint key, uint* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_all_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertAllUlibUint(__IntPtr h, uint* items, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_replace_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetReplaceUlibUint(__IntPtr h, uint key, uint* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetRemoveUlibUint(__IntPtr h, uint key, uint* removed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_is_superset_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetIsSupersetUlibUint(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_union_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetUnionUlibUint(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_intersect_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetIntersectUlibUint(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_hash_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetHashUlibUint(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_get_any_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetGetAnyUlibUint(__IntPtr h, uint if_empty);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_is_map_ulib_uint@@YA_NPEBUUHash_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhashIsMapUlibUint(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_move_ulib_uint@@YA?AUUHash_ulib_uint@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashMoveUlibUint(__IntPtr @return, __IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_next_ulib_uint@@YAIPEBUUHash_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashNextUlibUint(__IntPtr h, uint i);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhset_equals_ulib_uint@@YA_NPEBUUHash_ulib_uint@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetEqualsUlibUint(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uhash_occupied_ulib_uint@@YAIPEBUUHash_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUhashOccupiedUlibUint(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_deinit_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeinitUlibPtr(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyUlibPtr(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_as_set_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyAsSetUlibPtr(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_clear_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashClearUlibPtr(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_get_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashGetUlibPtr(__IntPtr h, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_resize_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashResizeUlibPtr(__IntPtr h, uint new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_put_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashPutUlibPtr(__IntPtr h, __IntPtr key, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_delete_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeleteUlibPtr(__IntPtr h, uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapUlibPtr(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_get_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhmapGetUlibPtr(__IntPtr h, __IntPtr key, __IntPtr if_missing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_set_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapSetUlibPtr(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_add_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapAddUlibPtr(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_replace_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapReplaceUlibPtr(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapRemoveUlibPtr(__IntPtr h, __IntPtr key, __IntPtr* r_key, __IntPtr* r_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetUlibPtr(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertUlibPtr(__IntPtr h, __IntPtr key, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_all_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertAllUlibPtr(__IntPtr h, __IntPtr* items, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_replace_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetReplaceUlibPtr(__IntPtr h, __IntPtr key, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetRemoveUlibPtr(__IntPtr h, __IntPtr key, __IntPtr* removed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_is_superset_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetIsSupersetUlibPtr(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_union_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetUnionUlibPtr(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_intersect_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetIntersectUlibPtr(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_hash_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetHashUlibPtr(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_get_any_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhsetGetAnyUlibPtr(__IntPtr h, __IntPtr if_empty);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_is_map_ulib_ptr@@YA_NPEBUUHash_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhashIsMapUlibPtr(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_move_ulib_ptr@@YA?AUUHash_ulib_ptr@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashMoveUlibPtr(__IntPtr @return, __IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_next_ulib_ptr@@YAIPEBUUHash_ulib_ptr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashNextUlibPtr(__IntPtr h, uint i);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhset_equals_ulib_ptr@@YA_NPEBUUHash_ulib_ptr@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetEqualsUlibPtr(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uhash_occupied_ulib_ptr@@YAIPEBUUHash_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUhashOccupiedUlibPtr(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_deinit_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeinitUString(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyUString(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_as_set_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyAsSetUString(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_clear_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashClearUString(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_get_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashGetUString(__IntPtr h, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_resize_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashResizeUString(__IntPtr h, uint new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_put_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashPutUString(__IntPtr h, __IntPtr key, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_delete_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeleteUString(__IntPtr h, uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapUString(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_get_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhmapGetUString(__IntPtr h, __IntPtr key, __IntPtr if_missing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_set_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapSetUString(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_add_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapAddUString(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_replace_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapReplaceUString(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapRemoveUString(__IntPtr h, __IntPtr key, __IntPtr r_key, __IntPtr* r_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetUString(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertUString(__IntPtr h, __IntPtr key, __IntPtr existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_all_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertAllUString(__IntPtr h, __IntPtr items, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_replace_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetReplaceUString(__IntPtr h, __IntPtr key, __IntPtr replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetRemoveUString(__IntPtr h, __IntPtr key, __IntPtr removed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_is_superset_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetIsSupersetUString(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_union_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetUnionUString(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_intersect_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetIntersectUString(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_hash_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetHashUString(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_get_any_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetGetAnyUString(__IntPtr @return, __IntPtr h, __IntPtr if_empty);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_is_map_UString@@YA_NPEBUUHash_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhashIsMapUString(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_move_UString@@YA?AUUHash_UString@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashMoveUString(__IntPtr @return, __IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_next_UString@@YAIPEBUUHash_UString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashNextUString(__IntPtr h, uint i);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhset_equals_UString@@YA_NPEBUUHash_UString@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetEqualsUString(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uhash_occupied_UString@@YAIPEBUUHash_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUhashOccupiedUString(__IntPtr h);
        }

        public static void UhashDeinitUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeinitUlibInt(__arg0);
        }

        public static global::cowl.UhashRet UhashCopyUlibInt(global::cowl.UHash_ulib_int src, global::cowl.UHash_ulib_int dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashCopyAsSetUlibInt(global::cowl.UHash_ulib_int src, global::cowl.UHash_ulib_int dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyAsSetUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static void UhashClearUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashClearUlibInt(__arg0);
        }

        public static uint UhashGetUlibInt(global::cowl.UHash_ulib_int h, int key)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashGetUlibInt(__arg0, key);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashResizeUlibInt(global::cowl.UHash_ulib_int h, uint new_size)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashResizeUlibInt(__arg0, new_size);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashPutUlibInt(global::cowl.UHash_ulib_int h, int key, ref uint idx)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UhashPutUlibInt(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static void UhashDeleteUlibInt(global::cowl.UHash_ulib_int h, uint x)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeleteUlibInt(__arg0, x);
        }

        public static global::cowl.UHash_ulib_int UhmapUlibInt()
        {
            var ___ret = new global::cowl.UHash_ulib_int.__Internal();
            __Internal.UhmapUlibInt(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_int.__CreateInstance(___ret);
        }

        public static __IntPtr UhmapGetUlibInt(global::cowl.UHash_ulib_int h, int key, __IntPtr if_missing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapGetUlibInt(__arg0, key, if_missing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapSetUlibInt(global::cowl.UHash_ulib_int h, int key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapSetUlibInt(__arg0, key, value, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapAddUlibInt(global::cowl.UHash_ulib_int h, int key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapAddUlibInt(__arg0, key, value, existing);
            return ___ret;
        }

        public static bool UhmapReplaceUlibInt(global::cowl.UHash_ulib_int h, int key, __IntPtr value, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapReplaceUlibInt(__arg0, key, value, replaced);
            return ___ret;
        }

        public static bool UhmapRemoveUlibInt(global::cowl.UHash_ulib_int h, int key, ref int r_key, __IntPtr* r_val)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (int* __r_key2 = &r_key)
            {
                var __arg2 = __r_key2;
                var ___ret = __Internal.UhmapRemoveUlibInt(__arg0, key, __arg2, r_val);
                return ___ret;
            }
        }

        public static global::cowl.UHash_ulib_int UhsetUlibInt()
        {
            var ___ret = new global::cowl.UHash_ulib_int.__Internal();
            __Internal.UhsetUlibInt(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_int.__CreateInstance(___ret);
        }

        public static global::cowl.UhashRet UhsetInsertUlibInt(global::cowl.UHash_ulib_int h, int key, ref int existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (int* __existing2 = &existing)
            {
                var __arg2 = __existing2;
                var ___ret = __Internal.UhsetInsertUlibInt(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UhashRet UhsetInsertAllUlibInt(global::cowl.UHash_ulib_int h, ref int items, uint n)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (int* __items1 = &items)
            {
                var __arg1 = __items1;
                var ___ret = __Internal.UhsetInsertAllUlibInt(__arg0, __arg1, n);
                return ___ret;
            }
        }

        public static bool UhsetReplaceUlibInt(global::cowl.UHash_ulib_int h, int key, ref int replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (int* __replaced2 = &replaced)
            {
                var __arg2 = __replaced2;
                var ___ret = __Internal.UhsetReplaceUlibInt(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static bool UhsetRemoveUlibInt(global::cowl.UHash_ulib_int h, int key, ref int removed)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (int* __removed2 = &removed)
            {
                var __arg2 = __removed2;
                var ___ret = __Internal.UhsetRemoveUlibInt(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static bool UhsetIsSupersetUlibInt(global::cowl.UHash_ulib_int h1, global::cowl.UHash_ulib_int h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetIsSupersetUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetUnionUlibInt(global::cowl.UHash_ulib_int h1, global::cowl.UHash_ulib_int h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetUnionUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static void UhsetIntersectUlibInt(global::cowl.UHash_ulib_int h1, global::cowl.UHash_ulib_int h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            __Internal.UhsetIntersectUlibInt(__arg0, __arg1);
        }

        public static uint UhsetHashUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetHashUlibInt(__arg0);
            return ___ret;
        }

        public static int UhsetGetAnyUlibInt(global::cowl.UHash_ulib_int h, int if_empty)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetGetAnyUlibInt(__arg0, if_empty);
            return ___ret;
        }

        public static bool UhashIsMapUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashIsMapUlibInt(__arg0);
            return ___ret;
        }

        public static global::cowl.UHash_ulib_int UhashMoveUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = new global::cowl.UHash_ulib_int.__Internal();
            __Internal.UhashMoveUlibInt(new IntPtr(&___ret), __arg0);
            return global::cowl.UHash_ulib_int.__CreateInstance(___ret);
        }

        public static uint UhashNextUlibInt(global::cowl.UHash_ulib_int h, uint i)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashNextUlibInt(__arg0, i);
            return ___ret;
        }

        public static bool UhsetEqualsUlibInt(global::cowl.UHash_ulib_int h1, global::cowl.UHash_ulib_int h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetEqualsUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static uint PUhashOccupiedUlibInt(global::cowl.UHash_ulib_int h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.PUhashOccupiedUlibInt(__arg0);
            return ___ret;
        }

        public static void UhashDeinitUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeinitUlibUint(__arg0);
        }

        public static global::cowl.UhashRet UhashCopyUlibUint(global::cowl.UHash_ulib_uint src, global::cowl.UHash_ulib_uint dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashCopyAsSetUlibUint(global::cowl.UHash_ulib_uint src, global::cowl.UHash_ulib_uint dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyAsSetUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static void UhashClearUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashClearUlibUint(__arg0);
        }

        public static uint UhashGetUlibUint(global::cowl.UHash_ulib_uint h, uint key)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashGetUlibUint(__arg0, key);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashResizeUlibUint(global::cowl.UHash_ulib_uint h, uint new_size)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashResizeUlibUint(__arg0, new_size);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashPutUlibUint(global::cowl.UHash_ulib_uint h, uint key, ref uint idx)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UhashPutUlibUint(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static void UhashDeleteUlibUint(global::cowl.UHash_ulib_uint h, uint x)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeleteUlibUint(__arg0, x);
        }

        public static global::cowl.UHash_ulib_uint UhmapUlibUint()
        {
            var ___ret = new global::cowl.UHash_ulib_uint.__Internal();
            __Internal.UhmapUlibUint(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_uint.__CreateInstance(___ret);
        }

        public static __IntPtr UhmapGetUlibUint(global::cowl.UHash_ulib_uint h, uint key, __IntPtr if_missing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapGetUlibUint(__arg0, key, if_missing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapSetUlibUint(global::cowl.UHash_ulib_uint h, uint key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapSetUlibUint(__arg0, key, value, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapAddUlibUint(global::cowl.UHash_ulib_uint h, uint key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapAddUlibUint(__arg0, key, value, existing);
            return ___ret;
        }

        public static bool UhmapReplaceUlibUint(global::cowl.UHash_ulib_uint h, uint key, __IntPtr value, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapReplaceUlibUint(__arg0, key, value, replaced);
            return ___ret;
        }

        public static bool UhmapRemoveUlibUint(global::cowl.UHash_ulib_uint h, uint key, ref uint r_key, __IntPtr* r_val)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __r_key2 = &r_key)
            {
                var __arg2 = __r_key2;
                var ___ret = __Internal.UhmapRemoveUlibUint(__arg0, key, __arg2, r_val);
                return ___ret;
            }
        }

        public static global::cowl.UHash_ulib_uint UhsetUlibUint()
        {
            var ___ret = new global::cowl.UHash_ulib_uint.__Internal();
            __Internal.UhsetUlibUint(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_uint.__CreateInstance(___ret);
        }

        public static global::cowl.UhashRet UhsetInsertUlibUint(global::cowl.UHash_ulib_uint h, uint key, ref uint existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __existing2 = &existing)
            {
                var __arg2 = __existing2;
                var ___ret = __Internal.UhsetInsertUlibUint(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UhashRet UhsetInsertAllUlibUint(global::cowl.UHash_ulib_uint h, ref uint items, uint n)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __items1 = &items)
            {
                var __arg1 = __items1;
                var ___ret = __Internal.UhsetInsertAllUlibUint(__arg0, __arg1, n);
                return ___ret;
            }
        }

        public static bool UhsetReplaceUlibUint(global::cowl.UHash_ulib_uint h, uint key, ref uint replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __replaced2 = &replaced)
            {
                var __arg2 = __replaced2;
                var ___ret = __Internal.UhsetReplaceUlibUint(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static bool UhsetRemoveUlibUint(global::cowl.UHash_ulib_uint h, uint key, ref uint removed)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __removed2 = &removed)
            {
                var __arg2 = __removed2;
                var ___ret = __Internal.UhsetRemoveUlibUint(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static bool UhsetIsSupersetUlibUint(global::cowl.UHash_ulib_uint h1, global::cowl.UHash_ulib_uint h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetIsSupersetUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetUnionUlibUint(global::cowl.UHash_ulib_uint h1, global::cowl.UHash_ulib_uint h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetUnionUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static void UhsetIntersectUlibUint(global::cowl.UHash_ulib_uint h1, global::cowl.UHash_ulib_uint h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            __Internal.UhsetIntersectUlibUint(__arg0, __arg1);
        }

        public static uint UhsetHashUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetHashUlibUint(__arg0);
            return ___ret;
        }

        public static uint UhsetGetAnyUlibUint(global::cowl.UHash_ulib_uint h, uint if_empty)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetGetAnyUlibUint(__arg0, if_empty);
            return ___ret;
        }

        public static bool UhashIsMapUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashIsMapUlibUint(__arg0);
            return ___ret;
        }

        public static global::cowl.UHash_ulib_uint UhashMoveUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = new global::cowl.UHash_ulib_uint.__Internal();
            __Internal.UhashMoveUlibUint(new IntPtr(&___ret), __arg0);
            return global::cowl.UHash_ulib_uint.__CreateInstance(___ret);
        }

        public static uint UhashNextUlibUint(global::cowl.UHash_ulib_uint h, uint i)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashNextUlibUint(__arg0, i);
            return ___ret;
        }

        public static bool UhsetEqualsUlibUint(global::cowl.UHash_ulib_uint h1, global::cowl.UHash_ulib_uint h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetEqualsUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static uint PUhashOccupiedUlibUint(global::cowl.UHash_ulib_uint h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.PUhashOccupiedUlibUint(__arg0);
            return ___ret;
        }

        public static void UhashDeinitUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeinitUlibPtr(__arg0);
        }

        public static global::cowl.UhashRet UhashCopyUlibPtr(global::cowl.UHash_ulib_ptr src, global::cowl.UHash_ulib_ptr dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashCopyAsSetUlibPtr(global::cowl.UHash_ulib_ptr src, global::cowl.UHash_ulib_ptr dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyAsSetUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static void UhashClearUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashClearUlibPtr(__arg0);
        }

        public static uint UhashGetUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashGetUlibPtr(__arg0, key);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashResizeUlibPtr(global::cowl.UHash_ulib_ptr h, uint new_size)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashResizeUlibPtr(__arg0, new_size);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashPutUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, ref uint idx)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UhashPutUlibPtr(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static void UhashDeleteUlibPtr(global::cowl.UHash_ulib_ptr h, uint x)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeleteUlibPtr(__arg0, x);
        }

        public static global::cowl.UHash_ulib_ptr UhmapUlibPtr()
        {
            var ___ret = new global::cowl.UHash_ulib_ptr.__Internal();
            __Internal.UhmapUlibPtr(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_ptr.__CreateInstance(___ret);
        }

        public static __IntPtr UhmapGetUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr if_missing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapGetUlibPtr(__arg0, key, if_missing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapSetUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapSetUlibPtr(__arg0, key, value, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapAddUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapAddUlibPtr(__arg0, key, value, existing);
            return ___ret;
        }

        public static bool UhmapReplaceUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr value, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapReplaceUlibPtr(__arg0, key, value, replaced);
            return ___ret;
        }

        public static bool UhmapRemoveUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr* r_key, __IntPtr* r_val)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapRemoveUlibPtr(__arg0, key, r_key, r_val);
            return ___ret;
        }

        public static global::cowl.UHash_ulib_ptr UhsetUlibPtr()
        {
            var ___ret = new global::cowl.UHash_ulib_ptr.__Internal();
            __Internal.UhsetUlibPtr(new IntPtr(&___ret));
            return global::cowl.UHash_ulib_ptr.__CreateInstance(___ret);
        }

        public static global::cowl.UhashRet UhsetInsertUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetInsertUlibPtr(__arg0, key, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetInsertAllUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr* items, uint n)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetInsertAllUlibPtr(__arg0, items, n);
            return ___ret;
        }

        public static bool UhsetReplaceUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetReplaceUlibPtr(__arg0, key, replaced);
            return ___ret;
        }

        public static bool UhsetRemoveUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr key, __IntPtr* removed)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetRemoveUlibPtr(__arg0, key, removed);
            return ___ret;
        }

        public static bool UhsetIsSupersetUlibPtr(global::cowl.UHash_ulib_ptr h1, global::cowl.UHash_ulib_ptr h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetIsSupersetUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetUnionUlibPtr(global::cowl.UHash_ulib_ptr h1, global::cowl.UHash_ulib_ptr h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetUnionUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static void UhsetIntersectUlibPtr(global::cowl.UHash_ulib_ptr h1, global::cowl.UHash_ulib_ptr h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            __Internal.UhsetIntersectUlibPtr(__arg0, __arg1);
        }

        public static uint UhsetHashUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetHashUlibPtr(__arg0);
            return ___ret;
        }

        public static __IntPtr UhsetGetAnyUlibPtr(global::cowl.UHash_ulib_ptr h, __IntPtr if_empty)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetGetAnyUlibPtr(__arg0, if_empty);
            return ___ret;
        }

        public static bool UhashIsMapUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashIsMapUlibPtr(__arg0);
            return ___ret;
        }

        public static global::cowl.UHash_ulib_ptr UhashMoveUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = new global::cowl.UHash_ulib_ptr.__Internal();
            __Internal.UhashMoveUlibPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UHash_ulib_ptr.__CreateInstance(___ret);
        }

        public static uint UhashNextUlibPtr(global::cowl.UHash_ulib_ptr h, uint i)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashNextUlibPtr(__arg0, i);
            return ___ret;
        }

        public static bool UhsetEqualsUlibPtr(global::cowl.UHash_ulib_ptr h1, global::cowl.UHash_ulib_ptr h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetEqualsUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static uint PUhashOccupiedUlibPtr(global::cowl.UHash_ulib_ptr h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.PUhashOccupiedUlibPtr(__arg0);
            return ___ret;
        }

        public static void UhashDeinitUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeinitUString(__arg0);
        }

        public static global::cowl.UhashRet UhashCopyUString(global::cowl.UHashUString src, global::cowl.UHashUString dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashCopyAsSetUString(global::cowl.UHashUString src, global::cowl.UHashUString dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyAsSetUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UhashClearUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashClearUString(__arg0);
        }

        public static uint UhashGetUString(global::cowl.UHashUString h, global::cowl.UString key)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var ___ret = __Internal.UhashGetUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashResizeUString(global::cowl.UHashUString h, uint new_size)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashResizeUString(__arg0, new_size);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashPutUString(global::cowl.UHashUString h, global::cowl.UString key, ref uint idx)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UhashPutUString(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        public static void UhashDeleteUString(global::cowl.UHashUString h, uint x)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeleteUString(__arg0, x);
        }

        public static global::cowl.UHashUString UhmapUString()
        {
            var ___ret = new global::cowl.UHashUString.__Internal();
            __Internal.UhmapUString(new IntPtr(&___ret));
            return global::cowl.UHashUString.__CreateInstance(___ret);
        }

        public static __IntPtr UhmapGetUString(global::cowl.UHashUString h, global::cowl.UString key, __IntPtr if_missing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var ___ret = __Internal.UhmapGetUString(__arg0, __arg1, if_missing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapSetUString(global::cowl.UHashUString h, global::cowl.UString key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var ___ret = __Internal.UhmapSetUString(__arg0, __arg1, value, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapAddUString(global::cowl.UHashUString h, global::cowl.UString key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var ___ret = __Internal.UhmapAddUString(__arg0, __arg1, value, existing);
            return ___ret;
        }

        public static bool UhmapReplaceUString(global::cowl.UHashUString h, global::cowl.UString key, __IntPtr value, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var ___ret = __Internal.UhmapReplaceUString(__arg0, __arg1, value, replaced);
            return ___ret;
        }

        public static bool UhmapRemoveUString(global::cowl.UHashUString h, global::cowl.UString key, global::cowl.UString r_key, __IntPtr* r_val)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var __arg2 = r_key is null ? __IntPtr.Zero : r_key.__Instance;
            var ___ret = __Internal.UhmapRemoveUString(__arg0, __arg1, __arg2, r_val);
            return ___ret;
        }

        public static global::cowl.UHashUString UhsetUString()
        {
            var ___ret = new global::cowl.UHashUString.__Internal();
            __Internal.UhsetUString(new IntPtr(&___ret));
            return global::cowl.UHashUString.__CreateInstance(___ret);
        }

        public static global::cowl.UhashRet UhsetInsertUString(global::cowl.UHashUString h, global::cowl.UString key, global::cowl.UString existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var __arg2 = existing is null ? __IntPtr.Zero : existing.__Instance;
            var ___ret = __Internal.UhsetInsertUString(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetInsertAllUString(global::cowl.UHashUString h, global::cowl.UString items, uint n)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var __arg1 = items is null ? __IntPtr.Zero : items.__Instance;
            var ___ret = __Internal.UhsetInsertAllUString(__arg0, __arg1, n);
            return ___ret;
        }

        public static bool UhsetReplaceUString(global::cowl.UHashUString h, global::cowl.UString key, global::cowl.UString replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var __arg2 = replaced is null ? __IntPtr.Zero : replaced.__Instance;
            var ___ret = __Internal.UhsetReplaceUString(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static bool UhsetRemoveUString(global::cowl.UHashUString h, global::cowl.UString key, global::cowl.UString removed)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var __arg2 = removed is null ? __IntPtr.Zero : removed.__Instance;
            var ___ret = __Internal.UhsetRemoveUString(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static bool UhsetIsSupersetUString(global::cowl.UHashUString h1, global::cowl.UHashUString h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetIsSupersetUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetUnionUString(global::cowl.UHashUString h1, global::cowl.UHashUString h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetUnionUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UhsetIntersectUString(global::cowl.UHashUString h1, global::cowl.UHashUString h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            __Internal.UhsetIntersectUString(__arg0, __arg1);
        }

        public static uint UhsetHashUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetHashUString(__arg0);
            return ___ret;
        }

        public static global::cowl.UString UhsetGetAnyUString(global::cowl.UHashUString h, global::cowl.UString if_empty)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            if (ReferenceEquals(if_empty, null))
                throw new global::System.ArgumentNullException("if_empty", "Cannot be null because it is passed by value.");
            var __arg1 = if_empty.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UhsetGetAnyUString(new IntPtr(&___ret), __arg0, __arg1);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        public static bool UhashIsMapUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashIsMapUString(__arg0);
            return ___ret;
        }

        public static global::cowl.UHashUString UhashMoveUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = new global::cowl.UHashUString.__Internal();
            __Internal.UhashMoveUString(new IntPtr(&___ret), __arg0);
            return global::cowl.UHashUString.__CreateInstance(___ret);
        }

        public static uint UhashNextUString(global::cowl.UHashUString h, uint i)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashNextUString(__arg0, i);
            return ___ret;
        }

        public static bool UhsetEqualsUString(global::cowl.UHashUString h1, global::cowl.UHashUString h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetEqualsUString(__arg0, __arg1);
            return ___ret;
        }

        public static uint PUhashOccupiedUString(global::cowl.UHashUString h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.PUhashOccupiedUString(__arg0);
            return ___ret;
        }
    }

    /// <summary>Version information.</summary>
    /// <summary>Version information.</summary>
    public unsafe partial class UVersion : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint major;
            internal uint minor;
            internal uint patch;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVersion@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uversion@@YA?AUUVersion@@III@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Uversion(__IntPtr @return, uint major, uint minor, uint patch);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uversion_compare", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UversionCompare(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uversion_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UversionToString(__IntPtr @return, __IntPtr version);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVersion> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVersion>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVersion managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVersion managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVersion __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVersion(native.ToPointer(), skipVTables);
        }

        internal static UVersion __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVersion)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVersion __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVersion(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVersion(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVersion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVersion()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVersion.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVersion(global::cowl.UVersion _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVersion.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVersion.__Internal*) __Instance) = *((global::cowl.UVersion.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Initializes a version struct.</summary>
        /// <param name="major">Major revision.</param>
        /// <param name="minor">Minor revision.</param>
        /// <param name="patch">Patch number.</param>
        /// <returns>Initialized version struct.</returns>
        public static global::cowl.UVersion Uversion(uint major, uint minor, uint patch)
        {
            var ___ret = new global::cowl.UVersion.__Internal();
            __Internal.Uversion(new IntPtr(&___ret), major, minor, patch);
            return global::cowl.UVersion.__CreateInstance(___ret);
        }

        /// <summary>Compares lhs and rhs.</summary>
        /// <param name="lhs">First version.</param>
        /// <param name="rhs">Second version.</param>
        /// <returns>-1 if `lhs` is smaller than `rhs`, 0 if they are equal, 1 if `lhs` is greater than `rhs`.</returns>
        public static int UversionCompare(global::cowl.UVersion lhs, global::cowl.UVersion rhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg1 = rhs.__Instance;
            var ___ret = __Internal.UversionCompare(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Converts the version into a string.</summary>
        /// <param name="version">Version.</param>
        /// <returns>String.</returns>
        public static global::cowl.UString UversionToString(global::cowl.UVersion version)
        {
            var __arg0 = version is null ? __IntPtr.Zero : version.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UversionToString(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Major revision.</summary>
        public uint Major
        {
            get
            {
                return ((__Internal*)__Instance)->major;
            }

            set
            {
                ((__Internal*)__Instance)->major = value;
            }
        }

        /// <summary>Minor revision.</summary>
        public uint Minor
        {
            get
            {
                return ((__Internal*)__Instance)->minor;
            }

            set
            {
                ((__Internal*)__Instance)->minor = value;
            }
        }

        /// <summary>Patch number.</summary>
        public uint Patch
        {
            get
            {
                return ((__Internal*)__Instance)->patch;
            }

            set
            {
                ((__Internal*)__Instance)->patch = value;
            }
        }
    }

    public unsafe partial class umeta
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ulib_get_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UlibGetVersion(__IntPtr @return);
        }

        /// <summary>Returns the version of the library.</summary>
        /// <returns>Library version.</returns>
        public static global::cowl.UVersion UlibGetVersion()
        {
            var ___ret = new global::cowl.UVersion.__Internal();
            __Internal.UlibGetVersion(new IntPtr(&___ret));
            return global::cowl.UVersion.__CreateInstance(___ret);
        }
    }

    public unsafe partial class urand
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_set_seed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UrandSetSeed(uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_default_charset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UrandDefaultCharset();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Urand();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UrandRange(int start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UrandFloat();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_float_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UrandFloatRange(double start, double len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UrandString(__IntPtr @return, uint len, __IntPtr charset);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UrandStr(uint len, sbyte* buf, __IntPtr charset);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "urand_shuffle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UrandShuffle(__IntPtr array, ulong element_size, uint length);
        }

        /// <summary>Sets the seed of the random number generator.</summary>
        /// <param name="seed">Seed.</param>
        public static void UrandSetSeed(uint seed)
        {
            __Internal.UrandSetSeed(seed);
        }

        /// <summary>Returns the default character set used by random string generators.</summary>
        /// <returns>Default character set.</returns>
        public static global::cowl.UString UrandDefaultCharset()
        {
            var ___ret = __Internal.UrandDefaultCharset();
            var __result0 = global::cowl.UString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a random integer.</summary>
        /// <returns>Random integer.</returns>
        public static int Urand()
        {
            var ___ret = __Internal.Urand();
            return ___ret;
        }

        /// <summary>Returns a random integer in the specified range.</summary>
        /// <param name="start">Start of the range.</param>
        /// <param name="len">Length of the range.</param>
        /// <returns>Random integer.</returns>
        public static int UrandRange(int start, uint len)
        {
            var ___ret = __Internal.UrandRange(start, len);
            return ___ret;
        }

        /// <summary>Returns a random float between 0.0 and 1.0.</summary>
        /// <returns>Random float.</returns>
        public static double UrandFloat()
        {
            var ___ret = __Internal.UrandFloat();
            return ___ret;
        }

        /// <summary>Returns a random float in the specified range.</summary>
        /// <param name="start">Start of the range.</param>
        /// <param name="len">Length of the range.</param>
        /// <returns>Random float.</returns>
        public static double UrandFloatRange(double start, double len)
        {
            var ___ret = __Internal.UrandFloatRange(start, len);
            return ___ret;
        }

        /// <summary>Returns a random string.</summary>
        /// <param name="len">Length of the string.</param>
        /// <param name="charset">Character set, or NULL for the default alphanumeric character set.</param>
        /// <returns>Random string.</returns>
        public static global::cowl.UString UrandString(uint len, global::cowl.UString charset)
        {
            var __arg1 = charset is null ? __IntPtr.Zero : charset.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UrandString(new IntPtr(&___ret), len, __arg1);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Populates the buffer with a random string.</summary>
        /// <param name="len">Length of the random string.</param>
        /// <param name="buf">Buffer to populate.</param>
        /// <param name="charset">Character set, or NULL for the default alphanumeric character set.</param>
        public static void UrandStr(uint len, sbyte* buf, global::cowl.UString charset)
        {
            var __arg2 = charset is null ? __IntPtr.Zero : charset.__Instance;
            __Internal.UrandStr(len, buf, __arg2);
        }

        /// <summary>Randomly shuffles the elements of the array.</summary>
        /// <param name="array">Array.</param>
        /// <param name="element_size">Size of each element of the array.</param>
        /// <param name="length">Length of the array.</param>
        public static void UrandShuffle(__IntPtr array, ulong element_size, uint length)
        {
            __Internal.UrandShuffle(array, element_size, length);
        }
    }

    /// <summary>Return codes.</summary>
    public enum UvecRet
    {
        /// <summary>
        /// <para>The operation failed due to an error.</para>
        /// <para>As of right now, it can only happen if memory cannot be allocated.</para>
        /// </summary>
        UVEC_ERR = -1,
        /// <summary>The operation succeeded.</summary>
        UVEC_OK = 0,
        /// <summary>The operation could not be completed.</summary>
        UVEC_NO = 1
    }

    /// <summary>Return codes.</summary>
    public unsafe partial class PUvecSizingChar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingChar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingChar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingChar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingChar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingChar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingChar(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingChar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingChar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingChar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingChar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingChar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingChar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingChar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingChar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingChar(global::cowl.PUvecSizingChar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingChar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingChar.__Internal*) __Instance) = *((global::cowl.PUvecSizingChar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{char} elements.</summary>
        /// <remarks>typedef struct UVec(char) UVec(char);</remarks>
        public sbyte* D
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr) value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeChar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeChar> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeChar>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeChar managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeChar managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeChar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeChar(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeChar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeChar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeChar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeChar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeChar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeChar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeChar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeChar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeChar(global::cowl.PUvecLargeChar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeChar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeChar.__Internal*) __Instance) = *((global::cowl.PUvecLargeChar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{char} elements.</summary>
        /// <remarks>typedef struct UVec(char) UVec(char);</remarks>
        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr) value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_char : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeChar.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_char> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_char>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_char managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_char managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_char(native.ToPointer(), skipVTables);
        }

        internal static UVec_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_char(global::cowl.UVec_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_char.__Internal*) __Instance) = *((global::cowl.UVec_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeChar L
        {
            get
            {
                return global::cowl.PUvecLargeChar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeChar.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_char> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_char>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_char managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_char managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_char(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_char(global::cowl.UVecLoop_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_char.__Internal*) __Instance) = *((global::cowl.UVecLoop_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{char} elements.</summary>
        /// <remarks>typedef struct UVec(char) UVec(char);</remarks>
        public sbyte* Item
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUlibByte : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_ulib_byte@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibByte> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibByte>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUlibByte managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUlibByte managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUlibByte __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUlibByte(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUlibByte __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUlibByte)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUlibByte __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUlibByte(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUlibByte(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUlibByte(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUlibByte()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibByte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUlibByte(global::cowl.PUvecSizingUlibByte _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibByte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUlibByte.__Internal*) __Instance) = *((global::cowl.PUvecSizingUlibByte.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_byte} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_byte) UVec(ulib_byte);</remarks>
        public byte* D
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr) value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUlibByte : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_ulib_byte@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibByte> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibByte>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUlibByte managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUlibByte managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUlibByte __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUlibByte(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUlibByte __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUlibByte)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUlibByte __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUlibByte(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUlibByte(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUlibByte(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUlibByte()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibByte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUlibByte(global::cowl.PUvecLargeUlibByte _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibByte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUlibByte.__Internal*) __Instance) = *((global::cowl.PUvecLargeUlibByte.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_byte} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_byte) UVec(ulib_byte);</remarks>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr) value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_ulib_byte : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUlibByte.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_ulib_byte@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_byte> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_byte>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_ulib_byte managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_ulib_byte managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_ulib_byte __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_ulib_byte(native.ToPointer(), skipVTables);
        }

        internal static UVec_ulib_byte __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_ulib_byte)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_ulib_byte __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_ulib_byte(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_ulib_byte(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_ulib_byte(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_ulib_byte()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_byte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_ulib_byte(global::cowl.UVec_ulib_byte _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_byte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_ulib_byte.__Internal*) __Instance) = *((global::cowl.UVec_ulib_byte.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUlibByte L
        {
            get
            {
                return global::cowl.PUvecLargeUlibByte.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUlibByte.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_ulib_byte : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_ulib_byte@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_byte> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_byte>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_ulib_byte managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_ulib_byte managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_ulib_byte __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_ulib_byte(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_ulib_byte __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_ulib_byte)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_ulib_byte __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_ulib_byte(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_ulib_byte(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_ulib_byte(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_ulib_byte()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_byte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_ulib_byte(global::cowl.UVecLoop_ulib_byte _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_byte.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_ulib_byte.__Internal*) __Instance) = *((global::cowl.UVecLoop_ulib_byte.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_byte} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_byte) UVec(ulib_byte);</remarks>
        public byte* Item
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUlibInt : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibInt> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibInt>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUlibInt managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUlibInt managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUlibInt __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUlibInt(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUlibInt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUlibInt)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUlibInt __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUlibInt(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUlibInt(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUlibInt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUlibInt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibInt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUlibInt(global::cowl.PUvecSizingUlibInt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibInt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUlibInt.__Internal*) __Instance) = *((global::cowl.PUvecSizingUlibInt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_int} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_int) UVec(ulib_int);</remarks>
        public int* D
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr) value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUlibInt : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibInt> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibInt>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUlibInt managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUlibInt managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUlibInt __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUlibInt(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUlibInt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUlibInt)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUlibInt __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUlibInt(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUlibInt(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUlibInt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUlibInt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibInt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUlibInt(global::cowl.PUvecLargeUlibInt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibInt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUlibInt.__Internal*) __Instance) = *((global::cowl.PUvecLargeUlibInt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_int} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_int) UVec(ulib_int);</remarks>
        public int* Data
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr) value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_ulib_int : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUlibInt.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_int> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_int>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_ulib_int managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_ulib_int managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_ulib_int __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_ulib_int(native.ToPointer(), skipVTables);
        }

        internal static UVec_ulib_int __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_ulib_int)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_ulib_int __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_ulib_int(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_ulib_int(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_ulib_int(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_ulib_int()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_ulib_int(global::cowl.UVec_ulib_int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_ulib_int.__Internal*) __Instance) = *((global::cowl.UVec_ulib_int.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUlibInt L
        {
            get
            {
                return global::cowl.PUvecLargeUlibInt.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUlibInt.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_ulib_int : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_ulib_int@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_int> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_int>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_ulib_int managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_ulib_int managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_ulib_int __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_ulib_int(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_ulib_int __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_ulib_int)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_ulib_int __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_ulib_int(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_ulib_int(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_ulib_int(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_ulib_int()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_ulib_int(global::cowl.UVecLoop_ulib_int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_int.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_ulib_int.__Internal*) __Instance) = *((global::cowl.UVecLoop_ulib_int.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_int} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_int) UVec(ulib_int);</remarks>
        public int* Item
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUlibUint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibUint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibUint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUlibUint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUlibUint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUlibUint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUlibUint(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUlibUint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUlibUint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUlibUint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUlibUint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUlibUint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUlibUint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUlibUint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibUint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUlibUint(global::cowl.PUvecSizingUlibUint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibUint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUlibUint.__Internal*) __Instance) = *((global::cowl.PUvecSizingUlibUint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_uint} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_uint) UVec(ulib_uint);</remarks>
        public uint* D
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr) value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUlibUint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibUint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibUint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUlibUint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUlibUint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUlibUint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUlibUint(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUlibUint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUlibUint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUlibUint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUlibUint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUlibUint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUlibUint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUlibUint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibUint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUlibUint(global::cowl.PUvecLargeUlibUint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibUint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUlibUint.__Internal*) __Instance) = *((global::cowl.PUvecLargeUlibUint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_uint} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_uint) UVec(ulib_uint);</remarks>
        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr) value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_ulib_uint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUlibUint.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_uint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_uint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_ulib_uint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_ulib_uint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_ulib_uint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_ulib_uint(native.ToPointer(), skipVTables);
        }

        internal static UVec_ulib_uint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_ulib_uint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_ulib_uint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_ulib_uint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_ulib_uint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_ulib_uint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_ulib_uint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_ulib_uint(global::cowl.UVec_ulib_uint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_ulib_uint.__Internal*) __Instance) = *((global::cowl.UVec_ulib_uint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUlibUint L
        {
            get
            {
                return global::cowl.PUvecLargeUlibUint.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUlibUint.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_ulib_uint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_ulib_uint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_uint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_uint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_ulib_uint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_ulib_uint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_ulib_uint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_ulib_uint(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_ulib_uint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_ulib_uint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_ulib_uint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_ulib_uint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_ulib_uint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_ulib_uint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_ulib_uint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_ulib_uint(global::cowl.UVecLoop_ulib_uint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_uint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_ulib_uint.__Internal*) __Instance) = *((global::cowl.UVecLoop_ulib_uint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_uint} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_uint) UVec(ulib_uint);</remarks>
        public uint* Item
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUlibFloat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_ulib_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibFloat> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibFloat>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUlibFloat managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUlibFloat managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUlibFloat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUlibFloat(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUlibFloat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUlibFloat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUlibFloat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUlibFloat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUlibFloat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUlibFloat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUlibFloat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibFloat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUlibFloat(global::cowl.PUvecSizingUlibFloat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibFloat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUlibFloat.__Internal*) __Instance) = *((global::cowl.PUvecSizingUlibFloat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_float} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_float) UVec(ulib_float);</remarks>
        public double* D
        {
            get
            {
                return (double*) ((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr) value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUlibFloat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_ulib_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibFloat> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibFloat>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUlibFloat managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUlibFloat managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUlibFloat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUlibFloat(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUlibFloat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUlibFloat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUlibFloat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUlibFloat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUlibFloat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUlibFloat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUlibFloat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibFloat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUlibFloat(global::cowl.PUvecLargeUlibFloat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibFloat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUlibFloat.__Internal*) __Instance) = *((global::cowl.PUvecLargeUlibFloat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_float} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_float) UVec(ulib_float);</remarks>
        public double* Data
        {
            get
            {
                return (double*) ((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr) value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_ulib_float : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUlibFloat.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_ulib_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_float> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_float>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_ulib_float managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_ulib_float managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_ulib_float __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_ulib_float(native.ToPointer(), skipVTables);
        }

        internal static UVec_ulib_float __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_ulib_float)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_ulib_float __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_ulib_float(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_ulib_float(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_ulib_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_ulib_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_ulib_float(global::cowl.UVec_ulib_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_ulib_float.__Internal*) __Instance) = *((global::cowl.UVec_ulib_float.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUlibFloat L
        {
            get
            {
                return global::cowl.PUvecLargeUlibFloat.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUlibFloat.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_ulib_float : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_ulib_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_float> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_float>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_ulib_float managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_ulib_float managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_ulib_float __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_ulib_float(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_ulib_float __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_ulib_float)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_ulib_float __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_ulib_float(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_ulib_float(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_ulib_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_ulib_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_ulib_float(global::cowl.UVecLoop_ulib_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_ulib_float.__Internal*) __Instance) = *((global::cowl.UVecLoop_ulib_float.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_float} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_float) UVec(ulib_float);</remarks>
        public double* Item
        {
            get
            {
                return (double*) ((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUlibPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUlibPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUlibPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUlibPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUlibPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUlibPtr(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUlibPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUlibPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUlibPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUlibPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUlibPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUlibPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUlibPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUlibPtr(global::cowl.PUvecSizingUlibPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUlibPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUlibPtr.__Internal*) __Instance) = *((global::cowl.PUvecSizingUlibPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_ptr} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_ptr) UVec(ulib_ptr);</remarks>
        public __IntPtr* D
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr)value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUlibPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUlibPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUlibPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUlibPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUlibPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUlibPtr(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUlibPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUlibPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUlibPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUlibPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUlibPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUlibPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUlibPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUlibPtr(global::cowl.PUvecLargeUlibPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUlibPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUlibPtr.__Internal*) __Instance) = *((global::cowl.PUvecLargeUlibPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_ptr} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_ptr) UVec(ulib_ptr);</remarks>
        public __IntPtr* Data
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr)value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVec_ulib_ptr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUlibPtr.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_ptr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVec_ulib_ptr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVec_ulib_ptr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVec_ulib_ptr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVec_ulib_ptr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVec_ulib_ptr(native.ToPointer(), skipVTables);
        }

        internal static UVec_ulib_ptr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVec_ulib_ptr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVec_ulib_ptr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVec_ulib_ptr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVec_ulib_ptr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVec_ulib_ptr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVec_ulib_ptr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVec_ulib_ptr(global::cowl.UVec_ulib_ptr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVec_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVec_ulib_ptr.__Internal*) __Instance) = *((global::cowl.UVec_ulib_ptr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUlibPtr L
        {
            get
            {
                return global::cowl.PUvecLargeUlibPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUlibPtr.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoop_ulib_ptr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_ulib_ptr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_ptr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoop_ulib_ptr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoop_ulib_ptr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoop_ulib_ptr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoop_ulib_ptr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoop_ulib_ptr(native.ToPointer(), skipVTables);
        }

        internal static UVecLoop_ulib_ptr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoop_ulib_ptr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoop_ulib_ptr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoop_ulib_ptr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoop_ulib_ptr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoop_ulib_ptr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoop_ulib_ptr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoop_ulib_ptr(global::cowl.UVecLoop_ulib_ptr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoop_ulib_ptr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoop_ulib_ptr.__Internal*) __Instance) = *((global::cowl.UVecLoop_ulib_ptr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#ulib_ptr} elements.</summary>
        /// <remarks>typedef struct UVec(ulib_ptr) UVec(ulib_ptr);</remarks>
        public __IntPtr* Item
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class PUvecSizingUString : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingUString(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingUString(global::cowl.PUvecSizingUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingUString.__Internal*) __Instance) = *((global::cowl.PUvecSizingUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#UString} elements.</summary>
        /// <remarks>typedef struct UVec(UString) UVec(UString);</remarks>
        public global::cowl.UString D
        {
            get
            {
                var __result0 = global::cowl.UString.__GetOrCreateInstance(((__Internal*)__Instance)->_d, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_d = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeUString : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeUString(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeUString(global::cowl.PUvecLargeUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeUString.__Internal*) __Instance) = *((global::cowl.PUvecLargeUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#UString} elements.</summary>
        /// <remarks>typedef struct UVec(UString) UVec(UString);</remarks>
        public global::cowl.UString Data
        {
            get
            {
                var __result0 = global::cowl.UString.__GetOrCreateInstance(((__Internal*)__Instance)->_data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecUString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeUString.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecUString(native.ToPointer(), skipVTables);
        }

        internal static UVecUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecUString(global::cowl.UVecUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecUString.__Internal*) __Instance) = *((global::cowl.UVecUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeUString L
        {
            get
            {
                return global::cowl.PUvecLargeUString.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeUString.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoopUString : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_UString@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoopUString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoopUString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoopUString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoopUString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoopUString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoopUString(native.ToPointer(), skipVTables);
        }

        internal static UVecLoopUString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoopUString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoopUString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoopUString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoopUString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoopUString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoopUString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoopUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoopUString(global::cowl.UVecLoopUString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoopUString.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoopUString.__Internal*) __Instance) = *((global::cowl.UVecLoopUString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>{#UVec(T)} of{#UString} elements.</summary>
        /// <remarks>typedef struct UVec(UString) UVec(UString);</remarks>
        public global::cowl.UString Item
        {
            get
            {
                var __result0 = global::cowl.UString.__GetOrCreateInstance(((__Internal*)__Instance)->item, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->item = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class uvec_builtin
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveChar(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeChar(__IntPtr vec, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyChar(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayChar(__IntPtr vec, sbyte[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopChar(__IntPtr vec, sbyte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeChar(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeChar(__IntPtr vec, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeChar(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsChar(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeChar(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertChar(__IntPtr vec, sbyte item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertChar(__IntPtr vec, sbyte item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopChar(__IntPtr vec, sbyte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopChar(__IntPtr vec, sbyte @in, sbyte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceChar(__IntPtr vec, sbyte @in, sbyte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopChar(__IntPtr vec, sbyte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopChar(__IntPtr vec, sbyte @in, sbyte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceChar(__IntPtr vec, sbyte @in, sbyte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_char", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecChar(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_char@@YA?AUUVec_char@@PEADI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignChar(__IntPtr @return, sbyte* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_char@@YA?AUUVec_char@@PEADI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapChar(__IntPtr @return, sbyte* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_char@@YAPEADPEBUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* UvecDataChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_char@@YAIPEBUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_count_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_char@@YAXPEAUUVec_char@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountChar(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_char@@YADPEBUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte UvecLastChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_char@@YA?AUUVec_char@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromChar(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_char@@YAXPEAUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_char@@YA?AUUVec_char@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveChar(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_char@@YA?AW4uvec_ret@@PEAUUVec_char@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandChar(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_char@@YA?AW4uvec_ret@@PEAUUVec_char@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendChar(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_char@@YA?AW4uvec_ret@@PEAUUVec_char@@PEBDI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayChar(__IntPtr vec, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_char@@YA?AW4uvec_ret@@PEAUUVec_char@@ID@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtChar(__IntPtr vec, uint idx, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_char@@YAXPEAUUVec_char@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtChar(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_char@@YAXPEAUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_char@@YA?AUUVec_Loop_char@@PEBUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitChar(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_char@@YA?AUUVec_Loop_char@@PEBUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitChar(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_char@@YA_NPEBUUVec_char@@D@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_char@@YAXPEAUUVec_char@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortChar(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_char@@YA_NPEBUUVec_char@@D@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsChar(__IntPtr vec, sbyte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUlibByte(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUlibByte(__IntPtr vec, byte* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUlibByte(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUlibByte(__IntPtr vec, byte[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUlibByte(__IntPtr vec, byte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUlibByte(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUlibByte(__IntPtr vec, byte* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUlibByte(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUlibByte(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUlibByte(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUlibByte(__IntPtr vec, byte item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUlibByte(__IntPtr vec, byte item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUlibByte(__IntPtr vec, byte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUlibByte(__IntPtr vec, byte @in, byte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUlibByte(__IntPtr vec, byte @in, byte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUlibByte(__IntPtr vec, byte* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUlibByte(__IntPtr vec, byte @in, byte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUlibByte(__IntPtr vec, byte @in, byte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_ulib_byte", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_ulib_byte@@YA?AUUVec_ulib_byte@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUlibByte(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_ulib_byte@@YA?AUUVec_ulib_byte@@PEAEI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUlibByte(__IntPtr @return, byte* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_ulib_byte@@YA?AUUVec_ulib_byte@@PEAEI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUlibByte(__IntPtr @return, byte* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_ulib_byte@@YAPEAEPEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* UvecDataUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_ulib_byte@@YAIPEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_ulib_byte@@YAIPEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_ulib_byte@@YAXPEAUUVec_ulib_byte@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUlibByte(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_ulib_byte@@YAEPEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte UvecLastUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_ulib_byte@@YA?AUUVec_ulib_byte@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUlibByte(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_ulib_byte@@YAXPEAUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_ulib_byte@@YA?AUUVec_ulib_byte@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUlibByte(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_ulib_byte@@YA?AW4uvec_ret@@PEAUUVec_ulib_byte@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUlibByte(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_ulib_byte@@YA?AW4uvec_ret@@PEAUUVec_ulib_byte@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUlibByte(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_ulib_byte@@YA?AW4uvec_ret@@PEAUUVec_ulib_byte@@PEBEI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUlibByte(__IntPtr vec, byte* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_ulib_byte@@YA?AW4uvec_ret@@PEAUUVec_ulib_byte@@IE@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUlibByte(__IntPtr vec, uint idx, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_ulib_byte@@YAXPEAUUVec_ulib_byte@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUlibByte(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_ulib_byte@@YAXPEAUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_ulib_byte@@YA?AUUVec_Loop_ulib_byte@@PEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUlibByte(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_ulib_byte@@YA?AUUVec_Loop_ulib_byte@@PEBUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUlibByte(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_ulib_byte@@YA_NPEBUUVec_ulib_byte@@E@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_ulib_byte@@YAXPEAUUVec_ulib_byte@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUlibByte(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_ulib_byte@@YA_NPEBUUVec_ulib_byte@@E@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUlibByte(__IntPtr vec, byte item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUlibInt(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUlibInt(__IntPtr vec, int* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUlibInt(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUlibInt(__IntPtr vec, int[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUlibInt(__IntPtr vec, int* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUlibInt(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUlibInt(__IntPtr vec, int* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUlibInt(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUlibInt(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUlibInt(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUlibInt(__IntPtr vec, int item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUlibInt(__IntPtr vec, int item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUlibInt(__IntPtr vec, int* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUlibInt(__IntPtr vec, int @in, int* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUlibInt(__IntPtr vec, int @in, int* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUlibInt(__IntPtr vec, int* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUlibInt(__IntPtr vec, int @in, int* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUlibInt(__IntPtr vec, int @in, int* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_ulib_int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_ulib_int@@YA?AUUVec_ulib_int@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUlibInt(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_ulib_int@@YA?AUUVec_ulib_int@@PEAHI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUlibInt(__IntPtr @return, int* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_ulib_int@@YA?AUUVec_ulib_int@@PEAHI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUlibInt(__IntPtr @return, int* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_ulib_int@@YAPEAHPEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int* UvecDataUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_ulib_int@@YAIPEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_ulib_int@@YAIPEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_ulib_int@@YAXPEAUUVec_ulib_int@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUlibInt(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_ulib_int@@YAHPEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UvecLastUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_ulib_int@@YA?AUUVec_ulib_int@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUlibInt(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_ulib_int@@YAXPEAUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_ulib_int@@YA?AUUVec_ulib_int@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUlibInt(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_ulib_int@@YA?AW4uvec_ret@@PEAUUVec_ulib_int@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUlibInt(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_ulib_int@@YA?AW4uvec_ret@@PEAUUVec_ulib_int@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUlibInt(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_ulib_int@@YA?AW4uvec_ret@@PEAUUVec_ulib_int@@PEBHI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUlibInt(__IntPtr vec, int* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_ulib_int@@YA?AW4uvec_ret@@PEAUUVec_ulib_int@@IH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUlibInt(__IntPtr vec, uint idx, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_ulib_int@@YAXPEAUUVec_ulib_int@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUlibInt(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_ulib_int@@YAXPEAUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_ulib_int@@YA?AUUVec_Loop_ulib_int@@PEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUlibInt(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_ulib_int@@YA?AUUVec_Loop_ulib_int@@PEBUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUlibInt(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_ulib_int@@YA_NPEBUUVec_ulib_int@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_ulib_int@@YAXPEAUUVec_ulib_int@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUlibInt(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_ulib_int@@YA_NPEBUUVec_ulib_int@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUlibInt(__IntPtr vec, int item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUlibUint(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUlibUint(__IntPtr vec, uint* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUlibUint(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUlibUint(__IntPtr vec, uint[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUlibUint(__IntPtr vec, uint* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUlibUint(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUlibUint(__IntPtr vec, uint* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUlibUint(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUlibUint(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUlibUint(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUlibUint(__IntPtr vec, uint item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUlibUint(__IntPtr vec, uint item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUlibUint(__IntPtr vec, uint* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUlibUint(__IntPtr vec, uint @in, uint* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUlibUint(__IntPtr vec, uint @in, uint* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUlibUint(__IntPtr vec, uint* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUlibUint(__IntPtr vec, uint @in, uint* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUlibUint(__IntPtr vec, uint @in, uint* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_ulib_uint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_ulib_uint@@YA?AUUVec_ulib_uint@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUlibUint(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_ulib_uint@@YA?AUUVec_ulib_uint@@PEAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUlibUint(__IntPtr @return, uint* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_ulib_uint@@YA?AUUVec_ulib_uint@@PEAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUlibUint(__IntPtr @return, uint* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_ulib_uint@@YAPEAIPEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* UvecDataUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_ulib_uint@@YAIPEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_ulib_uint@@YAIPEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_ulib_uint@@YAXPEAUUVec_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUlibUint(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_ulib_uint@@YAIPEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecLastUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_ulib_uint@@YA?AUUVec_ulib_uint@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUlibUint(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_ulib_uint@@YAXPEAUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_ulib_uint@@YA?AUUVec_ulib_uint@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUlibUint(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_ulib_uint@@YA?AW4uvec_ret@@PEAUUVec_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUlibUint(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_ulib_uint@@YA?AW4uvec_ret@@PEAUUVec_ulib_uint@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUlibUint(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_ulib_uint@@YA?AW4uvec_ret@@PEAUUVec_ulib_uint@@PEBII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUlibUint(__IntPtr vec, uint* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_ulib_uint@@YA?AW4uvec_ret@@PEAUUVec_ulib_uint@@II@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUlibUint(__IntPtr vec, uint idx, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_ulib_uint@@YAXPEAUUVec_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUlibUint(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_ulib_uint@@YAXPEAUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_ulib_uint@@YA?AUUVec_Loop_ulib_uint@@PEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUlibUint(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_ulib_uint@@YA?AUUVec_Loop_ulib_uint@@PEBUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUlibUint(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_ulib_uint@@YA_NPEBUUVec_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_ulib_uint@@YAXPEAUUVec_ulib_uint@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUlibUint(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_ulib_uint@@YA_NPEBUUVec_ulib_uint@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUlibUint(__IntPtr vec, uint item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUlibFloat(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUlibFloat(__IntPtr vec, double* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUlibFloat(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUlibFloat(__IntPtr vec, double[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUlibFloat(__IntPtr vec, double* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUlibFloat(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUlibFloat(__IntPtr vec, double* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUlibFloat(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUlibFloat(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUlibFloat(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUlibFloat(__IntPtr vec, double item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUlibFloat(__IntPtr vec, double item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUlibFloat(__IntPtr vec, double* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUlibFloat(__IntPtr vec, double @in, double* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUlibFloat(__IntPtr vec, double @in, double* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUlibFloat(__IntPtr vec, double* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUlibFloat(__IntPtr vec, double @in, double* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUlibFloat(__IntPtr vec, double @in, double* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_ulib_float", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_ulib_float@@YA?AUUVec_ulib_float@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUlibFloat(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_ulib_float@@YA?AUUVec_ulib_float@@PEANI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUlibFloat(__IntPtr @return, double* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_ulib_float@@YA?AUUVec_ulib_float@@PEANI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUlibFloat(__IntPtr @return, double* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_ulib_float@@YAPEANPEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double* UvecDataUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_ulib_float@@YAIPEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_ulib_float@@YAIPEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_ulib_float@@YAXPEAUUVec_ulib_float@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUlibFloat(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_ulib_float@@YANPEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UvecLastUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_ulib_float@@YA?AUUVec_ulib_float@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUlibFloat(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_ulib_float@@YAXPEAUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_ulib_float@@YA?AUUVec_ulib_float@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUlibFloat(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_ulib_float@@YA?AW4uvec_ret@@PEAUUVec_ulib_float@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUlibFloat(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_ulib_float@@YA?AW4uvec_ret@@PEAUUVec_ulib_float@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUlibFloat(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_ulib_float@@YA?AW4uvec_ret@@PEAUUVec_ulib_float@@PEBNI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUlibFloat(__IntPtr vec, double* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_ulib_float@@YA?AW4uvec_ret@@PEAUUVec_ulib_float@@IN@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUlibFloat(__IntPtr vec, uint idx, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_ulib_float@@YAXPEAUUVec_ulib_float@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUlibFloat(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_ulib_float@@YAXPEAUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_ulib_float@@YA?AUUVec_Loop_ulib_float@@PEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUlibFloat(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_ulib_float@@YA?AUUVec_Loop_ulib_float@@PEBUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUlibFloat(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_ulib_float@@YA_NPEBUUVec_ulib_float@@N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_ulib_float@@YAXPEAUUVec_ulib_float@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUlibFloat(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_ulib_float@@YA_NPEBUUVec_ulib_float@@N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUlibFloat(__IntPtr vec, double item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUlibPtr(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUlibPtr(__IntPtr vec, __IntPtr* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUlibPtr(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUlibPtr(__IntPtr vec, __IntPtr[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUlibPtr(__IntPtr vec, __IntPtr* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUlibPtr(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUlibPtr(__IntPtr vec, __IntPtr* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUlibPtr(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUlibPtr(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUlibPtr(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUlibPtr(__IntPtr vec, __IntPtr item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUlibPtr(__IntPtr vec, __IntPtr item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUlibPtr(__IntPtr vec, __IntPtr* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUlibPtr(__IntPtr vec, __IntPtr @in, __IntPtr* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUlibPtr(__IntPtr vec, __IntPtr @in, __IntPtr* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUlibPtr(__IntPtr vec, __IntPtr* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUlibPtr(__IntPtr vec, __IntPtr @in, __IntPtr* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUlibPtr(__IntPtr vec, __IntPtr @in, __IntPtr* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_ulib_ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_ulib_ptr@@YA?AUUVec_ulib_ptr@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUlibPtr(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_ulib_ptr@@YA?AUUVec_ulib_ptr@@PEAPEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUlibPtr(__IntPtr @return, __IntPtr* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_ulib_ptr@@YA?AUUVec_ulib_ptr@@PEAPEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUlibPtr(__IntPtr @return, __IntPtr* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_ulib_ptr@@YAPEAPEAXPEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr* UvecDataUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_ulib_ptr@@YAIPEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_ulib_ptr@@YAIPEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_ulib_ptr@@YAXPEAUUVec_ulib_ptr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUlibPtr(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_ulib_ptr@@YAPEAXPEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UvecLastUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_ulib_ptr@@YA?AUUVec_ulib_ptr@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUlibPtr(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_ulib_ptr@@YAXPEAUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_ulib_ptr@@YA?AUUVec_ulib_ptr@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUlibPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_ulib_ptr@@YA?AW4uvec_ret@@PEAUUVec_ulib_ptr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUlibPtr(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_ulib_ptr@@YA?AW4uvec_ret@@PEAUUVec_ulib_ptr@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUlibPtr(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_ulib_ptr@@YA?AW4uvec_ret@@PEAUUVec_ulib_ptr@@PEBQEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUlibPtr(__IntPtr vec, __IntPtr* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_ulib_ptr@@YA?AW4uvec_ret@@PEAUUVec_ulib_ptr@@IPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUlibPtr(__IntPtr vec, uint idx, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_ulib_ptr@@YAXPEAUUVec_ulib_ptr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUlibPtr(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_ulib_ptr@@YAXPEAUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_ulib_ptr@@YA?AUUVec_Loop_ulib_ptr@@PEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUlibPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_ulib_ptr@@YA?AUUVec_Loop_ulib_ptr@@PEBUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUlibPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_ulib_ptr@@YA_NPEBUUVec_ulib_ptr@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_ulib_ptr@@YAXPEAUUVec_ulib_ptr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUlibPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_ulib_ptr@@YA_NPEBUUVec_ulib_ptr@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUlibPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveUString(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeUString(__IntPtr vec, __IntPtr array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyUString(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayUString(__IntPtr vec, global::cowl.UString.__Internal[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeUString(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeUString(__IntPtr vec, __IntPtr array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeUString(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsUString(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_min_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMinUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_max_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfMaxUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sort_range_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortRangeUString(__IntPtr vec, uint start, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insertion_index_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedInsertionIndexUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_index_of_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSortedIndexOfUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_insert_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedInsertUString(__IntPtr vec, __IntPtr item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_unique_insert_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSortedUniqueInsertUString(__IntPtr vec, __IntPtr item, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_sorted_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedRemoveUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_make_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqMakeUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMaxHeapqPushUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_pop_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqPopUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_push_pop_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMaxHeapqPushPopUString(__IntPtr vec, __IntPtr @in, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_replace_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqReplaceUString(__IntPtr vec, __IntPtr @in, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_max_heapq_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMaxHeapqRemoveUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_make_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqMakeUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecMinHeapqPushUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_pop_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqPopUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_push_pop_UString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMinHeapqPushPopUString(__IntPtr vec, __IntPtr @in, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_replace_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqReplaceUString(__IntPtr vec, __IntPtr @in, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_min_heapq_remove_UString", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecMinHeapqRemoveUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_UString@@YA?AUUVec_UString@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUString(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_UString@@YA?AUUVec_UString@@PEAUUString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignUString(__IntPtr @return, __IntPtr array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_UString@@YA?AUUVec_UString@@PEAUUString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapUString(__IntPtr @return, __IntPtr array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_UString@@YAPEAUUString@@PEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UvecDataUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_UString@@YAIPEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_UString@@YAIPEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_UString@@YAXPEAUUVec_UString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountUString(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_UString@@YA?AUUString@@PEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecLastUString(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_UString@@YA?AUUVec_UString@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromUString(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_UString@@YAXPEAUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_UString@@YA?AUUVec_UString@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveUString(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_UString@@YA?AW4uvec_ret@@PEAUUVec_UString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandUString(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_UString@@YA?AW4uvec_ret@@PEAUUVec_UString@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendUString(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_UString@@YA?AW4uvec_ret@@PEAUUVec_UString@@PEBUUString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayUString(__IntPtr vec, __IntPtr src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_UString@@YA?AW4uvec_ret@@PEAUUVec_UString@@IUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtUString(__IntPtr vec, uint idx, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_UString@@YAXPEAUUVec_UString@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtUString(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_UString@@YAXPEAUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_UString@@YA?AUUVec_Loop_UString@@PEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitUString(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_UString@@YA?AUUVec_Loop_UString@@PEBUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitUString(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_UString@@YA_NPEBUUVec_UString@@UUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsUString(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sort_UString@@YAXPEAUUVec_UString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecSortUString(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_sorted_contains_UString@@YA_NPEBUUVec_UString@@UUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecSortedContainsUString(__IntPtr vec, __IntPtr item);
        }

        public static global::cowl.UvecRet UvecReserveChar(global::cowl.UVec_char vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveChar(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeChar(global::cowl.UVec_char vec, string array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSetRangeChar(__arg0, array, start, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecCopyChar(global::cowl.UVec_char src, global::cowl.UVec_char dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyChar(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayChar(global::cowl.UVec_char vec, sbyte[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayChar(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkChar(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopChar(global::cowl.UVec_char vec, sbyte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPopChar(__arg0, item);
            return ___ret;
        }

        public static void UvecRemoveRangeChar(global::cowl.UVec_char vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeChar(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeChar(global::cowl.UVec_char vec, string array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertRangeChar(__arg0, array, start, n);
            return ___ret;
        }

        public static void UvecUnorderedRemoveRangeChar(global::cowl.UVec_char vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeChar(__arg0, start, n);
        }

        public static void UvecReverseChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseChar(__arg0);
        }

        public static void UvecShuffleChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleChar(__arg0);
        }

        public static uint UvecIndexOfChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfChar(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsChar(global::cowl.UVec_char vec, global::cowl.UVec_char other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsChar(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueChar(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinChar(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxChar(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeChar(global::cowl.UVec_char vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeChar(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexChar(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfChar(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertChar(global::cowl.UVec_char vec, sbyte item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertChar(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertChar(global::cowl.UVec_char vec, sbyte item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertChar(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveChar(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeChar(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopChar(global::cowl.UVec_char vec, sbyte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPopChar(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqPushPopChar(global::cowl.UVec_char vec, sbyte @in, sbyte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqPushPopChar(__arg0, @in, @out);
        }

        public static bool UvecMaxHeapqReplaceChar(global::cowl.UVec_char vec, sbyte @in, sbyte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqReplaceChar(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMaxHeapqRemoveChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveChar(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeChar(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushChar(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopChar(global::cowl.UVec_char vec, sbyte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPopChar(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqPushPopChar(global::cowl.UVec_char vec, sbyte @in, sbyte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqPushPopChar(__arg0, @in, @out);
        }

        public static bool UvecMinHeapqReplaceChar(global::cowl.UVec_char vec, sbyte @in, sbyte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqReplaceChar(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMinHeapqRemoveChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveChar(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_char UvecChar()
        {
            var ___ret = new global::cowl.UVec_char.__Internal();
            __Internal.UvecChar(new IntPtr(&___ret));
            return global::cowl.UVec_char.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_char UvecAssignChar(sbyte* array, uint count)
        {
            var ___ret = new global::cowl.UVec_char.__Internal();
            __Internal.UvecAssignChar(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_char.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_char UvecWrapChar(sbyte* array, uint count)
        {
            var ___ret = new global::cowl.UVec_char.__Internal();
            __Internal.UvecWrapChar(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_char.__CreateInstance(___ret);
        }

        public static sbyte* UvecDataChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataChar(__arg0);
            return ___ret;
        }

        public static uint UvecSizeChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeChar(__arg0);
            return ___ret;
        }

        public static uint UvecCountChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountChar(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountChar(global::cowl.UVec_char vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountChar(__arg0, count);
        }

        public static sbyte UvecLastChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastChar(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_char UvecViewFromChar(global::cowl.UVec_char vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_char.__Internal();
            __Internal.UvecViewFromChar(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_char.__CreateInstance(___ret);
        }

        public static void UvecDeinitChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitChar(__arg0);
        }

        public static global::cowl.UVec_char UvecMoveChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_char.__Internal();
            __Internal.UvecMoveChar(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_char.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandChar(global::cowl.UVec_char vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandChar(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendChar(global::cowl.UVec_char vec, global::cowl.UVec_char src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendChar(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayChar(global::cowl.UVec_char vec, string src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecAppendArrayChar(__arg0, src, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecInsertAtChar(global::cowl.UVec_char vec, uint idx, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtChar(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtChar(global::cowl.UVec_char vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtChar(__arg0, idx);
        }

        public static void UvecClearChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearChar(__arg0);
        }

        public static global::cowl.UVecLoop_char PUvecLoopInitChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_char.__Internal();
            __Internal.PUvecLoopInitChar(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_char.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_char PUvecLoopReverseInitChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_char.__Internal();
            __Internal.PUvecLoopReverseInitChar(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_char.__CreateInstance(___ret);
        }

        public static bool UvecContainsChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsChar(__arg0, item);
            return ___ret;
        }

        public static void UvecSortChar(global::cowl.UVec_char vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortChar(__arg0);
        }

        public static bool UvecSortedContainsChar(global::cowl.UVec_char vec, sbyte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsChar(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUlibByte(global::cowl.UVec_ulib_byte vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUlibByte(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUlibByte(global::cowl.UVec_ulib_byte vec, byte* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSetRangeUlibByte(__arg0, array, start, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecCopyUlibByte(global::cowl.UVec_ulib_byte src, global::cowl.UVec_ulib_byte dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUlibByte(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUlibByte(global::cowl.UVec_ulib_byte vec, byte[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayUlibByte(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUlibByte(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopUlibByte(global::cowl.UVec_ulib_byte vec, byte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPopUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecRemoveRangeUlibByte(global::cowl.UVec_ulib_byte vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUlibByte(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUlibByte(global::cowl.UVec_ulib_byte vec, byte* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertRangeUlibByte(__arg0, array, start, n);
            return ___ret;
        }

        public static void UvecUnorderedRemoveRangeUlibByte(global::cowl.UVec_ulib_byte vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUlibByte(__arg0, start, n);
        }

        public static void UvecReverseUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUlibByte(__arg0);
        }

        public static void UvecShuffleUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUlibByte(__arg0);
        }

        public static uint UvecIndexOfUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfUlibByte(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsUlibByte(global::cowl.UVec_ulib_byte vec, global::cowl.UVec_ulib_byte other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUlibByte(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueUlibByte(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUlibByte(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUlibByte(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUlibByte(global::cowl.UVec_ulib_byte vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUlibByte(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUlibByte(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUlibByte(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUlibByte(global::cowl.UVec_ulib_byte vec, byte item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUlibByte(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUlibByte(global::cowl.UVec_ulib_byte vec, byte item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUlibByte(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUlibByte(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUlibByte(global::cowl.UVec_ulib_byte vec, byte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPopUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqPushPopUlibByte(global::cowl.UVec_ulib_byte vec, byte @in, byte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqPushPopUlibByte(__arg0, @in, @out);
        }

        public static bool UvecMaxHeapqReplaceUlibByte(global::cowl.UVec_ulib_byte vec, byte @in, byte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqReplaceUlibByte(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMaxHeapqRemoveUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUlibByte(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUlibByte(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUlibByte(global::cowl.UVec_ulib_byte vec, byte* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPopUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqPushPopUlibByte(global::cowl.UVec_ulib_byte vec, byte @in, byte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqPushPopUlibByte(__arg0, @in, @out);
        }

        public static bool UvecMinHeapqReplaceUlibByte(global::cowl.UVec_ulib_byte vec, byte @in, byte* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqReplaceUlibByte(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMinHeapqRemoveUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUlibByte(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_byte UvecUlibByte()
        {
            var ___ret = new global::cowl.UVec_ulib_byte.__Internal();
            __Internal.UvecUlibByte(new IntPtr(&___ret));
            return global::cowl.UVec_ulib_byte.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_byte UvecAssignUlibByte(byte* array, uint count)
        {
            var ___ret = new global::cowl.UVec_ulib_byte.__Internal();
            __Internal.UvecAssignUlibByte(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_ulib_byte.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_byte UvecWrapUlibByte(byte* array, uint count)
        {
            var ___ret = new global::cowl.UVec_ulib_byte.__Internal();
            __Internal.UvecWrapUlibByte(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_ulib_byte.__CreateInstance(___ret);
        }

        public static byte* UvecDataUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUlibByte(__arg0);
            return ___ret;
        }

        public static uint UvecSizeUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUlibByte(__arg0);
            return ___ret;
        }

        public static uint UvecCountUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUlibByte(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUlibByte(global::cowl.UVec_ulib_byte vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUlibByte(__arg0, count);
        }

        public static byte UvecLastUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastUlibByte(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_byte UvecViewFromUlibByte(global::cowl.UVec_ulib_byte vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_byte.__Internal();
            __Internal.UvecViewFromUlibByte(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_ulib_byte.__CreateInstance(___ret);
        }

        public static void UvecDeinitUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUlibByte(__arg0);
        }

        public static global::cowl.UVec_ulib_byte UvecMoveUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_byte.__Internal();
            __Internal.UvecMoveUlibByte(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_ulib_byte.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUlibByte(global::cowl.UVec_ulib_byte vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUlibByte(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUlibByte(global::cowl.UVec_ulib_byte vec, global::cowl.UVec_ulib_byte src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUlibByte(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUlibByte(global::cowl.UVec_ulib_byte vec, byte* src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecAppendArrayUlibByte(__arg0, src, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecInsertAtUlibByte(global::cowl.UVec_ulib_byte vec, uint idx, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtUlibByte(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUlibByte(global::cowl.UVec_ulib_byte vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUlibByte(__arg0, idx);
        }

        public static void UvecClearUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUlibByte(__arg0);
        }

        public static global::cowl.UVecLoop_ulib_byte PUvecLoopInitUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_byte.__Internal();
            __Internal.PUvecLoopInitUlibByte(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_byte.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_ulib_byte PUvecLoopReverseInitUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_byte.__Internal();
            __Internal.PUvecLoopReverseInitUlibByte(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_byte.__CreateInstance(___ret);
        }

        public static bool UvecContainsUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsUlibByte(__arg0, item);
            return ___ret;
        }

        public static void UvecSortUlibByte(global::cowl.UVec_ulib_byte vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUlibByte(__arg0);
        }

        public static bool UvecSortedContainsUlibByte(global::cowl.UVec_ulib_byte vec, byte item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsUlibByte(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUlibInt(global::cowl.UVec_ulib_int vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUlibInt(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUlibInt(global::cowl.UVec_ulib_int vec, ref int array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecSetRangeUlibInt(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecCopyUlibInt(global::cowl.UVec_ulib_int src, global::cowl.UVec_ulib_int dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUlibInt(global::cowl.UVec_ulib_int vec, int[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayUlibInt(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUlibInt(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopUlibInt(global::cowl.UVec_ulib_int vec, ref int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecPopUlibInt(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecRemoveRangeUlibInt(global::cowl.UVec_ulib_int vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUlibInt(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUlibInt(global::cowl.UVec_ulib_int vec, ref int array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecInsertRangeUlibInt(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static void UvecUnorderedRemoveRangeUlibInt(global::cowl.UVec_ulib_int vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUlibInt(__arg0, start, n);
        }

        public static void UvecReverseUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUlibInt(__arg0);
        }

        public static void UvecShuffleUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUlibInt(__arg0);
        }

        public static uint UvecIndexOfUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfUlibInt(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsUlibInt(global::cowl.UVec_ulib_int vec, global::cowl.UVec_ulib_int other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueUlibInt(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUlibInt(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUlibInt(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUlibInt(global::cowl.UVec_ulib_int vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUlibInt(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUlibInt(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUlibInt(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUlibInt(global::cowl.UVec_ulib_int vec, int item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUlibInt(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUlibInt(global::cowl.UVec_ulib_int vec, int item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUlibInt(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUlibInt(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUlibInt(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUlibInt(global::cowl.UVec_ulib_int vec, ref int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMaxHeapqPopUlibInt(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMaxHeapqPushPopUlibInt(global::cowl.UVec_ulib_int vec, int @in, ref int @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMaxHeapqPushPopUlibInt(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMaxHeapqReplaceUlibInt(global::cowl.UVec_ulib_int vec, int @in, ref int @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMaxHeapqReplaceUlibInt(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMaxHeapqRemoveUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUlibInt(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUlibInt(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUlibInt(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUlibInt(global::cowl.UVec_ulib_int vec, ref int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMinHeapqPopUlibInt(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMinHeapqPushPopUlibInt(global::cowl.UVec_ulib_int vec, int @in, ref int @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMinHeapqPushPopUlibInt(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMinHeapqReplaceUlibInt(global::cowl.UVec_ulib_int vec, int @in, ref int @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMinHeapqReplaceUlibInt(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMinHeapqRemoveUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUlibInt(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_int UvecUlibInt()
        {
            var ___ret = new global::cowl.UVec_ulib_int.__Internal();
            __Internal.UvecUlibInt(new IntPtr(&___ret));
            return global::cowl.UVec_ulib_int.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_int UvecAssignUlibInt(ref int array, uint count)
        {
            fixed (int* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_int.__Internal();
                __Internal.UvecAssignUlibInt(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_int.__CreateInstance(___ret);
            }
        }

        public static global::cowl.UVec_ulib_int UvecWrapUlibInt(ref int array, uint count)
        {
            fixed (int* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_int.__Internal();
                __Internal.UvecWrapUlibInt(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_int.__CreateInstance(___ret);
            }
        }

        public static int* UvecDataUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUlibInt(__arg0);
            return ___ret;
        }

        public static uint UvecSizeUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUlibInt(__arg0);
            return ___ret;
        }

        public static uint UvecCountUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUlibInt(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUlibInt(global::cowl.UVec_ulib_int vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUlibInt(__arg0, count);
        }

        public static int UvecLastUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastUlibInt(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_int UvecViewFromUlibInt(global::cowl.UVec_ulib_int vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_int.__Internal();
            __Internal.UvecViewFromUlibInt(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_ulib_int.__CreateInstance(___ret);
        }

        public static void UvecDeinitUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUlibInt(__arg0);
        }

        public static global::cowl.UVec_ulib_int UvecMoveUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_int.__Internal();
            __Internal.UvecMoveUlibInt(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_ulib_int.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUlibInt(global::cowl.UVec_ulib_int vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUlibInt(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUlibInt(global::cowl.UVec_ulib_int vec, global::cowl.UVec_ulib_int src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUlibInt(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUlibInt(global::cowl.UVec_ulib_int vec, ref int src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (int* __src1 = &src)
            {
                var __arg1 = __src1;
                var ___ret = __Internal.UvecAppendArrayUlibInt(__arg0, __arg1, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecInsertAtUlibInt(global::cowl.UVec_ulib_int vec, uint idx, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtUlibInt(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUlibInt(global::cowl.UVec_ulib_int vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUlibInt(__arg0, idx);
        }

        public static void UvecClearUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUlibInt(__arg0);
        }

        public static global::cowl.UVecLoop_ulib_int PUvecLoopInitUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_int.__Internal();
            __Internal.PUvecLoopInitUlibInt(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_int.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_ulib_int PUvecLoopReverseInitUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_int.__Internal();
            __Internal.PUvecLoopReverseInitUlibInt(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_int.__CreateInstance(___ret);
        }

        public static bool UvecContainsUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsUlibInt(__arg0, item);
            return ___ret;
        }

        public static void UvecSortUlibInt(global::cowl.UVec_ulib_int vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUlibInt(__arg0);
        }

        public static bool UvecSortedContainsUlibInt(global::cowl.UVec_ulib_int vec, int item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsUlibInt(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUlibUint(global::cowl.UVec_ulib_uint vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUlibUint(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUlibUint(global::cowl.UVec_ulib_uint vec, ref uint array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecSetRangeUlibUint(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecCopyUlibUint(global::cowl.UVec_ulib_uint src, global::cowl.UVec_ulib_uint dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUlibUint(global::cowl.UVec_ulib_uint vec, uint[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayUlibUint(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUlibUint(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopUlibUint(global::cowl.UVec_ulib_uint vec, ref uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecPopUlibUint(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecRemoveRangeUlibUint(global::cowl.UVec_ulib_uint vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUlibUint(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUlibUint(global::cowl.UVec_ulib_uint vec, ref uint array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecInsertRangeUlibUint(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static void UvecUnorderedRemoveRangeUlibUint(global::cowl.UVec_ulib_uint vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUlibUint(__arg0, start, n);
        }

        public static void UvecReverseUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUlibUint(__arg0);
        }

        public static void UvecShuffleUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUlibUint(__arg0);
        }

        public static uint UvecIndexOfUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfUlibUint(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsUlibUint(global::cowl.UVec_ulib_uint vec, global::cowl.UVec_ulib_uint other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueUlibUint(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUlibUint(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUlibUint(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUlibUint(global::cowl.UVec_ulib_uint vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUlibUint(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUlibUint(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUlibUint(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUlibUint(global::cowl.UVec_ulib_uint vec, uint item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUlibUint(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUlibUint(global::cowl.UVec_ulib_uint vec, uint item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUlibUint(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUlibUint(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUlibUint(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUlibUint(global::cowl.UVec_ulib_uint vec, ref uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMaxHeapqPopUlibUint(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMaxHeapqPushPopUlibUint(global::cowl.UVec_ulib_uint vec, uint @in, ref uint @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMaxHeapqPushPopUlibUint(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMaxHeapqReplaceUlibUint(global::cowl.UVec_ulib_uint vec, uint @in, ref uint @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMaxHeapqReplaceUlibUint(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMaxHeapqRemoveUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUlibUint(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUlibUint(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUlibUint(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUlibUint(global::cowl.UVec_ulib_uint vec, ref uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMinHeapqPopUlibUint(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMinHeapqPushPopUlibUint(global::cowl.UVec_ulib_uint vec, uint @in, ref uint @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMinHeapqPushPopUlibUint(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMinHeapqReplaceUlibUint(global::cowl.UVec_ulib_uint vec, uint @in, ref uint @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMinHeapqReplaceUlibUint(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMinHeapqRemoveUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUlibUint(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_uint UvecUlibUint()
        {
            var ___ret = new global::cowl.UVec_ulib_uint.__Internal();
            __Internal.UvecUlibUint(new IntPtr(&___ret));
            return global::cowl.UVec_ulib_uint.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_uint UvecAssignUlibUint(ref uint array, uint count)
        {
            fixed (uint* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_uint.__Internal();
                __Internal.UvecAssignUlibUint(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_uint.__CreateInstance(___ret);
            }
        }

        public static global::cowl.UVec_ulib_uint UvecWrapUlibUint(ref uint array, uint count)
        {
            fixed (uint* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_uint.__Internal();
                __Internal.UvecWrapUlibUint(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_uint.__CreateInstance(___ret);
            }
        }

        public static uint* UvecDataUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUlibUint(__arg0);
            return ___ret;
        }

        public static uint UvecSizeUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUlibUint(__arg0);
            return ___ret;
        }

        public static uint UvecCountUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUlibUint(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUlibUint(global::cowl.UVec_ulib_uint vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUlibUint(__arg0, count);
        }

        public static uint UvecLastUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastUlibUint(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_uint UvecViewFromUlibUint(global::cowl.UVec_ulib_uint vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_uint.__Internal();
            __Internal.UvecViewFromUlibUint(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_ulib_uint.__CreateInstance(___ret);
        }

        public static void UvecDeinitUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUlibUint(__arg0);
        }

        public static global::cowl.UVec_ulib_uint UvecMoveUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_uint.__Internal();
            __Internal.UvecMoveUlibUint(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_ulib_uint.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUlibUint(global::cowl.UVec_ulib_uint vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUlibUint(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUlibUint(global::cowl.UVec_ulib_uint vec, global::cowl.UVec_ulib_uint src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUlibUint(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUlibUint(global::cowl.UVec_ulib_uint vec, ref uint src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __src1 = &src)
            {
                var __arg1 = __src1;
                var ___ret = __Internal.UvecAppendArrayUlibUint(__arg0, __arg1, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecInsertAtUlibUint(global::cowl.UVec_ulib_uint vec, uint idx, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtUlibUint(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUlibUint(global::cowl.UVec_ulib_uint vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUlibUint(__arg0, idx);
        }

        public static void UvecClearUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUlibUint(__arg0);
        }

        public static global::cowl.UVecLoop_ulib_uint PUvecLoopInitUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_uint.__Internal();
            __Internal.PUvecLoopInitUlibUint(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_uint.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_ulib_uint PUvecLoopReverseInitUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_uint.__Internal();
            __Internal.PUvecLoopReverseInitUlibUint(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_uint.__CreateInstance(___ret);
        }

        public static bool UvecContainsUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsUlibUint(__arg0, item);
            return ___ret;
        }

        public static void UvecSortUlibUint(global::cowl.UVec_ulib_uint vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUlibUint(__arg0);
        }

        public static bool UvecSortedContainsUlibUint(global::cowl.UVec_ulib_uint vec, uint item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsUlibUint(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUlibFloat(global::cowl.UVec_ulib_float vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUlibFloat(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUlibFloat(global::cowl.UVec_ulib_float vec, ref double array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecSetRangeUlibFloat(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecCopyUlibFloat(global::cowl.UVec_ulib_float src, global::cowl.UVec_ulib_float dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUlibFloat(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUlibFloat(global::cowl.UVec_ulib_float vec, double[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayUlibFloat(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUlibFloat(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopUlibFloat(global::cowl.UVec_ulib_float vec, ref double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecPopUlibFloat(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecRemoveRangeUlibFloat(global::cowl.UVec_ulib_float vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUlibFloat(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUlibFloat(global::cowl.UVec_ulib_float vec, ref double array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __array1 = &array)
            {
                var __arg1 = __array1;
                var ___ret = __Internal.UvecInsertRangeUlibFloat(__arg0, __arg1, start, n);
                return ___ret;
            }
        }

        public static void UvecUnorderedRemoveRangeUlibFloat(global::cowl.UVec_ulib_float vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUlibFloat(__arg0, start, n);
        }

        public static void UvecReverseUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUlibFloat(__arg0);
        }

        public static void UvecShuffleUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUlibFloat(__arg0);
        }

        public static uint UvecIndexOfUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfUlibFloat(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsUlibFloat(global::cowl.UVec_ulib_float vec, global::cowl.UVec_ulib_float other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUlibFloat(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueUlibFloat(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUlibFloat(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUlibFloat(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUlibFloat(global::cowl.UVec_ulib_float vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUlibFloat(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUlibFloat(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUlibFloat(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUlibFloat(global::cowl.UVec_ulib_float vec, double item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUlibFloat(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUlibFloat(global::cowl.UVec_ulib_float vec, double item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUlibFloat(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUlibFloat(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUlibFloat(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUlibFloat(global::cowl.UVec_ulib_float vec, ref double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMaxHeapqPopUlibFloat(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMaxHeapqPushPopUlibFloat(global::cowl.UVec_ulib_float vec, double @in, ref double @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMaxHeapqPushPopUlibFloat(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMaxHeapqReplaceUlibFloat(global::cowl.UVec_ulib_float vec, double @in, ref double @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMaxHeapqReplaceUlibFloat(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMaxHeapqRemoveUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUlibFloat(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUlibFloat(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUlibFloat(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUlibFloat(global::cowl.UVec_ulib_float vec, ref double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __item1 = &item)
            {
                var __arg1 = __item1;
                var ___ret = __Internal.UvecMinHeapqPopUlibFloat(__arg0, __arg1);
                return ___ret;
            }
        }

        public static void UvecMinHeapqPushPopUlibFloat(global::cowl.UVec_ulib_float vec, double @in, ref double @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __out2 = &@out)
            {
                var __arg2 = __out2;
                __Internal.UvecMinHeapqPushPopUlibFloat(__arg0, @in, __arg2);
            }
        }

        public static bool UvecMinHeapqReplaceUlibFloat(global::cowl.UVec_ulib_float vec, double @in, ref double @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __out2 = &@out)
            {
                var __arg2 = __out2;
                var ___ret = __Internal.UvecMinHeapqReplaceUlibFloat(__arg0, @in, __arg2);
                return ___ret;
            }
        }

        public static bool UvecMinHeapqRemoveUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUlibFloat(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_float UvecUlibFloat()
        {
            var ___ret = new global::cowl.UVec_ulib_float.__Internal();
            __Internal.UvecUlibFloat(new IntPtr(&___ret));
            return global::cowl.UVec_ulib_float.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_float UvecAssignUlibFloat(ref double array, uint count)
        {
            fixed (double* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_float.__Internal();
                __Internal.UvecAssignUlibFloat(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_float.__CreateInstance(___ret);
            }
        }

        public static global::cowl.UVec_ulib_float UvecWrapUlibFloat(ref double array, uint count)
        {
            fixed (double* __array0 = &array)
            {
                var __arg0 = __array0;
                var ___ret = new global::cowl.UVec_ulib_float.__Internal();
                __Internal.UvecWrapUlibFloat(new IntPtr(&___ret), __arg0, count);
                return global::cowl.UVec_ulib_float.__CreateInstance(___ret);
            }
        }

        public static double* UvecDataUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUlibFloat(__arg0);
            return ___ret;
        }

        public static uint UvecSizeUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUlibFloat(__arg0);
            return ___ret;
        }

        public static uint UvecCountUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUlibFloat(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUlibFloat(global::cowl.UVec_ulib_float vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUlibFloat(__arg0, count);
        }

        public static double UvecLastUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastUlibFloat(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_float UvecViewFromUlibFloat(global::cowl.UVec_ulib_float vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_float.__Internal();
            __Internal.UvecViewFromUlibFloat(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_ulib_float.__CreateInstance(___ret);
        }

        public static void UvecDeinitUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUlibFloat(__arg0);
        }

        public static global::cowl.UVec_ulib_float UvecMoveUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_float.__Internal();
            __Internal.UvecMoveUlibFloat(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_ulib_float.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUlibFloat(global::cowl.UVec_ulib_float vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUlibFloat(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUlibFloat(global::cowl.UVec_ulib_float vec, global::cowl.UVec_ulib_float src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUlibFloat(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUlibFloat(global::cowl.UVec_ulib_float vec, ref double src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (double* __src1 = &src)
            {
                var __arg1 = __src1;
                var ___ret = __Internal.UvecAppendArrayUlibFloat(__arg0, __arg1, n);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecInsertAtUlibFloat(global::cowl.UVec_ulib_float vec, uint idx, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtUlibFloat(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUlibFloat(global::cowl.UVec_ulib_float vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUlibFloat(__arg0, idx);
        }

        public static void UvecClearUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUlibFloat(__arg0);
        }

        public static global::cowl.UVecLoop_ulib_float PUvecLoopInitUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_float.__Internal();
            __Internal.PUvecLoopInitUlibFloat(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_float.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_ulib_float PUvecLoopReverseInitUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_float.__Internal();
            __Internal.PUvecLoopReverseInitUlibFloat(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_float.__CreateInstance(___ret);
        }

        public static bool UvecContainsUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsUlibFloat(__arg0, item);
            return ___ret;
        }

        public static void UvecSortUlibFloat(global::cowl.UVec_ulib_float vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUlibFloat(__arg0);
        }

        public static bool UvecSortedContainsUlibFloat(global::cowl.UVec_ulib_float vec, double item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsUlibFloat(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUlibPtr(global::cowl.UVec_ulib_ptr vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUlibPtr(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSetRangeUlibPtr(__arg0, array, start, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecCopyUlibPtr(global::cowl.UVec_ulib_ptr src, global::cowl.UVec_ulib_ptr dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayUlibPtr(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUlibPtr(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPopUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecRemoveRangeUlibPtr(global::cowl.UVec_ulib_ptr vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUlibPtr(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertRangeUlibPtr(__arg0, array, start, n);
            return ___ret;
        }

        public static void UvecUnorderedRemoveRangeUlibPtr(global::cowl.UVec_ulib_ptr vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUlibPtr(__arg0, start, n);
        }

        public static void UvecReverseUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUlibPtr(__arg0);
        }

        public static void UvecShuffleUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUlibPtr(__arg0);
        }

        public static uint UvecIndexOfUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfUlibPtr(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsUlibPtr(global::cowl.UVec_ulib_ptr vec, global::cowl.UVec_ulib_ptr other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueUlibPtr(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfMinUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUlibPtr(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUlibPtr(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUlibPtr(global::cowl.UVec_ulib_ptr vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUlibPtr(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUlibPtr(__arg0, item);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUlibPtr(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUlibPtr(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUlibPtr(__arg0, item, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUlibPtr(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPopUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecMaxHeapqPushPopUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr @in, __IntPtr* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqPushPopUlibPtr(__arg0, @in, @out);
        }

        public static bool UvecMaxHeapqReplaceUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr @in, __IntPtr* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqReplaceUlibPtr(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMaxHeapqRemoveUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUlibPtr(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUlibPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqPopUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecMinHeapqPushPopUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr @in, __IntPtr* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqPushPopUlibPtr(__arg0, @in, @out);
        }

        public static bool UvecMinHeapqReplaceUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr @in, __IntPtr* @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqReplaceUlibPtr(__arg0, @in, @out);
            return ___ret;
        }

        public static bool UvecMinHeapqRemoveUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUlibPtr(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_ptr UvecUlibPtr()
        {
            var ___ret = new global::cowl.UVec_ulib_ptr.__Internal();
            __Internal.UvecUlibPtr(new IntPtr(&___ret));
            return global::cowl.UVec_ulib_ptr.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_ptr UvecAssignUlibPtr(__IntPtr* array, uint count)
        {
            var ___ret = new global::cowl.UVec_ulib_ptr.__Internal();
            __Internal.UvecAssignUlibPtr(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_ulib_ptr.__CreateInstance(___ret);
        }

        public static global::cowl.UVec_ulib_ptr UvecWrapUlibPtr(__IntPtr* array, uint count)
        {
            var ___ret = new global::cowl.UVec_ulib_ptr.__Internal();
            __Internal.UvecWrapUlibPtr(new IntPtr(&___ret), array, count);
            return global::cowl.UVec_ulib_ptr.__CreateInstance(___ret);
        }

        public static __IntPtr* UvecDataUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUlibPtr(__arg0);
            return ___ret;
        }

        public static uint UvecSizeUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUlibPtr(__arg0);
            return ___ret;
        }

        public static uint UvecCountUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUlibPtr(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUlibPtr(global::cowl.UVec_ulib_ptr vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUlibPtr(__arg0, count);
        }

        public static __IntPtr UvecLastUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastUlibPtr(__arg0);
            return ___ret;
        }

        public static global::cowl.UVec_ulib_ptr UvecViewFromUlibPtr(global::cowl.UVec_ulib_ptr vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_ptr.__Internal();
            __Internal.UvecViewFromUlibPtr(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVec_ulib_ptr.__CreateInstance(___ret);
        }

        public static void UvecDeinitUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUlibPtr(__arg0);
        }

        public static global::cowl.UVec_ulib_ptr UvecMoveUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVec_ulib_ptr.__Internal();
            __Internal.UvecMoveUlibPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVec_ulib_ptr.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUlibPtr(global::cowl.UVec_ulib_ptr vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUlibPtr(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUlibPtr(global::cowl.UVec_ulib_ptr vec, global::cowl.UVec_ulib_ptr src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUlibPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr* src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecAppendArrayUlibPtr(__arg0, src, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecInsertAtUlibPtr(global::cowl.UVec_ulib_ptr vec, uint idx, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtUlibPtr(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUlibPtr(global::cowl.UVec_ulib_ptr vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUlibPtr(__arg0, idx);
        }

        public static void UvecClearUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUlibPtr(__arg0);
        }

        public static global::cowl.UVecLoop_ulib_ptr PUvecLoopInitUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_ptr.__Internal();
            __Internal.PUvecLoopInitUlibPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_ptr.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoop_ulib_ptr PUvecLoopReverseInitUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoop_ulib_ptr.__Internal();
            __Internal.PUvecLoopReverseInitUlibPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoop_ulib_ptr.__CreateInstance(___ret);
        }

        public static bool UvecContainsUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsUlibPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecSortUlibPtr(global::cowl.UVec_ulib_ptr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUlibPtr(__arg0);
        }

        public static bool UvecSortedContainsUlibPtr(global::cowl.UVec_ulib_ptr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSortedContainsUlibPtr(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecReserveUString(global::cowl.UVecUString vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveUString(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeUString(global::cowl.UVecUString vec, global::cowl.UString array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.UvecSetRangeUString(__arg0, __arg1, start, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecCopyUString(global::cowl.UVecUString src, global::cowl.UVecUString dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayUString(global::cowl.UVecUString vec, global::cowl.UString[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            global::cowl.UString.__Internal[] __array;
            if (array == null)
                __array = null;
            else
            {
                __array = new global::cowl.UString.__Internal[array.Length];
                for (int i = 0; i < __array.Length; i++)
                {
                    var __element = array[i];
                    __array[i] = __element is null ? new global::cowl.UString.__Internal() : *(global::cowl.UString.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __array;
            __Internal.UvecCopyToArrayUString(__arg0, __arg1);
        }

        public static global::cowl.UvecRet UvecShrinkUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkUString(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecPushUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecPopUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = item is null ? __IntPtr.Zero : item.__Instance;
            var ___ret = __Internal.UvecPopUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecRemoveRangeUString(global::cowl.UVecUString vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeUString(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeUString(global::cowl.UVecUString vec, global::cowl.UString array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.UvecInsertRangeUString(__arg0, __arg1, start, n);
            return ___ret;
        }

        public static void UvecUnorderedRemoveRangeUString(global::cowl.UVecUString vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeUString(__arg0, start, n);
        }

        public static void UvecReverseUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseUString(__arg0);
        }

        public static void UvecShuffleUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleUString(__arg0);
        }

        public static uint UvecIndexOfUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecIndexOfUString(__arg0, __arg1);
            return ___ret;
        }

        public static uint UvecIndexOfReverseUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecRemoveUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecRemoveUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecEqualsUString(global::cowl.UVecUString vec, global::cowl.UVecUString other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecPushUniqueUString(__arg0, __arg1);
            return ___ret;
        }

        public static uint UvecIndexOfMinUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMinUString(__arg0);
            return ___ret;
        }

        public static uint UvecIndexOfMaxUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfMaxUString(__arg0);
            return ___ret;
        }

        public static void UvecSortRangeUString(global::cowl.UVecUString vec, uint start, uint len)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortRangeUString(__arg0, start, len);
        }

        public static uint UvecSortedInsertionIndexUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecSortedInsertionIndexUString(__arg0, __arg1);
            return ___ret;
        }

        public static uint UvecSortedIndexOfUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecSortedIndexOfUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSortedInsertUString(global::cowl.UVecUString vec, global::cowl.UString item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedInsertUString(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        public static global::cowl.UvecRet UvecSortedUniqueInsertUString(global::cowl.UVecUString vec, global::cowl.UString item, ref uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UvecSortedUniqueInsertUString(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        public static bool UvecSortedRemoveUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecSortedRemoveUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecMaxHeapqMakeUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMaxHeapqMakeUString(__arg0);
        }

        public static global::cowl.UvecRet UvecMaxHeapqPushUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPushUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecMaxHeapqPopUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = item is null ? __IntPtr.Zero : item.__Instance;
            var ___ret = __Internal.UvecMaxHeapqPopUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecMaxHeapqPushPopUString(global::cowl.UVecUString vec, global::cowl.UString @in, global::cowl.UString @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg1 = @in.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            __Internal.UvecMaxHeapqPushPopUString(__arg0, __arg1, __arg2);
        }

        public static bool UvecMaxHeapqReplaceUString(global::cowl.UVecUString vec, global::cowl.UString @in, global::cowl.UString @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg1 = @in.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            var ___ret = __Internal.UvecMaxHeapqReplaceUString(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static bool UvecMaxHeapqRemoveUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecMaxHeapqRemoveUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecMinHeapqMakeUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecMinHeapqMakeUString(__arg0);
        }

        public static global::cowl.UvecRet UvecMinHeapqPushUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecMinHeapqPushUString(__arg0, __arg1);
            return ___ret;
        }

        public static bool UvecMinHeapqPopUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = item is null ? __IntPtr.Zero : item.__Instance;
            var ___ret = __Internal.UvecMinHeapqPopUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecMinHeapqPushPopUString(global::cowl.UVecUString vec, global::cowl.UString @in, global::cowl.UString @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg1 = @in.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            __Internal.UvecMinHeapqPushPopUString(__arg0, __arg1, __arg2);
        }

        public static bool UvecMinHeapqReplaceUString(global::cowl.UVecUString vec, global::cowl.UString @in, global::cowl.UString @out)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg1 = @in.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            var ___ret = __Internal.UvecMinHeapqReplaceUString(__arg0, __arg1, __arg2);
            return ___ret;
        }

        public static bool UvecMinHeapqRemoveUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecMinHeapqRemoveUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UVecUString UvecUString()
        {
            var ___ret = new global::cowl.UVecUString.__Internal();
            __Internal.UvecUString(new IntPtr(&___ret));
            return global::cowl.UVecUString.__CreateInstance(___ret);
        }

        public static global::cowl.UVecUString UvecAssignUString(global::cowl.UString array, uint count)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = new global::cowl.UVecUString.__Internal();
            __Internal.UvecAssignUString(new IntPtr(&___ret), __arg0, count);
            return global::cowl.UVecUString.__CreateInstance(___ret);
        }

        public static global::cowl.UVecUString UvecWrapUString(global::cowl.UString array, uint count)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = new global::cowl.UVecUString.__Internal();
            __Internal.UvecWrapUString(new IntPtr(&___ret), __arg0, count);
            return global::cowl.UVecUString.__CreateInstance(___ret);
        }

        public static global::cowl.UString UvecDataUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataUString(__arg0);
            var __result0 = global::cowl.UString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint UvecSizeUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeUString(__arg0);
            return ___ret;
        }

        public static uint UvecCountUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountUString(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountUString(global::cowl.UVecUString vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountUString(__arg0, count);
        }

        public static global::cowl.UString UvecLastUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UvecLastUString(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        public static global::cowl.UVecUString UvecViewFromUString(global::cowl.UVecUString vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecUString.__Internal();
            __Internal.UvecViewFromUString(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVecUString.__CreateInstance(___ret);
        }

        public static void UvecDeinitUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitUString(__arg0);
        }

        public static global::cowl.UVecUString UvecMoveUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecUString.__Internal();
            __Internal.UvecMoveUString(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecUString.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandUString(global::cowl.UVecUString vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandUString(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendUString(global::cowl.UVecUString vec, global::cowl.UVecUString src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendUString(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayUString(global::cowl.UVecUString vec, global::cowl.UString src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendArrayUString(__arg0, __arg1, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecInsertAtUString(global::cowl.UVecUString vec, uint idx, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg2 = item.__Instance;
            var ___ret = __Internal.UvecInsertAtUString(__arg0, idx, __arg2);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtUString(global::cowl.UVecUString vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtUString(__arg0, idx);
        }

        public static void UvecClearUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearUString(__arg0);
        }

        public static global::cowl.UVecLoopUString PUvecLoopInitUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoopUString.__Internal();
            __Internal.PUvecLoopInitUString(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoopUString.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoopUString PUvecLoopReverseInitUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoopUString.__Internal();
            __Internal.PUvecLoopReverseInitUString(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoopUString.__CreateInstance(___ret);
        }

        public static bool UvecContainsUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecContainsUString(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecSortUString(global::cowl.UVecUString vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecSortUString(__arg0);
        }

        public static bool UvecSortedContainsUString(global::cowl.UVecUString vec, global::cowl.UString item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            if (ReferenceEquals(item, null))
                throw new global::System.ArgumentNullException("item", "Cannot be null because it is passed by value.");
            var __arg1 = item.__Instance;
            var ___ret = __Internal.UvecSortedContainsUString(__arg0, __arg1);
            return ___ret;
        }
    }

    /// <summary>A mutable string buffer.</summary>
    /// <remarks>
    /// <para>A string buffer is a{#UVec(T)} of{char} elements,</para>
    /// <para>so you can use any{#UVec(T)} API on a{#UStrBuf} object.</para>
    /// </remarks>
    public unsafe partial class ustrbuf
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustrbuf_append_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UstrbufAppendFormat(__IntPtr buf, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "ustrbuf_to_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UstrbufToUstring(__IntPtr @return, __IntPtr buf);
        }

        /// <summary>Appends the specified formatted string to the string buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <param name="format">Format string.</param>
        /// <param name="...">Format arguments.</param>
        public static global::cowl.UvecRet UstrbufAppendFormat(global::cowl.UVec_char buf, string format)
        {
            var __arg0 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.UstrbufAppendFormat(__arg0, format);
            return ___ret;
        }

        /// <summary>Converts the string buffer into aand deinitializes the buffer.</summary>
        /// <param name="buf">String buffer.</param>
        /// <returns>String.</returns>
        /// <remarks>After calling this function, the string buffer must not be used anymore.</remarks>
        public static global::cowl.UString UstrbufToUstring(global::cowl.UVec_char buf)
        {
            var __arg0 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UstrbufToUstring(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }
    }

    /// <summary>Time units.</summary>
    public enum UtimeUnit
    {
        /// <summary>Nanoseconds.</summary>
        UTIME_NANOSECONDS = 0,
        /// <summary>Microseconds.</summary>
        UTIME_MICROSECONDS = 1,
        /// <summary>Milliseconds.</summary>
        UTIME_MILLISECONDS = 2,
        /// <summary>Seconds.</summary>
        UTIME_SECONDS = 3,
        /// <summary>Minutes.</summary>
        UTIME_MINUTES = 4,
        /// <summary>Hours.</summary>
        UTIME_HOURS = 5,
        /// <summary>Days.</summary>
        UTIME_DAYS = 6,
        /// <summary>Months.</summary>
        UTIME_MONTHS = 7,
        /// <summary>Years.</summary>
        UTIME_YEARS = 8
    }

    /// <summary>Timestamp expressed as seconds since January 1 1970, 00:00:00.</summary>
    /// <summary>Nanoseconds type, suitable for storing CPU time.</summary>
    /// <summary>Time units.</summary>
    /// <summary>Date and time.</summary>
    /// <summary>Date and time.</summary>
    public unsafe partial class UTime : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long year;

            [FieldOffset(8)]
            internal uint month;

            [FieldOffset(8)]
            internal uint day;

            [FieldOffset(9)]
            internal uint hour;

            [FieldOffset(9)]
            internal uint minute;

            [FieldOffset(10)]
            internal uint second;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UTime@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_equals", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UtimeEquals(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_to_timestamp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long UtimeToTimestamp(__IntPtr time);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_from_timestamp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeFromTimestamp(__IntPtr @return, long ts);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeAdd(__IntPtr time, long quantity, global::cowl.UtimeUnit unit);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_to_utc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeToUtc(__IntPtr time, int tz_hour, uint tz_minute);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_to_timezone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeToTimezone(__IntPtr time, int tz_hour, uint tz_minute);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?utime_normalize_to_utc@@YAXPEAUUTime@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeNormalizeToUtc(__IntPtr time, int tz_hour, uint tz_minute);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_diff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long UtimeDiff(__IntPtr a, __IntPtr b, global::cowl.UtimeUnit unit);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeToString(__IntPtr @return, __IntPtr time);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_from_string", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UtimeFromString(__IntPtr time, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?utime_is_leap_year@@YA_N_J@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UtimeIsLeapYear(long year);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?utime_days_in_month@@YAI_JI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UtimeDaysInMonth(long year, uint month);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_interval_unit_auto", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UtimeUnit UtimeIntervalUnitAuto(ulong t);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_interval_convert", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double UtimeIntervalConvert(ulong t, global::cowl.UtimeUnit unit);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_interval_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeIntervalToString(__IntPtr @return, ulong t, global::cowl.UtimeUnit unit);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_now", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeNow(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_local", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UtimeLocal(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_get_timestamp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long UtimeGetTimestamp();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utime_get_ns", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong UtimeGetNs();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UTime> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UTime>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UTime managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UTime managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UTime __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UTime(native.ToPointer(), skipVTables);
        }

        internal static UTime __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UTime)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UTime __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UTime(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UTime(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UTime(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UTime()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UTime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UTime(global::cowl.UTime _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UTime.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UTime.__Internal*) __Instance) = *((global::cowl.UTime.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Checks whether the specified dates and times are equal.</summary>
        /// <param name="a">First date and time.</param>
        /// <param name="b">Second date and time.</param>
        /// <returns>True if the two dates and times are equal, false otherwise.</returns>
        public static bool UtimeEquals(global::cowl.UTime a, global::cowl.UTime b)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.UtimeEquals(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Converts the specified UTC date abd time into a timestamp.</summary>
        /// <param name="time">Date and time to convert.</param>
        /// <returns>Corresponding timestamp.</returns>
        public static long UtimeToTimestamp(global::cowl.UTime time)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            var ___ret = __Internal.UtimeToTimestamp(__arg0);
            return ___ret;
        }

        /// <summary>Converts the specified timestamp into a UTC date and time.</summary>
        /// <param name="ts">Timestamp to convert.</param>
        /// <returns>Corresponding UTC date and time.</returns>
        public static global::cowl.UTime UtimeFromTimestamp(long ts)
        {
            var ___ret = new global::cowl.UTime.__Internal();
            __Internal.UtimeFromTimestamp(new IntPtr(&___ret), ts);
            return global::cowl.UTime.__CreateInstance(___ret);
        }

        /// <summary>Adds a certain time interval to the specified date and time.</summary>
        /// <param name="time">Date and time.</param>
        /// <param name="quantity">Quantity to add.</param>
        /// <param name="unit">Time unit.</param>
        public static void UtimeAdd(global::cowl.UTime time, long quantity, global::cowl.UtimeUnit unit)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            __Internal.UtimeAdd(__arg0, quantity, unit);
        }

        /// <summary>Transforms a date and time from the specified timezone to UTC.</summary>
        /// <param name="time">Date and time to transform.</param>
        /// <param name="tz_hour">Timezone offset hours.</param>
        /// <param name="tz_minute">Timezone offset minutes.</param>
        public static void UtimeToUtc(global::cowl.UTime time, int tz_hour, uint tz_minute)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            __Internal.UtimeToUtc(__arg0, tz_hour, tz_minute);
        }

        /// <summary>Transforms a date and time from UTC to the specified timezone.</summary>
        /// <param name="time">Date and time to transform.</param>
        /// <param name="tz_hour">Timezone offset hours.</param>
        /// <param name="tz_minute">Timezone offset minutes.</param>
        public static void UtimeToTimezone(global::cowl.UTime time, int tz_hour, uint tz_minute)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            __Internal.UtimeToTimezone(__arg0, tz_hour, tz_minute);
        }

        public static void UtimeNormalizeToUtc(global::cowl.UTime time, int tz_hour, uint tz_minute)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            __Internal.UtimeNormalizeToUtc(__arg0, tz_hour, tz_minute);
        }

        /// <summary>Returns the difference between the specified dates and times.</summary>
        /// <param name="a">First date and time.</param>
        /// <param name="b">Second date and time.</param>
        /// <param name="unit">Time unit.</param>
        /// <returns>Difference between the specified dates and times.</returns>
        public static long UtimeDiff(global::cowl.UTime a, global::cowl.UTime b, global::cowl.UtimeUnit unit)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.UtimeDiff(__arg0, __arg1, unit);
            return ___ret;
        }

        /// <summary>Converts the specified date and time into a human readable string.</summary>
        /// <param name="time">Date and time.</param>
        /// <returns>Human readable string.</returns>
        public static global::cowl.UString UtimeToString(global::cowl.UTime time)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UtimeToString(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Parses a date and time from the specified string.</summary>
        /// <param name="time">Date and time.</param>
        /// <param name="string">Date string.</param>
        /// <returns>True if the string was parsed without errors, false otherwise.</returns>
        /// <remarks>
        /// <para>The string must be in `Y_M_D_H_M_S` format, where each component is separated by any</para>
        /// <para>non-digit character. An optional timezone specifier can also be specified, in which case</para>
        /// <para>the date is automatically normalized to UTC. Examples of equivalent dates:</para>
        /// <para>- 1990/02/14 13:30:00</para>
        /// <para>- 1990-02-14T13:30:00Z</para>
        /// <para>- 1990 02 14 14.30.00+1:00</para>
        /// </remarks>
        public static bool UtimeFromString(global::cowl.UTime time, global::cowl.UString @string)
        {
            var __arg0 = time is null ? __IntPtr.Zero : time.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.UtimeFromString(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Checks whether the specified year is a leap year.</summary>
        /// <param name="year">Year.</param>
        /// <returns>True if the specified year is a leap year, false otherwise.</returns>
        public static bool UtimeIsLeapYear(long year)
        {
            var ___ret = __Internal.UtimeIsLeapYear(year);
            return ___ret;
        }

        /// <summary>Returns the number of days in the specified month.</summary>
        /// <param name="year">Year.</param>
        /// <param name="month">Month.</param>
        /// <returns>Number of days in the specified month.</returns>
        public static uint UtimeDaysInMonth(long year, uint month)
        {
            var ___ret = __Internal.UtimeDaysInMonth(year, month);
            return ___ret;
        }

        /// <summary>Returns an appropriate time unit for the specified time interval.</summary>
        /// <param name="t">Time interval in nanoseconds.</param>
        /// <returns>Appropriate time unit.</returns>
        public static global::cowl.UtimeUnit UtimeIntervalUnitAuto(ulong t)
        {
            var ___ret = __Internal.UtimeIntervalUnitAuto(t);
            return ___ret;
        }

        /// <summary>Converts a time interval according to the specified time unit.</summary>
        /// <param name="t">Time interval.</param>
        /// <param name="unit">Time unit.</param>
        /// <returns>Converted time interval.</returns>
        public static double UtimeIntervalConvert(ulong t, global::cowl.UtimeUnit unit)
        {
            var ___ret = __Internal.UtimeIntervalConvert(t, unit);
            return ___ret;
        }

        /// <summary>Converts a time interval into a string formatted according to the specified time unit.</summary>
        /// <param name="t">Time interval in nanoseconds.</param>
        /// <param name="unit">Time unit.</param>
        /// <returns>Time interval in string form.</returns>
        public static global::cowl.UString UtimeIntervalToString(ulong t, global::cowl.UtimeUnit unit)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.UtimeIntervalToString(new IntPtr(&___ret), t, unit);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Year.</summary>
        public long Year
        {
            get
            {
                return ((__Internal*)__Instance)->year;
            }

            set
            {
                ((__Internal*)__Instance)->year = value;
            }
        }

        /// <summary>Month.</summary>
        public uint Month
        {
            get
            {
                return ((__Internal*)__Instance)->month;
            }

            set
            {
                ((__Internal*)__Instance)->month = value;
            }
        }

        /// <summary>Day.</summary>
        public uint Day
        {
            get
            {
                return ((__Internal*)__Instance)->day;
            }

            set
            {
                ((__Internal*)__Instance)->day = value;
            }
        }

        /// <summary>Hour.</summary>
        public uint Hour
        {
            get
            {
                return ((__Internal*)__Instance)->hour;
            }

            set
            {
                ((__Internal*)__Instance)->hour = value;
            }
        }

        /// <summary>Minute.</summary>
        public uint Minute
        {
            get
            {
                return ((__Internal*)__Instance)->minute;
            }

            set
            {
                ((__Internal*)__Instance)->minute = value;
            }
        }

        /// <summary>Second.</summary>
        public uint Second
        {
            get
            {
                return ((__Internal*)__Instance)->second;
            }

            set
            {
                ((__Internal*)__Instance)->second = value;
            }
        }

        /// <summary>Gets the current UTC date and time.</summary>
        /// <returns>Current UTC date and time.</returns>
        public static global::cowl.UTime UtimeNow
        {
            get
            {
                var ___ret = new global::cowl.UTime.__Internal();
                __Internal.UtimeNow(new IntPtr(&___ret));
                return global::cowl.UTime.__CreateInstance(___ret);
            }
        }

        /// <summary>Gets the current local date and time.</summary>
        /// <returns>Current local date and time.</returns>
        public static global::cowl.UTime UtimeLocal
        {
            get
            {
                var ___ret = new global::cowl.UTime.__Internal();
                __Internal.UtimeLocal(new IntPtr(&___ret));
                return global::cowl.UTime.__CreateInstance(___ret);
            }
        }

        /// <summary>Retrieves a timestamp expressed as seconds since January 1 1970, 00:00:00.</summary>
        /// <returns>Timestamp.</returns>
        public static long UtimeGetTimestamp
        {
            get
            {
                var ___ret = __Internal.UtimeGetTimestamp();
                return ___ret;
            }
        }

        /// <summary>Retrieves a timestamp in nanoseconds.</summary>
        /// <returns>Timestamp in nanoseconds.</returns>
        /// <remarks>The timestamp is suitable for benchmarking purposes.</remarks>
        public static ulong UtimeGetNs
        {
            get
            {
                var ___ret = __Internal.UtimeGetNs();
                return ___ret;
            }
        }
    }

    /// <summary>Return codes for IO streams.</summary>
    public enum UstreamRet
    {
        /// <summary>Success.</summary>
        USTREAM_OK = 0,
        /// <summary>Buffer bounds exceeded, usually when writing to a stream backed by a fixed memory buffer.</summary>
        USTREAM_ERR_BOUNDS = 1,
        /// <summary>Memory error, usually caused by failed allocations.</summary>
        USTREAM_ERR_MEM = 2,
        /// <summary>Input/output error, usually returned when a file or stream operation fails.</summary>
        /// <remarks>When this happens, `errno` is sometimes set to a more meaningful value.</remarks>
        USTREAM_ERR_IO = 3,
        /// <summary>Generic error.</summary>
        USTREAM_ERR = 4
    }

    /// <summary>An immutable string.</summary>
    /// <summary>Version information.</summary>
    /// <summary>Return codes for IO streams.</summary>
    /// <summary>Models an input stream.</summary>
    /// <summary>Models an output stream.</summary>
    /// <summary>Models an input stream.</summary>
    public unsafe partial class UIStream : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal global::cowl.UstreamRet state;
            internal ulong read_bytes;
            internal __IntPtr ctx;
            internal __IntPtr read;
            internal __IntPtr reset;
            internal __IntPtr free;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UIStream@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UIStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UIStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UIStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UIStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UIStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UIStream(native.ToPointer(), skipVTables);
        }

        internal static UIStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UIStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UIStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UIStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UIStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UIStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UIStream()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UIStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UIStream(global::cowl.UIStream _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UIStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UIStream.__Internal*) __Instance) = *((global::cowl.UIStream.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Stream state.</summary>
        public global::cowl.UstreamRet State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Bytes read since the last `reset` call.</summary>
        public ulong ReadBytes
        {
            get
            {
                return ((__Internal*)__Instance)->read_bytes;
            }

            set
            {
                ((__Internal*)__Instance)->read_bytes = value;
            }
        }

        /// <summary>Stream context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Pointer to a function that reads `count` bytes from the stream and writes them into `buf`.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="buf">Buffer to write into.</param>
        /// <param name="count">Number of bytes to read.</param>
        /// <param name="read">Number of bytes actually read.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that resets the stream.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <returns>Return code.</returns>
        /// <remarks>Can be NULL if the stream cannot be reset.</remarks>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr Reset
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->reset;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->reset = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Pointer to a function that releases any resource reserved by the stream.</para>
        /// <para>The provided function is invoked when{#uistream_deinit()} is called.</para>
        /// </summary>
        /// <param name="ctx">Stream context.</param>
        /// <returns>Return code.</returns>
        /// <remarks>Can be NULL if the stream does not need to release resources.</remarks>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Models an output stream.</summary>
    public unsafe partial class UOStream : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::cowl.UstreamRet state;
            internal ulong written_bytes;
            internal __IntPtr ctx;
            internal __IntPtr write;
            internal __IntPtr writef;
            internal __IntPtr flush;
            internal __IntPtr free;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UOStream@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UOStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UOStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UOStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UOStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UOStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UOStream(native.ToPointer(), skipVTables);
        }

        internal static UOStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UOStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UOStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UOStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UOStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UOStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UOStream()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UOStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UOStream(global::cowl.UOStream _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UOStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UOStream.__Internal*) __Instance) = *((global::cowl.UOStream.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Stream state.</summary>
        public global::cowl.UstreamRet State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Bytes written since the last `flush` call.</summary>
        public ulong WrittenBytes
        {
            get
            {
                return ((__Internal*)__Instance)->written_bytes;
            }

            set
            {
                ((__Internal*)__Instance)->written_bytes = value;
            }
        }

        /// <summary>Stream context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Pointer to a function that reads `count` bytes from `buf` and writes them into the stream.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="buf">Buffer to read from.</param>
        /// <param name="count">Number of bytes to write.</param>
        /// <param name="rcount">Number of bytes actually written.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr Write
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that flushes the stream, writing any buffered data.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <returns>Return code.</returns>
        /// <remarks>Can be NULL if the stream cannot be flushed.</remarks>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr Flush
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->flush;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Pointer to a function that releases any resource reserved by the stream.</para>
        /// <para>The provided function is invoked when{#uostream_deinit()} is called.</para>
        /// </summary>
        /// <param name="ctx">Stream context.</param>
        /// <returns>Return code.</returns>
        /// <remarks>Can be NULL if the stream does not need to release resources.</remarks>
        public global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ustream
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uistream@@YA?AUUIStream@@PEAXP6A?AW4ustream_ret@@00_KPEA_K@ZP6A?AW42@0@Z4@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Uistream(__IntPtr @return, __IntPtr ctx, __IntPtr read_func, __IntPtr reset_func, __IntPtr free_func);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamDeinit(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamReset(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamRead(__IntPtr stream, __IntPtr buf, ulong count, ulong* read);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_std", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UistreamStd();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromPath(__IntPtr stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromFile(__IntPtr stream, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromBuf(__IntPtr stream, __IntPtr buf, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_strbuf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromStrbuf(__IntPtr stream, __IntPtr buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromString(__IntPtr stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uistream_from_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UistreamFromUstring(__IntPtr stream, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamDeinit(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_flush", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamFlush(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWrite(__IntPtr stream, __IntPtr buf, ulong count, ulong* written);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_writef", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWritef(__IntPtr stream, ulong* written, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_write_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWriteString(__IntPtr stream, __IntPtr @string, ulong* written);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_write_time", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWriteTime(__IntPtr stream, __IntPtr time, ulong* written);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_write_time_interval", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWriteTimeInterval(__IntPtr stream, ulong interval, global::cowl.UtimeUnit unit, uint decimal_digits, ulong* written);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_write_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamWriteVersion(__IntPtr stream, __IntPtr version, ulong* written);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_std", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UostreamStd();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_stderr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UostreamStderr();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_null", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UostreamNull();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_to_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamToPath(__IntPtr stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_to_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamToFile(__IntPtr stream, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_to_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamToBuf(__IntPtr stream, __IntPtr buf, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_to_strbuf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamToStrbuf(__IntPtr stream, __IntPtr buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_to_multi", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamToMulti(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uostream_add_substream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet UostreamAddSubstream(__IntPtr stream, __IntPtr other);
        }

        /// <summary>Initializes an input stream.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="read_func">`read` function pointer.</param>
        /// <param name="reset_func">`reset` function pointer.</param>
        /// <param name="free_func">`free` function pointer.</param>
        /// <returns>Stream instance.</returns>
        public static global::cowl.UIStream Uistream(__IntPtr ctx, global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr read_func, global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr reset_func, global::cowl.Delegates.Func_cowl_ustream_ret___IntPtr free_func)
        {
            var __arg1 = read_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read_func);
            var __arg2 = reset_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(reset_func);
            var __arg3 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            var ___ret = new global::cowl.UIStream.__Internal();
            __Internal.Uistream(new IntPtr(&___ret), ctx, __arg1, __arg2, __arg3);
            return global::cowl.UIStream.__CreateInstance(___ret);
        }

        /// <summary>Deinitializes the stream, releasing any reserved resource.</summary>
        /// <param name="stream">Input stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamDeinit(global::cowl.UIStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamDeinit(__arg0);
            return ___ret;
        }

        /// <summary>Resets the stream.</summary>
        /// <param name="stream">Input stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamReset(global::cowl.UIStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamReset(__arg0);
            return ___ret;
        }

        /// <summary>Reads `count` bytes from the stream and writes them into `buf`.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="buf">Input buffer.</param>
        /// <param name="count">Maximum number of bytes to read.</param>
        /// <param name="read">Number of bytes read.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamRead(global::cowl.UIStream stream, __IntPtr buf, ulong count, ref ulong read)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            fixed (ulong* __read3 = &read)
            {
                var __arg3 = __read3;
                var ___ret = __Internal.UistreamRead(__arg0, buf, count, __arg3);
                return ___ret;
            }
        }

        /// <summary>Returns a stream that reads from the standard input.</summary>
        /// <returns>Standard input stream.</returns>
        public static global::cowl.UIStream UistreamStd()
        {
            var ___ret = __Internal.UistreamStd();
            var __result0 = global::cowl.UIStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initializes a stream that reads from the file at the specified path.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="path">Path to the file to read from.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromPath(global::cowl.UIStream stream, string path)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamFromPath(__arg0, path);
            return ___ret;
        }

        /// <summary>Initializes a stream that reads from the specified file.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="file">The input file.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromFile(global::cowl.UIStream stream, global::System.IntPtr file)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamFromFile(__arg0, file);
            return ___ret;
        }

        /// <summary>Initializes a stream that reads from the specified buffer.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="buf">The input buffer.</param>
        /// <param name="size">Size of the input buffer.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromBuf(global::cowl.UIStream stream, __IntPtr buf, ulong size)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamFromBuf(__arg0, buf, size);
            return ___ret;
        }

        /// <summary>Initializes a stream that reads from the specified string buffer.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="buf">String buffer.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromStrbuf(global::cowl.UIStream stream, global::cowl.UVec_char buf)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.UistreamFromStrbuf(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Initializes a stream that reads from the specified null-terminated string.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="string">String.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromString(global::cowl.UIStream stream, string @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UistreamFromString(__arg0, @string);
            return ___ret;
        }

        /// <summary>Initializes a stream that reads from the specified string.</summary>
        /// <param name="stream">Input stream.</param>
        /// <param name="string">String.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UistreamFromUstring(global::cowl.UIStream stream, global::cowl.UString @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.UistreamFromUstring(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Deinitializes the stream, releasing any reserved resource.</summary>
        /// <param name="stream">Output stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamDeinit(global::cowl.UOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamDeinit(__arg0);
            return ___ret;
        }

        /// <summary>Flushes the stream, writing any buffered data.</summary>
        /// <param name="stream">Output stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamFlush(global::cowl.UOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamFlush(__arg0);
            return ___ret;
        }

        /// <summary>Writes `count` bytes from `buf` into the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="buf">Buffer.</param>
        /// <param name="count">Number of bytes to write.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWrite(global::cowl.UOStream stream, __IntPtr buf, ulong count, ref ulong written)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            fixed (ulong* __written3 = &written)
            {
                var __arg3 = __written3;
                var ___ret = __Internal.UostreamWrite(__arg0, buf, count, __arg3);
                return ___ret;
            }
        }

        /// <summary>Writes a formatted string into the stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <param name="format">Format string.</param>
        /// <param name="...">Format arguments.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWritef(global::cowl.UOStream stream, ref ulong written, string format)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            fixed (ulong* __written1 = &written)
            {
                var __arg1 = __written1;
                var ___ret = __Internal.UostreamWritef(__arg0, __arg1, format);
                return ___ret;
            }
        }

        /// <summary>Writes a string into the stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="string">String.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWriteString(global::cowl.UOStream stream, global::cowl.UString @string, ref ulong written)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            fixed (ulong* __written2 = &written)
            {
                var __arg2 = __written2;
                var ___ret = __Internal.UostreamWriteString(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        /// <summary>Writes the specified date and time into the stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="time">Date and time.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWriteTime(global::cowl.UOStream stream, global::cowl.UTime time, ref ulong written)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = time is null ? __IntPtr.Zero : time.__Instance;
            fixed (ulong* __written2 = &written)
            {
                var __arg2 = __written2;
                var ___ret = __Internal.UostreamWriteTime(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        /// <summary>Writes the specified time interval into the stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="interval">Time interval.</param>
        /// <param name="unit">Time unit.</param>
        /// <param name="decimal_digits">Number of decimal digits to write.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWriteTimeInterval(global::cowl.UOStream stream, ulong interval, global::cowl.UtimeUnit unit, uint decimal_digits, ref ulong written)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            fixed (ulong* __written4 = &written)
            {
                var __arg4 = __written4;
                var ___ret = __Internal.UostreamWriteTimeInterval(__arg0, interval, unit, decimal_digits, __arg4);
                return ___ret;
            }
        }

        /// <summary>Writes the specified version into the stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="version">Version.</param>
        /// <param name="written">Number of bytes written.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamWriteVersion(global::cowl.UOStream stream, global::cowl.UVersion version, ref ulong written)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = version is null ? __IntPtr.Zero : version.__Instance;
            fixed (ulong* __written2 = &written)
            {
                var __arg2 = __written2;
                var ___ret = __Internal.UostreamWriteVersion(__arg0, __arg1, __arg2);
                return ___ret;
            }
        }

        /// <summary>Returns a stream that writes to the standard output.</summary>
        /// <returns>Standard output stream.</returns>
        public static global::cowl.UOStream UostreamStd()
        {
            var ___ret = __Internal.UostreamStd();
            var __result0 = global::cowl.UOStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a stream that writes to the standard error.</summary>
        /// <returns>Standard error stream.</returns>
        public static global::cowl.UOStream UostreamStderr()
        {
            var ___ret = __Internal.UostreamStderr();
            var __result0 = global::cowl.UOStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a stream that discards its output.</summary>
        /// <returns>Null output stream.</returns>
        public static global::cowl.UOStream UostreamNull()
        {
            var ___ret = __Internal.UostreamNull();
            var __result0 = global::cowl.UOStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initializes a stream that writes to the file at the specified path.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="path">Path to the file to write to.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamToPath(global::cowl.UOStream stream, string path)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamToPath(__arg0, path);
            return ___ret;
        }

        /// <summary>Initializes a stream that writes to the specified file.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="file">The output file.</param>
        /// <returns>Return code.</returns>
        /// <remarks>You are responsible for closing the file.</remarks>
        public static global::cowl.UstreamRet UostreamToFile(global::cowl.UOStream stream, global::System.IntPtr file)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamToFile(__arg0, file);
            return ___ret;
        }

        /// <summary>Initializes a stream that writes to the specified buffer.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="buf">The output buffer.</param>
        /// <param name="size">Size of the output buffer.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet UostreamToBuf(global::cowl.UOStream stream, __IntPtr buf, ulong size)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamToBuf(__arg0, buf, size);
            return ___ret;
        }

        /// <summary>Initializes a stream that writes to the specified string buffer.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="buf">The output buffer.</param>
        /// <returns>Return code.</returns>
        /// <remarks>
        /// <para>If `buf` is NULL, the stream will allocate a new string buffer and set it as its context.</para>
        /// <para>In this case, the string buffer will be deinitialized when calling</para>
        /// <para>{#uostream_deinit()}.</para>
        /// </remarks>
        public static global::cowl.UstreamRet UostreamToStrbuf(global::cowl.UOStream stream, global::cowl.UVec_char buf)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.UostreamToStrbuf(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Initializes a stream that writes to multiple substreams.</summary>
        /// <param name="stream">Output stream.</param>
        /// <returns>Return code.</returns>
        /// <remarks>
        /// <para>Multi-streams behave as follows:</para>
        /// <para>- In case of error of any of the substreams, only the first detected error code</para>
        /// <para>is returned. It is your responsibility to check the state of each individual</para>
        /// <para>substream if that is important for your use case.</para>
        /// <para>- The reported written bytes are the maximum bytes written by any of the underlying</para>
        /// <para>substreams.</para>
        /// <para>- Calling{#uostream_deinit()} deinitializes all substreams.</para>
        /// </remarks>
        public static global::cowl.UstreamRet UostreamToMulti(global::cowl.UOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UostreamToMulti(__arg0);
            return ___ret;
        }

        /// <summary>Adds a new output stream to the specified multi-stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="other">Stream to add.</param>
        /// <returns>Return code.</returns>
        /// <remarks>
        /// <para>Both streams must have been initialized beforehand, and `stream`</para>
        /// <para>must have been initialized via{#uostream_to_multi()}.</para>
        /// </remarks>
        public static global::cowl.UstreamRet UostreamAddSubstream(global::cowl.UOStream stream, global::cowl.UOStream other)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UostreamAddSubstream(__arg0, __arg1);
            return ___ret;
        }
    }

    public unsafe partial class utest
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utest_leak_start", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UtestLeakStart();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "utest_leak_end", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UtestLeakEnd();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "p_utest_leak_malloc_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PUtestLeakMallocImpl(ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fn, int line);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "p_utest_leak_calloc_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PUtestLeakCallocImpl(ulong num, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fn, int line);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "p_utest_leak_realloc_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr PUtestLeakReallocImpl(__IntPtr ptr, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fn, int line);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "p_utest_leak_free_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUtestLeakFreeImpl(__IntPtr ptr);
        }

        /// <summary>Start detection of memory leaks.</summary>
        /// <returns>True if detection started successfully, false otherwise.</returns>
        public static bool UtestLeakStart()
        {
            var ___ret = __Internal.UtestLeakStart();
            return ___ret;
        }

        /// <summary>Ends detection of memory leaks and prints detected leaks to the console.</summary>
        /// <returns>True if no leaks were detected, false otherwise.</returns>
        public static bool UtestLeakEnd()
        {
            var ___ret = __Internal.UtestLeakEnd();
            return ___ret;
        }

        /// <summary>@}</summary>
        public static __IntPtr PUtestLeakMallocImpl(ulong size, string file, string fn, int line)
        {
            var ___ret = __Internal.PUtestLeakMallocImpl(size, file, fn, line);
            return ___ret;
        }

        public static __IntPtr PUtestLeakCallocImpl(ulong num, ulong size, string file, string fn, int line)
        {
            var ___ret = __Internal.PUtestLeakCallocImpl(num, size, file, fn, line);
            return ___ret;
        }

        public static __IntPtr PUtestLeakReallocImpl(__IntPtr ptr, ulong size, string file, string fn, int line)
        {
            var ___ret = __Internal.PUtestLeakReallocImpl(ptr, size, file, fn, line);
            return ___ret;
        }

        public static void PUtestLeakFreeImpl(__IntPtr ptr)
        {
            __Internal.PUtestLeakFreeImpl(ptr);
        }
    }

    /// <summary>Placeholder for any</summary>
    /// <summary>Placeholder for any{#CowlAnnotValue}.</summary>
    /// <summary>Placeholder for any{#CowlAxiom}.</summary>
    /// <summary>Placeholder for any{#CowlClsExp}.</summary>
    /// <summary>Placeholder for any{#CowlDataPropExp}.</summary>
    /// <summary>Placeholder for any{#CowlDataRange}.</summary>
    /// <summary>Placeholder for any</summary>
    /// <summary>Placeholder for any{#CowlIndividual}.</summary>
    /// <summary>Placeholder for any{#CowlPrimitive}.</summary>
    /// <summary>Placeholder for any{#CowlObjPropExp}.</summary>
    /// <summary>Represents the type of</summary>
    public enum CowlPrimitiveType
    {
        /// <summary>- class.</summary>
        COWL_PT_CLASS = 0,
        /// <summary>- object property.</summary>
        COWL_PT_OBJ_PROP = 1,
        /// <summary>- data property.</summary>
        COWL_PT_DATA_PROP = 2,
        /// <summary>- annotation property.</summary>
        COWL_PT_ANNOT_PROP = 3,
        /// <summary>- named individual.</summary>
        COWL_PT_NAMED_IND = 4,
        /// <summary>- anonymous individual.</summary>
        COWL_PT_ANON_IND = 5,
        /// <summary>- datatype.</summary>
        COWL_PT_DATATYPE = 6,
        /// <summary>- IRI.</summary>
        COWL_PT_IRI = 7,
        /// <summary>Number of enum values.</summary>
        COWL_PT_COUNT = 8,
        /// <summary>First enum value.</summary>
        COWL_PT_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    /// <summary>Flags to control iteration over primitives</summary>
    /// <remarks>typedef UBit(N) CowlPrimitiveFlags;</remarks>
    public unsafe partial class cowl_primitive_flags
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_primitive_flags_from_type@@YAEW4CowlPrimitiveType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte CowlPrimitiveFlagsFromType(global::cowl.CowlPrimitiveType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_primitive_flags_has_type@@YA_NEW4CowlPrimitiveType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlPrimitiveFlagsHasType(byte flags, global::cowl.CowlPrimitiveType type);
        }

        /// <summary>Returns a bitmask with a bit set for the specified primitive type.</summary>
        /// <param name="type">Primitive type.</param>
        /// <returns>Flags.</returns>
        public static byte CowlPrimitiveFlagsFromType(global::cowl.CowlPrimitiveType type)
        {
            var ___ret = __Internal.CowlPrimitiveFlagsFromType(type);
            return ___ret;
        }

        /// <summary>Checks whether the specified type is included in the flags.</summary>
        /// <param name="flags">Primitive flags.</param>
        /// <param name="type">Primitive type.</param>
        /// <returns>True if the type is included in the flags, false otherwise.</returns>
        public static bool CowlPrimitiveFlagsHasType(byte flags, global::cowl.CowlPrimitiveType type)
        {
            var ___ret = __Internal.CowlPrimitiveFlagsHasType(flags, type);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>Wrapper around a function that gets called for every element matched by a query.</para>
    /// <para>The context provided while creating the iterator is passed to the `for_each` function</para>
    /// <para>each time it is called.</para>
    /// </summary>
    /// <remarks>
    /// <para>The iterator function returns athat can be used to control iteration: by returning</para>
    /// <para>true iteration proceeds to the next element, while returning false causes it to stop.</para>
    /// </remarks>
    /// <summary>Wrapper around a function called to filter objects according to user-defined criteria.</summary>
    /// <remarks>{#CowlIterator}</remarks>
    /// <summary>
    /// <para>Wrapper around a function that gets called for every element matched by a query.</para>
    /// <para>The context provided while creating the iterator is passed to the `for_each` function</para>
    /// <para>each time it is called.</para>
    /// </summary>
    /// <remarks>
    /// <para>The iterator function returns athat can be used to control iteration: by returning</para>
    /// <para>true iteration proceeds to the next element, while returning false causes it to stop.</para>
    /// </remarks>
    public unsafe partial class CowlIterator : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr ctx;
            internal __IntPtr for_each;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlIterator@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIterator> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIterator>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlIterator managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlIterator managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlIterator(native.ToPointer(), skipVTables);
        }

        internal static CowlIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlIterator)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlIterator __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlIterator(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlIterator(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlIterator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlIterator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlIterator.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlIterator(global::cowl.CowlIterator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlIterator.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlIterator.__Internal*) __Instance) = *((global::cowl.CowlIterator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The iterator context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Function called by the iterator for every element.</summary>
        public global::cowl.Delegates.Func_bool___IntPtr___IntPtr ForEach
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->for_each;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_bool___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_bool___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->for_each = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Wrapper around a function called to filter objects according to user-defined criteria.</summary>
    /// <remarks>{#CowlIterator}</remarks>
    public unsafe partial class CowlFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr ctx;
            internal __IntPtr filter;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFilter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFilter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlFilter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlFilter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlFilter(native.ToPointer(), skipVTables);
        }

        internal static CowlFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlFilter(global::cowl.CowlFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlFilter.__Internal*) __Instance) = *((global::cowl.CowlFilter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Filter function.</summary>
        public global::cowl.Delegates.Func_bool___IntPtr___IntPtr Filter
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->filter;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_bool___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_bool___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->filter = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class cowl_iterator
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_iterator_call@@YA_NPEBUCowlIterator@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIteratorCall(__IntPtr iter, __IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iterator_vec", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlIteratorVec(__IntPtr @return, __IntPtr vec, bool retain);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iterator_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlIteratorSet(__IntPtr @return, __IntPtr set, bool retain);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iterator_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlIteratorCount(__IntPtr @return, uint* count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iterator_contains", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlIteratorContains(__IntPtr @return, __IntPtr @object);
        }

        /// <summary>Call the iterator on a single object.</summary>
        /// <param name="iter">The iterator.</param>
        /// <param name="object">The object.</param>
        /// <returns>Return value of the iterator function.</returns>
        public static bool CowlIteratorCall(global::cowl.CowlIterator iter, __IntPtr @object)
        {
            var __arg0 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlIteratorCall(__arg0, @object);
            return ___ret;
        }

        /// <summary>Initializes an iterator that stores objects in the specified vector.</summary>
        /// <param name="vec">Vector.</param>
        /// <param name="retain">If true, elements are retained.</param>
        /// <returns>Initialized iterator.</returns>
        /// <remarks>
        /// <para>When using this iterator, iterator functions return false on error,</para>
        /// <para>e.g. when memory cannot be allocated.</para>
        /// </remarks>
        public static global::cowl.CowlIterator CowlIteratorVec(global::cowl.UVecCowlObjectPtr vec, bool retain)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.CowlIterator.__Internal();
            __Internal.CowlIteratorVec(new IntPtr(&___ret), __arg0, retain);
            return global::cowl.CowlIterator.__CreateInstance(___ret);
        }

        /// <summary>Initializes an iterator that stores objects in the specified set.</summary>
        /// <param name="set">Set.</param>
        /// <param name="retain">If true, elements are retained.</param>
        /// <returns>Initialized iterator.</returns>
        /// <remarks>
        /// <para>When using this iterator, iterator functions return false on error,</para>
        /// <para>e.g. when memory cannot be allocated.</para>
        /// </remarks>
        public static global::cowl.CowlIterator CowlIteratorSet(global::cowl.UHashCowlObjectTable set, bool retain)
        {
            var __arg0 = set is null ? __IntPtr.Zero : set.__Instance;
            var ___ret = new global::cowl.CowlIterator.__Internal();
            __Internal.CowlIteratorSet(new IntPtr(&___ret), __arg0, retain);
            return global::cowl.CowlIterator.__CreateInstance(___ret);
        }

        /// <summary>Initializes an iterator that counts the objects it iterates on.</summary>
        /// <param name="count">Object count.</param>
        /// <returns>Initialized iterator.</returns>
        public static global::cowl.CowlIterator CowlIteratorCount(ref uint count)
        {
            fixed (uint* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = new global::cowl.CowlIterator.__Internal();
                __Internal.CowlIteratorCount(new IntPtr(&___ret), __arg0);
                return global::cowl.CowlIterator.__CreateInstance(___ret);
            }
        }

        /// <summary>
        /// <para>Initializes an iterator that checks if any of the objects it iterates on</para>
        /// <para>is equal to the specified object.</para>
        /// </summary>
        /// <param name="object">The object to look for.</param>
        /// <returns>Initialized iterator.</returns>
        /// <remarks>When using this iterator, iterator functions return false if the element has been found.</remarks>
        public static global::cowl.CowlIterator CowlIteratorContains(__IntPtr @object)
        {
            var ___ret = new global::cowl.CowlIterator.__Internal();
            __Internal.CowlIteratorContains(new IntPtr(&___ret), @object);
            return global::cowl.CowlIterator.__CreateInstance(___ret);
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlObjectType
    {
        /// <summary>- String.</summary>
        COWL_OT_STRING = 0,
        /// <summary>- Vector.</summary>
        COWL_OT_VECTOR = 1,
        /// <summary>- Hash table.</summary>
        COWL_OT_TABLE = 2,
        /// <summary>- IRI.</summary>
        COWL_OT_IRI = 3,
        /// <summary>- Literal.</summary>
        COWL_OT_LITERAL = 4,
        /// <summary>- Facet restriction.</summary>
        COWL_OT_FACET_RESTR = 5,
        /// <summary>- Ontology.</summary>
        COWL_OT_ONTOLOGY = 6,
        /// <summary>- Ontology manager.</summary>
        COWL_OT_MANAGER = 7,
        /// <summary>- Symbol table.</summary>
        COWL_OT_SYM_TABLE = 8,
        /// <summary>- Ontology input stream.</summary>
        COWL_OT_ISTREAM = 9,
        /// <summary>- Ontology output stream.</summary>
        COWL_OT_OSTREAM = 10,
        /// <summary>- Annotation.</summary>
        COWL_OT_ANNOTATION = 11,
        /// <summary>- Annotation property.</summary>
        COWL_OT_ANNOT_PROP = 12,
        /// <summary>- Declaration.</summary>
        COWL_OT_A_DECL = 13,
        /// <summary>- Datatype definition.</summary>
        COWL_OT_A_DATATYPE_DEF = 14,
        /// <summary>- Subclass.</summary>
        COWL_OT_A_SUB_CLASS = 15,
        /// <summary>- Equivalent classes.</summary>
        COWL_OT_A_EQUIV_CLASSES = 16,
        /// <summary>- Disjoint classes.</summary>
        COWL_OT_A_DISJ_CLASSES = 17,
        /// <summary>- Disjoint union.</summary>
        COWL_OT_A_DISJ_UNION = 18,
        /// <summary>- Class assertion.</summary>
        COWL_OT_A_CLASS_ASSERT = 19,
        /// <summary>- Same individual.</summary>
        COWL_OT_A_SAME_IND = 20,
        /// <summary>- Different individuals.</summary>
        COWL_OT_A_DIFF_IND = 21,
        /// <summary>- Object property assertion.</summary>
        COWL_OT_A_OBJ_PROP_ASSERT = 22,
        /// <summary>- Negative object property assertion.</summary>
        COWL_OT_A_NEG_OBJ_PROP_ASSERT = 23,
        /// <summary>- Data property assertion.</summary>
        COWL_OT_A_DATA_PROP_ASSERT = 24,
        /// <summary>- Negative data property assertion.</summary>
        COWL_OT_A_NEG_DATA_PROP_ASSERT = 25,
        /// <summary>- Object subproperty.</summary>
        COWL_OT_A_SUB_OBJ_PROP = 26,
        /// <summary>- Inverse object properties.</summary>
        COWL_OT_A_INV_OBJ_PROP = 27,
        /// <summary>- Equivalent object properties.</summary>
        COWL_OT_A_EQUIV_OBJ_PROP = 28,
        /// <summary>- Disjoint object properties.</summary>
        COWL_OT_A_DISJ_OBJ_PROP = 29,
        /// <summary>- Functional object property.</summary>
        COWL_OT_A_FUNC_OBJ_PROP = 30,
        /// <summary>- Inverse functional object property.</summary>
        COWL_OT_A_INV_FUNC_OBJ_PROP = 31,
        /// <summary>- Symmetric object property.</summary>
        COWL_OT_A_SYMM_OBJ_PROP = 32,
        /// <summary>- Asymmetric object property.</summary>
        COWL_OT_A_ASYMM_OBJ_PROP = 33,
        /// <summary>- Transitive object property.</summary>
        COWL_OT_A_TRANS_OBJ_PROP = 34,
        /// <summary>- Reflexive object property.</summary>
        COWL_OT_A_REFL_OBJ_PROP = 35,
        /// <summary>- Irreflexive object property.</summary>
        COWL_OT_A_IRREFL_OBJ_PROP = 36,
        /// <summary>- Object property domain.</summary>
        COWL_OT_A_OBJ_PROP_DOMAIN = 37,
        /// <summary>- Object property range.</summary>
        COWL_OT_A_OBJ_PROP_RANGE = 38,
        /// <summary>- Data subproperty.</summary>
        COWL_OT_A_SUB_DATA_PROP = 39,
        /// <summary>- Equivalent data properties.</summary>
        COWL_OT_A_EQUIV_DATA_PROP = 40,
        /// <summary>- Disjoint data properties.</summary>
        COWL_OT_A_DISJ_DATA_PROP = 41,
        /// <summary>- Functional data property.</summary>
        COWL_OT_A_FUNC_DATA_PROP = 42,
        /// <summary>- Data property domain.</summary>
        COWL_OT_A_DATA_PROP_DOMAIN = 43,
        /// <summary>- Data property range.</summary>
        COWL_OT_A_DATA_PROP_RANGE = 44,
        /// <summary>- Has key.</summary>
        COWL_OT_A_HAS_KEY = 45,
        /// <summary>- Annotation assertion.</summary>
        COWL_OT_A_ANNOT_ASSERT = 46,
        /// <summary>- Annotation subproperty.</summary>
        COWL_OT_A_SUB_ANNOT_PROP = 47,
        /// <summary>- Annotation property domain.</summary>
        COWL_OT_A_ANNOT_PROP_DOMAIN = 48,
        /// <summary>- Annotation property range.</summary>
        COWL_OT_A_ANNOT_PROP_RANGE = 49,
        /// <summary>- class.</summary>
        COWL_OT_CE_CLASS = 50,
        /// <summary>- &quot;some values from&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_SOME = 51,
        /// <summary>- &quot;all values from&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_ALL = 52,
        /// <summary>- &quot;minimum cardinality&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_MIN_CARD = 53,
        /// <summary>- &quot;maximum cardinality&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_MAX_CARD = 54,
        /// <summary>- &quot;exact cardinality&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_EXACT_CARD = 55,
        /// <summary>- &quot;has value&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_HAS_VALUE = 56,
        /// <summary>- &quot;has self&quot; object property restriction.</summary>
        COWL_OT_CE_OBJ_HAS_SELF = 57,
        /// <summary>- &quot;some values from&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_SOME = 58,
        /// <summary>- &quot;all values from&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_ALL = 59,
        /// <summary>- &quot;min cardinality&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_MIN_CARD = 60,
        /// <summary>- &quot;max cardinality&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_MAX_CARD = 61,
        /// <summary>- &quot;exact cardinality&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_EXACT_CARD = 62,
        /// <summary>- &quot;has value&quot; data property restriction.</summary>
        COWL_OT_CE_DATA_HAS_VALUE = 63,
        /// <summary>- Intersection of class expressions.</summary>
        COWL_OT_CE_OBJ_INTERSECT = 64,
        /// <summary>- Union of class expressions.</summary>
        COWL_OT_CE_OBJ_UNION = 65,
        /// <summary>- Complement of a class expression.</summary>
        COWL_OT_CE_OBJ_COMPL = 66,
        /// <summary>- Enumeration of individuals.</summary>
        COWL_OT_CE_OBJ_ONE_OF = 67,
        /// <summary>- Data property.</summary>
        COWL_OT_DPE_DATA_PROP = 68,
        /// <summary>- Datatype.</summary>
        COWL_OT_DR_DATATYPE = 69,
        /// <summary>- Datatype restriction.</summary>
        COWL_OT_DR_DATATYPE_RESTR = 70,
        /// <summary>- Intersection of data ranges.</summary>
        COWL_OT_DR_DATA_INTERSECT = 71,
        /// <summary>- Union of data ranges.</summary>
        COWL_OT_DR_DATA_UNION = 72,
        /// <summary>- Complement of data ranges.</summary>
        COWL_OT_DR_DATA_COMPL = 73,
        /// <summary>- Enumeration of literals.</summary>
        COWL_OT_DR_DATA_ONE_OF = 74,
        /// <summary>- Anonymous individual.</summary>
        COWL_OT_I_ANONYMOUS = 75,
        /// <summary>- Named individual.</summary>
        COWL_OT_I_NAMED = 76,
        /// <summary>- Object property.</summary>
        COWL_OT_OPE_OBJ_PROP = 77,
        /// <summary>- Inverse object property.</summary>
        COWL_OT_OPE_INV_OBJ_PROP = 78,
        /// <summary>Number of enum values.</summary>
        COWL_OT_COUNT = 79,
        /// <summary>First enum value.</summary>
        COWL_OT_FIRST = 0,
        /// <summary>First axiom type.</summary>
        COWL_OT_FIRST_A = 13,
        /// <summary>Last axiom type.</summary>
        COWL_OT_LAST_A = 49,
        /// <summary>First class expression type.</summary>
        COWL_OT_FIRST_CE = 50,
        /// <summary>Last class expression type.</summary>
        COWL_OT_LAST_CE = 67,
        /// <summary>First object property expression type.</summary>
        COWL_OT_FIRST_OPE = 77,
        /// <summary>Last object property expression type.</summary>
        COWL_OT_LAST_OPE = 78,
        /// <summary>First individual type.</summary>
        COWL_OT_FIRST_I = 75,
        /// <summary>Last individual type.</summary>
        COWL_OT_LAST_I = 76,
        /// <summary>First data range type.</summary>
        COWL_OT_FIRST_DR = 69,
        /// <summary>Last data range type.</summary>
        COWL_OT_LAST_DR = 74
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class CowlString
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlString> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlString>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlString managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlString managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlString __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlString(native.ToPointer(), skipVTables);
        }

        internal static CowlString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlString)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlString __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlString(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlString(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_object_type
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_object_type_to_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlObjectTypeToUstring(__IntPtr @return, global::cowl.CowlObjectType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_object_type_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjectTypeToString(global::cowl.CowlObjectType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_object_type_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlObjectType CowlObjectTypeFromString(__IntPtr @string);
        }

        /// <summary>Returns a human-readable string representation of the specified object type.</summary>
        /// <param name="type">Object type.</param>
        /// <returns>String representation, or NULL on error.</returns>
        /// <remarks>You must not modify or free the returned string.</remarks>
        public static global::cowl.UString CowlObjectTypeToUstring(global::cowl.CowlObjectType type)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.CowlObjectTypeToUstring(new IntPtr(&___ret), type);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a human-readable string representation of the specified object type.</summary>
        /// <param name="type">Object type.</param>
        /// <returns>String representation, or NULL on error.</returns>
        public static global::cowl.CowlString CowlObjectTypeToString(global::cowl.CowlObjectType type)
        {
            var ___ret = __Internal.CowlObjectTypeToString(type);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the object type given its string representation.</summary>
        /// <param name="string">String representation.</param>
        /// <returns>Object type, or an invalid object type (&gt;=</returns>
        public static global::cowl.CowlObjectType CowlObjectTypeFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlObjectTypeFromString(__arg0);
            return ___ret;
        }
    }

    public unsafe partial class CowlIRI
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIRI> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIRI>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlIRI managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlIRI managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlIRI __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlIRI(native.ToPointer(), skipVTables);
        }

        internal static CowlIRI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlIRI)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlIRI __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlIRI(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlIRI(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlIRI(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlVector
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlVector> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlVector>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlVector managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlVector managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlVector __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlVector(native.ToPointer(), skipVTables);
        }

        internal static CowlVector __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlVector)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlVector __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlVector(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlVector(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_impl
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl(global::cowl.CowlObjectType type, __IntPtr[] fields, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_impl_annot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImplAnnot(global::cowl.CowlObjectType type, __IntPtr[] fields, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_1_opt@@YAPEAXW4CowlObjectType@@PEAX1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl1Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_1_annot@@YAPEAXW4CowlObjectType@@PEAXPEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl1Annot(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_1@@YAPEAXW4CowlObjectType@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl1(global::cowl.CowlObjectType type, __IntPtr f1);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_2_opt@@YAPEAXW4CowlObjectType@@PEAX11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl2Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_2_annot@@YAPEAXW4CowlObjectType@@PEAX1PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl2Annot(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_2@@YAPEAXW4CowlObjectType@@PEAX1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl2(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_3_opt@@YAPEAXW4CowlObjectType@@PEAX111@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl3Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_3_annot@@YAPEAXW4CowlObjectType@@PEAX11PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl3Annot(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_3@@YAPEAXW4CowlObjectType@@PEAX11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl3(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_impl_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImplUint(global::cowl.CowlObjectType type, __IntPtr[] fields, uint val, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_1_uint_opt@@YAPEAXW4CowlObjectType@@PEAXI1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl1UintOpt(global::cowl.CowlObjectType type, __IntPtr f1, uint val, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_1_uint@@YAPEAXW4CowlObjectType@@PEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl1Uint(global::cowl.CowlObjectType type, __IntPtr f1, uint val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_2_uint_opt@@YAPEAXW4CowlObjectType@@PEAX1I1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl2UintOpt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, uint val, __IntPtr opt);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_get_impl_2_uint@@YAPEAXW4CowlObjectType@@PEAX1I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetImpl2Uint(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, uint val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_entity_get_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlEntityGetImpl(global::cowl.CowlObjectType type, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_entity_from_string_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlEntityFromStringImpl(global::cowl.CowlObjectType type, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_release_all_impl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlReleaseAllImpl(__IntPtr* objects);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_fields", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr* CowlGetFields(__IntPtr @object, uint* count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_field_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlGetFieldCount(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_field", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetField(__IntPtr @object, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_has_opt_field", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlHasOptField(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_opt_field", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetOptField(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_uint_field", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlGetUintField(__IntPtr @object);
        }

        public static __IntPtr CowlGetImpl(global::cowl.CowlObjectType type, __IntPtr[] fields, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl(type, fields, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImplAnnot(global::cowl.CowlObjectType type, __IntPtr[] fields, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlGetImplAnnot(type, fields, __arg2);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl1Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl1Opt(type, f1, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl1Annot(global::cowl.CowlObjectType type, __IntPtr f1, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlGetImpl1Annot(type, f1, __arg2);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl1(global::cowl.CowlObjectType type, __IntPtr f1)
        {
            var ___ret = __Internal.CowlGetImpl1(type, f1);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl2Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl2Opt(type, f1, f2, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl2Annot(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, global::cowl.CowlVector annot)
        {
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlGetImpl2Annot(type, f1, f2, __arg3);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl2(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2)
        {
            var ___ret = __Internal.CowlGetImpl2(type, f1, f2);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl3Opt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl3Opt(type, f1, f2, f3, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl3Annot(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3, global::cowl.CowlVector annot)
        {
            var __arg4 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlGetImpl3Annot(type, f1, f2, f3, __arg4);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl3(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, __IntPtr f3)
        {
            var ___ret = __Internal.CowlGetImpl3(type, f1, f2, f3);
            return ___ret;
        }

        public static __IntPtr CowlGetImplUint(global::cowl.CowlObjectType type, __IntPtr[] fields, uint val, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImplUint(type, fields, val, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl1UintOpt(global::cowl.CowlObjectType type, __IntPtr f1, uint val, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl1UintOpt(type, f1, val, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl1Uint(global::cowl.CowlObjectType type, __IntPtr f1, uint val)
        {
            var ___ret = __Internal.CowlGetImpl1Uint(type, f1, val);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl2UintOpt(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, uint val, __IntPtr opt)
        {
            var ___ret = __Internal.CowlGetImpl2UintOpt(type, f1, f2, val, opt);
            return ___ret;
        }

        public static __IntPtr CowlGetImpl2Uint(global::cowl.CowlObjectType type, __IntPtr f1, __IntPtr f2, uint val)
        {
            var ___ret = __Internal.CowlGetImpl2Uint(type, f1, f2, val);
            return ___ret;
        }

        public static __IntPtr CowlEntityGetImpl(global::cowl.CowlObjectType type, global::cowl.CowlIRI iri)
        {
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlEntityGetImpl(type, __arg1);
            return ___ret;
        }

        public static __IntPtr CowlEntityFromStringImpl(global::cowl.CowlObjectType type, global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg1 = @string.__Instance;
            var ___ret = __Internal.CowlEntityFromStringImpl(type, __arg1);
            return ___ret;
        }

        public static void CowlReleaseAllImpl(__IntPtr* objects)
        {
            __Internal.CowlReleaseAllImpl(objects);
        }

        public static __IntPtr* CowlGetFields(__IntPtr @object, ref uint count)
        {
            fixed (uint* __count1 = &count)
            {
                var __arg1 = __count1;
                var ___ret = __Internal.CowlGetFields(@object, __arg1);
                return ___ret;
            }
        }

        public static uint CowlGetFieldCount(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetFieldCount(@object);
            return ___ret;
        }

        public static __IntPtr CowlGetField(__IntPtr @object, uint index)
        {
            var ___ret = __Internal.CowlGetField(@object, index);
            return ___ret;
        }

        public static bool CowlHasOptField(__IntPtr @object)
        {
            var ___ret = __Internal.CowlHasOptField(@object);
            return ___ret;
        }

        public static __IntPtr CowlGetOptField(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetOptField(@object);
            return ___ret;
        }

        public static uint CowlGetUintField(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetUintField(@object);
            return ___ret;
        }
    }

    public unsafe partial class CowlObject
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObject> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObject>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObject managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObject managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObject __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObject(native.ToPointer(), skipVTables);
        }

        internal static CowlObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObject)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObject __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObject(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObject(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_object
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_retain", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlRetain(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlRelease(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlObjectType CowlGetType(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_primitive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsPrimitive(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_entity", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsEntity(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_axiom", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsAxiom(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_cls_exp", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsClsExp(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_obj_prop_exp", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsObjPropExp(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_data_prop_exp", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsDataPropExp(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_individual", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsIndividual(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_data_range", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsDataRange(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetIri(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_has_iri", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlHasIri(__IntPtr @object, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_has_iri_string", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlHasIriString(__IntPtr @object, __IntPtr iri_str);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_ns", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetNs(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_rem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetRem(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_annot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetAnnot(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlToString(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_to_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlToUstring(__IntPtr @return, __IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_to_debug_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlToDebugString(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_to_debug_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlToDebugUstring(__IntPtr @return, __IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_equals", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlEquals(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_is_reserved", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIsReserved(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_hash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlHash(__IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_has_primitive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlHasPrimitive(__IntPtr @object, __IntPtr primitive);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iterate_primitives", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIteratePrimitives(__IntPtr @object, byte flags, __IntPtr iter);
        }

        /// <summary>Retains the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>Retained object.</returns>
        public static __IntPtr CowlRetain(__IntPtr @object)
        {
            var ___ret = __Internal.CowlRetain(@object);
            return ___ret;
        }

        /// <summary>Releases the specified object.</summary>
        /// <param name="object">The object.</param>
        public static void CowlRelease(__IntPtr @object)
        {
            __Internal.CowlRelease(@object);
        }

        /// <summary>Gets the type of the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlObjectType CowlGetType(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetType(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is a primitive.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is a primitive, false otherwise.</returns>
        public static bool CowlIsPrimitive(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsPrimitive(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is an entity.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is an entity, false otherwise.</returns>
        public static bool CowlIsEntity(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsEntity(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is an axiom.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is an axiom, false otherwise.</returns>
        public static bool CowlIsAxiom(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsAxiom(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is a class expression.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is a class expression, false otherwise.</returns>
        public static bool CowlIsClsExp(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsClsExp(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is an object property expression.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is an object property expression, false otherwise.</returns>
        public static bool CowlIsObjPropExp(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsObjPropExp(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is a data property expression.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is a data property expression, false otherwise.</returns>
        public static bool CowlIsDataPropExp(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsDataPropExp(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is an individual.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is an individual, false otherwise.</returns>
        public static bool CowlIsIndividual(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsIndividual(@object);
            return ___ret;
        }

        /// <summary>Checks whether the specified object is a data range.</summary>
        /// <param name="object">The object</param>
        /// <returns>True if the object is a data range, false otherwise.</returns>
        public static bool CowlIsDataRange(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsDataRange(@object);
            return ___ret;
        }

        /// <summary>Returns the IRI of the object, if it is identified by one.</summary>
        /// <param name="object">The object.</param>
        /// <returns>IRI or NULL.</returns>
        public static global::cowl.CowlIRI CowlGetIri(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetIri(@object);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Checks if the object has the specified IRI.</summary>
        /// <param name="object">The object.</param>
        /// <param name="iri">The IRI.</param>
        /// <returns>True if the object has the specified IRI, false otherwise.</returns>
        public static bool CowlHasIri(__IntPtr @object, global::cowl.CowlIRI iri)
        {
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlHasIri(@object, __arg1);
            return ___ret;
        }

        /// <summary>Checks if the object has an IRI that matches the specified string.</summary>
        /// <param name="object">The object.</param>
        /// <param name="iri_str">IRI string.</param>
        /// <returns>True if the object has an IRI that matches the string, false otherwise.</returns>
        public static bool CowlHasIriString(__IntPtr @object, global::cowl.UString iri_str)
        {
            if (ReferenceEquals(iri_str, null))
                throw new global::System.ArgumentNullException("iri_str", "Cannot be null because it is passed by value.");
            var __arg1 = iri_str.__Instance;
            var ___ret = __Internal.CowlHasIriString(@object, __arg1);
            return ___ret;
        }

        /// <summary>Returns the namespace of the object's IRI.</summary>
        /// <param name="object">The object.</param>
        /// <returns>IRI namespace or NULL.</returns>
        public static global::cowl.CowlString CowlGetNs(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetNs(@object);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the remainder of the object's IRI.</summary>
        /// <param name="object">The object.</param>
        /// <returns>IRI remainder or NULL.</returns>
        public static global::cowl.CowlString CowlGetRem(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetRem(@object);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the object's annotations.</summary>
        /// <param name="object">The object.</param>
        /// <returns>The annotations, or NULL if the object has no annotations.</returns>
        public static global::cowl.CowlVector CowlGetAnnot(__IntPtr @object)
        {
            var ___ret = __Internal.CowlGetAnnot(@object);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the string representation of the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>String representation, or NULL on error.</returns>
        public static global::cowl.CowlString CowlToString(__IntPtr @object)
        {
            var ___ret = __Internal.CowlToString(@object);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the string representation of the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>String representation, or</returns>
        public static global::cowl.UString CowlToUstring(__IntPtr @object)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.CowlToUstring(new IntPtr(&___ret), @object);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a debug string representation of the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>String representation, or NULL on error.</returns>
        /// <remarks>
        /// <para>The debug string includes internal details such as the object's address,</para>
        /// <para>type and reference count.</para>
        /// </remarks>
        public static global::cowl.CowlString CowlToDebugString(__IntPtr @object)
        {
            var ___ret = __Internal.CowlToDebugString(@object);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a debug string representation of the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <returns>String representation, or</returns>
        /// <remarks>
        /// <para>The debug string includes internal details such as the object's address,</para>
        /// <para>type and reference count.</para>
        /// </remarks>
        public static global::cowl.UString CowlToDebugUstring(__IntPtr @object)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.CowlToDebugUstring(new IntPtr(&___ret), @object);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Equality function.</summary>
        /// <param name="lhs">LHS of the equality relation.</param>
        /// <param name="rhs">RHS of the equality relation.</param>
        /// <returns>True if the equality relation holds, false otherwise.</returns>
        public static bool CowlEquals(__IntPtr lhs, __IntPtr rhs)
        {
            var ___ret = __Internal.CowlEquals(lhs, rhs);
            return ___ret;
        }

        /// <summary>Checks whether the object is reserved, i.e. if its IRI is in the reserved vocabulary.</summary>
        /// <param name="object">The object.</param>
        /// <returns>True if the object is reserved, false otherwise.</returns>
        public static bool CowlIsReserved(__IntPtr @object)
        {
            var ___ret = __Internal.CowlIsReserved(@object);
            return ___ret;
        }

        /// <summary>Hash function.</summary>
        /// <param name="object">The object.</param>
        /// <returns>The hash value.</returns>
        public static uint CowlHash(__IntPtr @object)
        {
            var ___ret = __Internal.CowlHash(@object);
            return ___ret;
        }

        /// <summary>Checks whether the object references the specified primitive.</summary>
        /// <param name="object">The object.</param>
        /// <param name="primitive">The primitive.</param>
        /// <returns>True if the object references the primitive, false otherwise.</returns>
        public static bool CowlHasPrimitive(__IntPtr @object, __IntPtr primitive)
        {
            var ___ret = __Internal.CowlHasPrimitive(@object, primitive);
            return ___ret;
        }

        /// <summary>Iterates over the primitives referenced by the specified object.</summary>
        /// <param name="object">The object.</param>
        /// <param name="flags">Iteration flags.</param>
        /// <param name="iter">The iterator.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlIteratePrimitives(__IntPtr @object, byte flags, global::cowl.CowlIterator iter)
        {
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlIteratePrimitives(@object, flags, __arg2);
            return ___ret;
        }
    }

    public unsafe partial class CowlAnnotProp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotProp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotProp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotProp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotProp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotProp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotProp(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotProp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotProp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotProp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotProp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotProp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotProp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlAnnotValue
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotValue> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotValue>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotValue managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotValue managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotValue(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotValue)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotValue(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlAnnotAssertAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotAssertAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotAssertAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotAssertAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotAssertAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotAssertAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotAssertAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotAssertAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotAssertAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotAssertAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotAssertAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotAssertAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotAssertAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_annot_assert_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_assert_axiom@@YAPEAUCowlAnnotAssertAxiom@@PEAUCowlAnnotProp@@PEAX1PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotAssertAxiom(__IntPtr prop, __IntPtr subject, __IntPtr value, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_assert_axiom_get_prop@@YAPEAUCowlAnnotProp@@PEAUCowlAnnotAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotAssertAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_assert_axiom_get_subject@@YAPEAUCowlAnnotValue@@PEAUCowlAnnotAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotAssertAxiomGetSubject(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_assert_axiom_get_value@@YAPEAUCowlAnnotValue@@PEAUCowlAnnotAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotAssertAxiomGetValue(__IntPtr axiom);
        }

        /// <summary>Returns an annotation assertion axiom.</summary>
        /// <param name="prop">The annotation property.</param>
        /// <param name="subject">The annotation subject.</param>
        /// <param name="value">The annotation value.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlAnnotAssertAxiom CowlAnnotAssertAxiom(global::cowl.CowlAnnotProp prop, __IntPtr subject, __IntPtr value, global::cowl.CowlVector annot)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotAssertAxiom(__arg0, subject, value, __arg3);
            var __result0 = global::cowl.CowlAnnotAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotation property.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotAssertAxiomGetProp(global::cowl.CowlAnnotAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotAssertAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation subject.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotation subject.</returns>
        /// <remarks>The annotation subject can only be an anonymous individual or an IRI.</remarks>
        public static global::cowl.CowlAnnotValue CowlAnnotAssertAxiomGetSubject(global::cowl.CowlAnnotAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotAssertAxiomGetSubject(__arg0);
            var __result0 = global::cowl.CowlAnnotValue.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation value.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotation value.</returns>
        public static global::cowl.CowlAnnotValue CowlAnnotAssertAxiomGetValue(global::cowl.CowlAnnotAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotAssertAxiomGetValue(__arg0);
            var __result0 = global::cowl.CowlAnnotValue.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlEntityType
    {
        /// <summary>- class.</summary>
        COWL_ET_CLASS = 0,
        /// <summary>- object property.</summary>
        COWL_ET_OBJ_PROP = 1,
        /// <summary>- data property.</summary>
        COWL_ET_DATA_PROP = 2,
        /// <summary>- annotation property.</summary>
        COWL_ET_ANNOT_PROP = 3,
        /// <summary>- named individual.</summary>
        COWL_ET_NAMED_IND = 4,
        /// <summary>- datatype.</summary>
        COWL_ET_DATATYPE = 5,
        /// <summary>Number of enum values.</summary>
        COWL_ET_COUNT = 6,
        /// <summary>First enum value.</summary>
        COWL_ET_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class CowlEntity
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlEntity> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlEntity>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlEntity managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlEntity managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlEntity __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlEntity(native.ToPointer(), skipVTables);
        }

        internal static CowlEntity __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlEntity)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlEntity __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlEntity(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlEntity(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlEntity(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_entity
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_entity_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlEntityType CowlEntityGetType(__IntPtr entity);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_entity_get_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlEntityGetIri(__IntPtr entity);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_entity_is_reserved", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlEntityIsReserved(__IntPtr entity);
        }

        /// <summary>Gets the type of the entity.</summary>
        /// <param name="entity">The entity.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlEntityType CowlEntityGetType(__IntPtr entity)
        {
            var ___ret = __Internal.CowlEntityGetType(entity);
            return ___ret;
        }

        /// <summary>Gets the IRI of the entity.</summary>
        /// <param name="entity">The entity.</param>
        /// <returns>The IRI.</returns>
        public static global::cowl.CowlIRI CowlEntityGetIri(__IntPtr entity)
        {
            var ___ret = __Internal.CowlEntityGetIri(entity);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Checks whether the entity is reserved, i.e. if its IRI is in the reserved vocabulary.</summary>
        /// <param name="entity">The entity.</param>
        /// <returns>True if the entity is reserved, false otherwise.</returns>
        public static bool CowlEntityIsReserved(__IntPtr entity)
        {
            var ___ret = __Internal.CowlEntityIsReserved(entity);
            return ___ret;
        }
    }

    public unsafe partial class cowl_annot_prop
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop@@YAPEAUCowlAnnotProp@@PEAUCowlIRI@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotProp(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_from_string@@YAPEAUCowlAnnotProp@@UUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_get_iri@@YAPEAUCowlIRI@@PEAUCowlAnnotProp@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropGetIri(__IntPtr prop);
        }

        /// <summary>Returns an annotation property.</summary>
        /// <param name="iri">IRI of the property.</param>
        /// <returns>Annotation property, or NULL on error.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotProp(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlAnnotProp(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an annotation property given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Annotation property, or NULL on error.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotPropFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlAnnotPropFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the specified annotation property.</summary>
        /// <param name="prop">The annotation property.</param>
        /// <returns>IRI of the annotation property.</returns>
        public static global::cowl.CowlIRI CowlAnnotPropGetIri(global::cowl.CowlAnnotProp prop)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var ___ret = __Internal.CowlAnnotPropGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlAnnotPropDomainAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotPropDomainAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotPropDomainAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotPropDomainAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotPropDomainAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotPropDomainAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotPropDomainAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotPropDomainAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotPropDomainAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotPropDomainAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotPropDomainAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotPropDomainAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotPropDomainAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_annot_prop_domain_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_domain_axiom@@YAPEAUCowlAnnotPropDomainAxiom@@PEAUCowlAnnotProp@@PEAUCowlIRI@@PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropDomainAxiom(__IntPtr prop, __IntPtr domain, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_domain_axiom_get_prop@@YAPEAUCowlAnnotProp@@PEAUCowlAnnotPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropDomainAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_domain_axiom_get_domain@@YAPEAUCowlIRI@@PEAUCowlAnnotPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropDomainAxiomGetDomain(__IntPtr axiom);
        }

        /// <summary>Returns an annotation property domain axiom.</summary>
        /// <param name="prop">The annotation property.</param>
        /// <param name="domain">Domain of the annotation property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlAnnotPropDomainAxiom CowlAnnotPropDomainAxiom(global::cowl.CowlAnnotProp prop, global::cowl.CowlIRI domain, global::cowl.CowlVector annot)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var __arg1 = domain is null ? __IntPtr.Zero : domain.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotPropDomainAxiom(__arg0, __arg1, __arg2);
            var __result0 = global::cowl.CowlAnnotPropDomainAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotation property.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotPropDomainAxiomGetProp(global::cowl.CowlAnnotPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotPropDomainAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the domain of the annotation property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Domain of the annotation property.</returns>
        public static global::cowl.CowlIRI CowlAnnotPropDomainAxiomGetDomain(global::cowl.CowlAnnotPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotPropDomainAxiomGetDomain(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlAnnotPropRangeAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotPropRangeAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotPropRangeAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotPropRangeAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotPropRangeAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotPropRangeAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotPropRangeAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotPropRangeAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotPropRangeAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotPropRangeAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotPropRangeAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotPropRangeAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotPropRangeAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_annot_prop_range_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_range_axiom@@YAPEAUCowlAnnotPropRangeAxiom@@PEAUCowlAnnotProp@@PEAUCowlIRI@@PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropRangeAxiom(__IntPtr prop, __IntPtr range, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_range_axiom_get_prop@@YAPEAUCowlAnnotProp@@PEAUCowlAnnotPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropRangeAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annot_prop_range_axiom_get_range@@YAPEAUCowlIRI@@PEAUCowlAnnotPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotPropRangeAxiomGetRange(__IntPtr axiom);
        }

        /// <summary>Returns an annotation property range axiom.</summary>
        /// <param name="prop">The annotation property.</param>
        /// <param name="range">Range of the annotation property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlAnnotPropRangeAxiom CowlAnnotPropRangeAxiom(global::cowl.CowlAnnotProp prop, global::cowl.CowlIRI range, global::cowl.CowlVector annot)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var __arg1 = range is null ? __IntPtr.Zero : range.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotPropRangeAxiom(__arg0, __arg1, __arg2);
            var __result0 = global::cowl.CowlAnnotPropRangeAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotation property.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotPropRangeAxiomGetProp(global::cowl.CowlAnnotPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotPropRangeAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the annotation property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Range of the annotation property.</returns>
        public static global::cowl.CowlIRI CowlAnnotPropRangeAxiomGetRange(global::cowl.CowlAnnotPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlAnnotPropRangeAxiomGetRange(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlAnnotValueType
    {
        /// <summary>- IRI.</summary>
        COWL_AVT_IRI = 0,
        /// <summary>- Literal.</summary>
        COWL_AVT_LITERAL = 1,
        /// <summary>- Anonymous individual.</summary>
        COWL_AVT_ANON_IND = 2,
        /// <summary>Number of enum values.</summary>
        COWL_AVT_COUNT = 3,
        /// <summary>First enum value.</summary>
        COWL_AVT_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class cowl_annot_value
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_annot_value_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlAnnotValueType CowlAnnotValueGetType(__IntPtr value);
        }

        /// <summary>Gets the type of the specified annotation value.</summary>
        /// <param name="value">The annotation value.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlAnnotValueType CowlAnnotValueGetType(__IntPtr value)
        {
            var ___ret = __Internal.CowlAnnotValueGetType(value);
            return ___ret;
        }
    }

    public unsafe partial class CowlAnnotation
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotation> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnnotation>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnnotation managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnnotation managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnnotation __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnnotation(native.ToPointer(), skipVTables);
        }

        internal static CowlAnnotation __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnnotation)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnnotation __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnnotation(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnnotation(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnnotation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_annotation
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annotation@@YAPEAUCowlAnnotation@@PEAUCowlAnnotProp@@PEAXPEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotation(__IntPtr prop, __IntPtr value, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annotation_get_prop@@YAPEAUCowlAnnotProp@@PEAUCowlAnnotation@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotationGetProp(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annotation_get_value@@YAPEAUCowlAnnotValue@@PEAUCowlAnnotation@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotationGetValue(__IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_annotation_get_annot@@YAPEAUCowlVector@@PEAUCowlAnnotation@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnnotationGetAnnot(__IntPtr annot);
        }

        /// <summary>Returns an annotation.</summary>
        /// <param name="prop">The annotation property.</param>
        /// <param name="value">The annotation value.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Annotation, or NULL on error.</returns>
        public static global::cowl.CowlAnnotation CowlAnnotation(global::cowl.CowlAnnotProp prop, __IntPtr value, global::cowl.CowlVector annot)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotation(__arg0, value, __arg2);
            var __result0 = global::cowl.CowlAnnotation.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation property.</summary>
        /// <param name="annot">The annotation.</param>
        /// <returns>The annotation property.</returns>
        public static global::cowl.CowlAnnotProp CowlAnnotationGetProp(global::cowl.CowlAnnotation annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotationGetProp(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotation value.</summary>
        /// <param name="annot">The annotation.</param>
        /// <returns>The annotation value.</returns>
        public static global::cowl.CowlAnnotValue CowlAnnotationGetValue(global::cowl.CowlAnnotation annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotationGetValue(__arg0);
            var __result0 = global::cowl.CowlAnnotValue.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the annotations of the specified annotation.</summary>
        /// <param name="annot">The annotation.</param>
        /// <returns>The annotations, or NULL of the annotation has no annotations.</returns>
        public static global::cowl.CowlVector CowlAnnotationGetAnnot(global::cowl.CowlAnnotation annot)
        {
            var __arg0 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlAnnotationGetAnnot(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlPrimitive
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlPrimitive> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlPrimitive>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlPrimitive managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlPrimitive managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlPrimitive __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlPrimitive(native.ToPointer(), skipVTables);
        }

        internal static CowlPrimitive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlPrimitive)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlPrimitive __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlPrimitive(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlPrimitive(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlPrimitive(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_primitive
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_primitive_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlPrimitiveType CowlPrimitiveGetType(__IntPtr primitive);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_primitive_is_entity@@YA_NPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlPrimitiveIsEntity(__IntPtr primitive);
        }

        /// <summary>Gets the type of the primitive.</summary>
        /// <param name="primitive">The primitive.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlPrimitiveType CowlPrimitiveGetType(__IntPtr primitive)
        {
            var ___ret = __Internal.CowlPrimitiveGetType(primitive);
            return ___ret;
        }

        /// <summary>Checks whether the primitive is an entity.</summary>
        /// <param name="primitive">The primitive.</param>
        /// <returns>True if the primitive is an entity,</returns>
        public static bool CowlPrimitiveIsEntity(__IntPtr primitive)
        {
            var ___ret = __Internal.CowlPrimitiveIsEntity(primitive);
            return ___ret;
        }
    }

    public unsafe partial class CowlAnonInd
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnonInd> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAnonInd>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAnonInd managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAnonInd managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAnonInd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAnonInd(native.ToPointer(), skipVTables);
        }

        internal static CowlAnonInd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAnonInd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAnonInd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAnonInd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAnonInd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAnonInd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_anon_ind
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_anon_ind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnonInd(__IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_anon_ind_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnonIndFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_anon_ind_get_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAnonIndGetId(__IntPtr ind);
        }

        /// <summary>Returns an anonymous individual.</summary>
        /// <param name="id">Anonymous individual identifier.</param>
        /// <returns>Anonymous individual, or NULL on error.</returns>
        /// <remarks>By passing NULL as the identifier, a new identifier is randomly generated.</remarks>
        public static global::cowl.CowlAnonInd CowlAnonInd(global::cowl.CowlString id)
        {
            var __arg0 = id is null ? __IntPtr.Zero : id.__Instance;
            var ___ret = __Internal.CowlAnonInd(__arg0);
            var __result0 = global::cowl.CowlAnonInd.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an anonymous individual given the string representation of its identifier.</summary>
        /// <param name="string">Anonymous individual identifier.</param>
        /// <returns>Anonymous individual, or NULL on error.</returns>
        public static global::cowl.CowlAnonInd CowlAnonIndFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlAnonIndFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlAnonInd.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the node ID of the specified anonymous individual.</summary>
        /// <param name="ind">The anonymous individual.</param>
        /// <returns>Node ID.</returns>
        public static global::cowl.CowlString CowlAnonIndGetId(global::cowl.CowlAnonInd ind)
        {
            var __arg0 = ind is null ? __IntPtr.Zero : ind.__Instance;
            var ___ret = __Internal.CowlAnonIndGetId(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlAxiomType
    {
        /// <summary>- Declaration.</summary>
        COWL_AT_DECL = 0,
        /// <summary>- Datatype definition.</summary>
        COWL_AT_DATATYPE_DEF = 1,
        /// <summary>- Subclass.</summary>
        COWL_AT_SUB_CLASS = 2,
        /// <summary>- Equivalent classes.</summary>
        COWL_AT_EQUIV_CLASSES = 3,
        /// <summary>- Disjoint classes.</summary>
        COWL_AT_DISJ_CLASSES = 4,
        /// <summary>- Disjoint union.</summary>
        COWL_AT_DISJ_UNION = 5,
        /// <summary>- Class assertion.</summary>
        COWL_AT_CLASS_ASSERT = 6,
        /// <summary>- Same individual.</summary>
        COWL_AT_SAME_IND = 7,
        /// <summary>- Different individuals.</summary>
        COWL_AT_DIFF_IND = 8,
        /// <summary>- Object property assertion.</summary>
        COWL_AT_OBJ_PROP_ASSERT = 9,
        /// <summary>- Negative object property assertion.</summary>
        COWL_AT_NEG_OBJ_PROP_ASSERT = 10,
        /// <summary>- Data property assertion.</summary>
        COWL_AT_DATA_PROP_ASSERT = 11,
        /// <summary>- Negative data property assertion.</summary>
        COWL_AT_NEG_DATA_PROP_ASSERT = 12,
        /// <summary>- Object subproperty.</summary>
        COWL_AT_SUB_OBJ_PROP = 13,
        /// <summary>- Inverse object properties.</summary>
        COWL_AT_INV_OBJ_PROP = 14,
        /// <summary>- Equivalent object properties.</summary>
        COWL_AT_EQUIV_OBJ_PROP = 15,
        /// <summary>- Disjoint object properties.</summary>
        COWL_AT_DISJ_OBJ_PROP = 16,
        /// <summary>- Functional object property.</summary>
        COWL_AT_FUNC_OBJ_PROP = 17,
        /// <summary>- Inverse functional object property.</summary>
        COWL_AT_INV_FUNC_OBJ_PROP = 18,
        /// <summary>- Symmetric object property.</summary>
        COWL_AT_SYMM_OBJ_PROP = 19,
        /// <summary>- Asymmetric object property.</summary>
        COWL_AT_ASYMM_OBJ_PROP = 20,
        /// <summary>- Transitive object property.</summary>
        COWL_AT_TRANS_OBJ_PROP = 21,
        /// <summary>- Reflexive object property.</summary>
        COWL_AT_REFL_OBJ_PROP = 22,
        /// <summary>- Irreflexive object property.</summary>
        COWL_AT_IRREFL_OBJ_PROP = 23,
        /// <summary>- Object property domain.</summary>
        COWL_AT_OBJ_PROP_DOMAIN = 24,
        /// <summary>- Object property range.</summary>
        COWL_AT_OBJ_PROP_RANGE = 25,
        /// <summary>- Data subproperty.</summary>
        COWL_AT_SUB_DATA_PROP = 26,
        /// <summary>- Equivalent data properties.</summary>
        COWL_AT_EQUIV_DATA_PROP = 27,
        /// <summary>- Disjoint data properties.</summary>
        COWL_AT_DISJ_DATA_PROP = 28,
        /// <summary>- Functional data property.</summary>
        COWL_AT_FUNC_DATA_PROP = 29,
        /// <summary>- Data property domain.</summary>
        COWL_AT_DATA_PROP_DOMAIN = 30,
        /// <summary>- Data property range.</summary>
        COWL_AT_DATA_PROP_RANGE = 31,
        /// <summary>- Has key.</summary>
        COWL_AT_HAS_KEY = 32,
        /// <summary>- Annotation assertion.</summary>
        COWL_AT_ANNOT_ASSERT = 33,
        /// <summary>- Annotation subproperty.</summary>
        COWL_AT_SUB_ANNOT_PROP = 34,
        /// <summary>- Annotation property domain.</summary>
        COWL_AT_ANNOT_PROP_DOMAIN = 35,
        /// <summary>- Annotation property range.</summary>
        COWL_AT_ANNOT_PROP_RANGE = 36,
        /// <summary>Number of enum values.</summary>
        COWL_AT_COUNT = 37,
        /// <summary>First enum value.</summary>
        COWL_AT_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    /// <summary>Position of a component in an OWL construct.</summary>
    /// <remarks>typedef UBit(N) CowlPosition;</remarks>
    public unsafe partial class CowlAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_get_type@@YA?AW4CowlAxiomType@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlAxiomType CowlAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_get_annot@@YAPEAUCowlVector@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlAxiomGetAnnot(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_axiom_has_operand", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomHasOperand(__IntPtr axiom, __IntPtr operand, byte position);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_axiom_has_operand_with_iri", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomHasOperandWithIri(__IntPtr axiom, __IntPtr iri, byte position);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_axiom_iterate_operands", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomIterateOperands(__IntPtr axiom, byte position, __IntPtr iter);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_axiom_has_primitive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomHasPrimitive(__IntPtr axiom, __IntPtr primitive, byte position);
        }

        /// <summary>Gets the type of the specified axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Axiom type.</returns>
        public static global::cowl.CowlAxiomType CowlAxiomGetType(__IntPtr axiom)
        {
            var ___ret = __Internal.CowlAxiomGetType(axiom);
            return ___ret;
        }

        /// <summary>Gets the annotations of the specified axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The annotations, or NULL if the axiom has no annotations.</returns>
        public static global::cowl.CowlVector CowlAxiomGetAnnot(__IntPtr axiom)
        {
            var ___ret = __Internal.CowlAxiomGetAnnot(axiom);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Checks if the axiom has the specified operand.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <param name="operand">The operand.</param>
        /// <param name="position">Position where the operand should appear.</param>
        /// <returns>True if the axiom has the specified operand, false otherwise.</returns>
        public static bool CowlAxiomHasOperand(__IntPtr axiom, __IntPtr operand, byte position)
        {
            var ___ret = __Internal.CowlAxiomHasOperand(axiom, operand, position);
            return ___ret;
        }

        /// <summary>Checks if the axiom has an operand with the specified IRI.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <param name="iri">The IRI.</param>
        /// <param name="position">Position where the operand should appear.</param>
        /// <returns>True if the axiom has an operand with the specified IRI, false otherwise.</returns>
        public static bool CowlAxiomHasOperandWithIri(__IntPtr axiom, global::cowl.CowlIRI iri, byte position)
        {
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlAxiomHasOperandWithIri(axiom, __arg1, position);
            return ___ret;
        }

        /// <summary>Iterates over the operands of the specified axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <param name="position">Position of the desired operands.</param>
        /// <param name="iter">The iterator.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlAxiomIterateOperands(__IntPtr axiom, byte position, global::cowl.CowlIterator iter)
        {
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlAxiomIterateOperands(axiom, position, __arg2);
            return ___ret;
        }

        /// <summary>Checks whether the axiom references the specified primitive.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <param name="primitive">The primitive.</param>
        /// <param name="position">Position of the desired primitive.</param>
        /// <returns>True if the axiom references the primitive, false otherwise.</returns>
        public static bool CowlAxiomHasPrimitive(__IntPtr axiom, __IntPtr primitive, byte position)
        {
            var ___ret = __Internal.CowlAxiomHasPrimitive(axiom, primitive, position);
            return ___ret;
        }
    }

    /// <summary>Flags to control iteration over axioms.</summary>
    /// <remarks>typedef UBit(N) CowlAxiomFlags;</remarks>
    public unsafe partial class cowl_axiom_flags
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_flags_from_type@@YA_KW4CowlAxiomType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong CowlAxiomFlagsFromType(global::cowl.CowlAxiomType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_flags_has_type@@YA_N_KW4CowlAxiomType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomFlagsHasType(ulong flags, global::cowl.CowlAxiomType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_flags_has_all_types@@YA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomFlagsHasAllTypes(ulong flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_flags_has_no_types@@YA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlAxiomFlagsHasNoTypes(ulong flags);
        }

        /// <summary>Returns a bitmask with a bit set for the specified axiom type.</summary>
        /// <param name="type">Axiom type.</param>
        /// <returns>Flags.</returns>
        public static ulong CowlAxiomFlagsFromType(global::cowl.CowlAxiomType type)
        {
            var ___ret = __Internal.CowlAxiomFlagsFromType(type);
            return ___ret;
        }

        /// <summary>Checks whether the specified type is included in the flags.</summary>
        /// <param name="flags">Axiom flags.</param>
        /// <param name="type">Axiom type.</param>
        /// <returns>True if the type is included in the flags, false otherwise.</returns>
        public static bool CowlAxiomFlagsHasType(ulong flags, global::cowl.CowlAxiomType type)
        {
            var ___ret = __Internal.CowlAxiomFlagsHasType(flags, type);
            return ___ret;
        }

        /// <summary>Checks whether the flags match all axiom types.</summary>
        /// <param name="flags">Axiom flags.</param>
        /// <returns>True if the flags match all axiom types, false otherwise.</returns>
        public static bool CowlAxiomFlagsHasAllTypes(ulong flags)
        {
            var ___ret = __Internal.CowlAxiomFlagsHasAllTypes(flags);
            return ___ret;
        }

        /// <summary>Checks whether the flags match no axiom types.</summary>
        /// <param name="flags">Axiom flags.</param>
        /// <returns>True if the flags match no axiom types, false otherwise.</returns>
        public static bool CowlAxiomFlagsHasNoTypes(ulong flags)
        {
            var ___ret = __Internal.CowlAxiomFlagsHasNoTypes(flags);
            return ___ret;
        }
    }

    /// <summary>Return codes for API calls that can fail.</summary>
    /// <remarks>Error codes are guaranteed to evaluate to true in boolean expressions.</remarks>
    public enum CowlRet
    {
        /// <summary>Success.</summary>
        COWL_OK = 0,
        /// <summary>Failure with unspecified error.</summary>
        COWL_ERR = 1,
        /// <summary>Input/output error, usually returned when a file or stream operation fails.</summary>
        /// <remarks>When this happens, `errno` is sometimes set to a more meaningful value.</remarks>
        COWL_ERR_IO = 2,
        /// <summary>Memory error, usually caused by failed allocations.</summary>
        COWL_ERR_MEM = 3,
        /// <summary>Syntax error.</summary>
        COWL_ERR_SYNTAX = 4,
        /// <summary>Import error.</summary>
        COWL_ERR_IMPORT = 5,
        /// <summary>Number of enum values.</summary>
        COWL_RET_COUNT = 6,
        /// <summary>First enum value.</summary>
        COWL_RET_FIRST = 0
    }

    /// <summary>Return codes.</summary>
    /// <summary>Return codes for IO streams.</summary>
    /// <summary>Return codes.</summary>
    /// <summary>Return codes for API calls that can fail.</summary>
    /// <remarks>Error codes are guaranteed to evaluate to true in boolean expressions.</remarks>
    public unsafe partial class cowl_ret
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ret_from_ustream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlRetFromUstream(global::cowl.UstreamRet ret);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ret_from_uvec", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlRetFromUvec(global::cowl.UvecRet ret);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ret_from_uhash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlRetFromUhash(global::cowl.UhashRet ret);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ret_to_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlRetToUstring(__IntPtr @return, global::cowl.CowlRet ret);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ret_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlRetToString(global::cowl.CowlRet ret);
        }

        /// <summary>Convertsinto</summary>
        /// <param name="ret">Return code.</param>
        /// <returns>Return value.</returns>
        public static global::cowl.CowlRet CowlRetFromUstream(global::cowl.UstreamRet ret)
        {
            var ___ret = __Internal.CowlRetFromUstream(ret);
            return ___ret;
        }

        /// <summary>Convertsinto</summary>
        /// <param name="ret">Return code.</param>
        /// <returns>Return value.</returns>
        public static global::cowl.CowlRet CowlRetFromUvec(global::cowl.UvecRet ret)
        {
            var ___ret = __Internal.CowlRetFromUvec(ret);
            return ___ret;
        }

        /// <summary>Convertsinto</summary>
        /// <param name="ret">Return code.</param>
        /// <returns>Return value.</returns>
        public static global::cowl.CowlRet CowlRetFromUhash(global::cowl.UhashRet ret)
        {
            var ___ret = __Internal.CowlRetFromUhash(ret);
            return ___ret;
        }

        /// <summary>Returns a human-readable string representation of the specified return value.</summary>
        /// <param name="ret">Return value.</param>
        /// <returns>String representation, or NULL on error.</returns>
        /// <remarks>You must not modify or free the returned string.</remarks>
        public static global::cowl.UString CowlRetToUstring(global::cowl.CowlRet ret)
        {
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.CowlRetToUstring(new IntPtr(&___ret), ret);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Returns a human-readable string representation of the specified return value.</summary>
        /// <param name="ret">Return value.</param>
        /// <returns>String representation, or NULL on error.</returns>
        public static global::cowl.CowlString CowlRetToString(global::cowl.CowlRet ret)
        {
            var ___ret = __Internal.CowlRetToString(ret);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Pointer to any</summary>
    public unsafe partial class PUvecSizingCowlObjectPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _d;
            internal uint _c;
            internal byte _e;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_sizing_CowlObjectPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingCowlObjectPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecSizingCowlObjectPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecSizingCowlObjectPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecSizingCowlObjectPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecSizingCowlObjectPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecSizingCowlObjectPtr(native.ToPointer(), skipVTables);
        }

        internal static PUvecSizingCowlObjectPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecSizingCowlObjectPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecSizingCowlObjectPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecSizingCowlObjectPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecSizingCowlObjectPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecSizingCowlObjectPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecSizingCowlObjectPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecSizingCowlObjectPtr(global::cowl.PUvecSizingCowlObjectPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecSizingCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecSizingCowlObjectPtr.__Internal*) __Instance) = *((global::cowl.PUvecSizingCowlObjectPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr* D
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_d;
            }

            set
            {
                ((__Internal*)__Instance)->_d = (__IntPtr)value;
            }
        }

        public uint C
        {
            get
            {
                return ((__Internal*)__Instance)->_c;
            }

            set
            {
                ((__Internal*)__Instance)->_c = value;
            }
        }

        public byte E
        {
            get
            {
                return ((__Internal*)__Instance)->_e;
            }

            set
            {
                ((__Internal*)__Instance)->_e = value;
            }
        }
    }

    public unsafe partial class PUvecLargeCowlObjectPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr _data;
            internal uint _count;
            internal fixed byte _exp[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0p_uvec_large_CowlObjectPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeCowlObjectPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.PUvecLargeCowlObjectPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.PUvecLargeCowlObjectPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.PUvecLargeCowlObjectPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PUvecLargeCowlObjectPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PUvecLargeCowlObjectPtr(native.ToPointer(), skipVTables);
        }

        internal static PUvecLargeCowlObjectPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PUvecLargeCowlObjectPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PUvecLargeCowlObjectPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PUvecLargeCowlObjectPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PUvecLargeCowlObjectPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PUvecLargeCowlObjectPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PUvecLargeCowlObjectPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PUvecLargeCowlObjectPtr(global::cowl.PUvecLargeCowlObjectPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.PUvecLargeCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.PUvecLargeCowlObjectPtr.__Internal*) __Instance) = *((global::cowl.PUvecLargeCowlObjectPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr* Data
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_data;
            }

            set
            {
                ((__Internal*)__Instance)->_data = (__IntPtr)value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public byte[] Exp
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_exp, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->_exp[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecCowlObjectPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::cowl.PUvecLargeCowlObjectPtr.__Internal _l;

            [FieldOffset(0)]
            internal fixed byte _s[16];

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_CowlObjectPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecCowlObjectPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecCowlObjectPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecCowlObjectPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecCowlObjectPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecCowlObjectPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecCowlObjectPtr(native.ToPointer(), skipVTables);
        }

        internal static UVecCowlObjectPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecCowlObjectPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecCowlObjectPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecCowlObjectPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecCowlObjectPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecCowlObjectPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecCowlObjectPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecCowlObjectPtr(global::cowl.UVecCowlObjectPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecCowlObjectPtr.__Internal*) __Instance) = *((global::cowl.UVecCowlObjectPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.PUvecLargeCowlObjectPtr L
        {
            get
            {
                return global::cowl.PUvecLargeCowlObjectPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_l));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_l = *(global::cowl.PUvecLargeCowlObjectPtr.__Internal*) value.__Instance;
            }
        }

        public byte[] S
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->_s, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->_s[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class UVecLoopCowlObjectPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr item;
            internal uint i;
            internal uint count;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UVec_Loop_CowlObjectPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoopCowlObjectPtr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UVecLoopCowlObjectPtr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UVecLoopCowlObjectPtr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UVecLoopCowlObjectPtr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVecLoopCowlObjectPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVecLoopCowlObjectPtr(native.ToPointer(), skipVTables);
        }

        internal static UVecLoopCowlObjectPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVecLoopCowlObjectPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVecLoopCowlObjectPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVecLoopCowlObjectPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVecLoopCowlObjectPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVecLoopCowlObjectPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UVecLoopCowlObjectPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoopCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UVecLoopCowlObjectPtr(global::cowl.UVecLoopCowlObjectPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UVecLoopCowlObjectPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UVecLoopCowlObjectPtr.__Internal*) __Instance) = *((global::cowl.UVecLoopCowlObjectPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr* Item
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->item;
            }

            set
            {
                ((__Internal*)__Instance)->item = (__IntPtr)value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    public unsafe partial class cowl_vector
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reserve_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecReserveCowlObjectPtr(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_set_range_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecSetRangeCowlObjectPtr(__IntPtr vec, __IntPtr* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecCopyCowlObjectPtr(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_copy_to_array_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCopyToArrayCowlObjectPtr(__IntPtr vec, __IntPtr[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shrink_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecShrinkCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_pop_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecPopCowlObjectPtr(__IntPtr vec, __IntPtr* item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_range_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecRemoveRangeCowlObjectPtr(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_insert_range_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertRangeCowlObjectPtr(__IntPtr vec, __IntPtr* array, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_range_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveRangeCowlObjectPtr(__IntPtr vec, uint start, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_reverse_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecReverseCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_shuffle_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecShuffleCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_index_of_reverse_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecIndexOfReverseCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_remove_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecRemoveCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_unordered_remove_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecUnorderedRemoveCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_equals_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecEqualsCowlObjectPtr(__IntPtr vec, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_push_unique_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecPushUniqueCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uvec_CowlObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecCowlObjectPtr(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_assign_CowlObjectPtr@@YA?AUUVec_CowlObjectPtr@@PEAPEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecAssignCowlObjectPtr(__IntPtr @return, __IntPtr* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_wrap_CowlObjectPtr@@YA?AUUVec_CowlObjectPtr@@PEAPEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecWrapCowlObjectPtr(__IntPtr @return, __IntPtr* array, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_data_CowlObjectPtr@@YAPEAPEAXPEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr* UvecDataCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_size_CowlObjectPtr@@YAIPEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecSizeCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_count_CowlObjectPtr@@YAIPEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UvecCountCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_set_count_CowlObjectPtr@@YAXPEAUUVec_CowlObjectPtr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecSetCountCowlObjectPtr(__IntPtr vec, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_last_CowlObjectPtr@@YAPEAXPEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UvecLastCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_view_from_CowlObjectPtr@@YA?AUUVec_CowlObjectPtr@@PEBU1@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecViewFromCowlObjectPtr(__IntPtr @return, __IntPtr vec, uint start);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_deinit_CowlObjectPtr@@YAXPEAUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecDeinitCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_move_CowlObjectPtr@@YA?AUUVec_CowlObjectPtr@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecMoveCowlObjectPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_expand_CowlObjectPtr@@YA?AW4uvec_ret@@PEAUUVec_CowlObjectPtr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecExpandCowlObjectPtr(__IntPtr vec, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_CowlObjectPtr@@YA?AW4uvec_ret@@PEAUUVec_CowlObjectPtr@@PEBU2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendCowlObjectPtr(__IntPtr vec, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_append_array_CowlObjectPtr@@YA?AW4uvec_ret@@PEAUUVec_CowlObjectPtr@@PEBQEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecAppendArrayCowlObjectPtr(__IntPtr vec, __IntPtr* src, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_insert_at_CowlObjectPtr@@YA?AW4uvec_ret@@PEAUUVec_CowlObjectPtr@@IPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UvecRet UvecInsertAtCowlObjectPtr(__IntPtr vec, uint idx, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_unordered_remove_at_CowlObjectPtr@@YAXPEAUUVec_CowlObjectPtr@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecUnorderedRemoveAtCowlObjectPtr(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_clear_CowlObjectPtr@@YAXPEAUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UvecClearCowlObjectPtr(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_init_CowlObjectPtr@@YA?AUUVec_Loop_CowlObjectPtr@@PEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopInitCowlObjectPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uvec_loop_reverse_init_CowlObjectPtr@@YA?AUUVec_Loop_CowlObjectPtr@@PEBUUVec_CowlObjectPtr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PUvecLoopReverseInitCowlObjectPtr(__IntPtr @return, __IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uvec_contains_CowlObjectPtr@@YA_NPEBUUVec_CowlObjectPtr@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UvecContainsCowlObjectPtr(__IntPtr vec, __IntPtr item);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vector", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlVector(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vector_get_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlVectorGetData(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vector_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlVectorCount(__IntPtr vec);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vector_get_item", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlVectorGetItem(__IntPtr vec, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vector_contains", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlVectorContains(__IntPtr vec, __IntPtr @object);
        }

        public static global::cowl.UvecRet UvecReserveCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecReserveCowlObjectPtr(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecSetRangeCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSetRangeCowlObjectPtr(__arg0, array, start, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecCopyCowlObjectPtr(global::cowl.UVecCowlObjectPtr src, global::cowl.UVecCowlObjectPtr dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UvecCopyCowlObjectPtr(__arg0, __arg1);
            return ___ret;
        }

        public static void UvecCopyToArrayCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr[] array)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecCopyToArrayCowlObjectPtr(__arg0, array);
        }

        public static global::cowl.UvecRet UvecShrinkCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecShrinkCowlObjectPtr(__arg0);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecPopCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr* item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPopCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static void UvecRemoveRangeCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecRemoveRangeCowlObjectPtr(__arg0, start, n);
        }

        public static global::cowl.UvecRet UvecInsertRangeCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr* array, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertRangeCowlObjectPtr(__arg0, array, start, n);
            return ___ret;
        }

        public static void UvecUnorderedRemoveRangeCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint start, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveRangeCowlObjectPtr(__arg0, start, n);
        }

        public static void UvecReverseCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecReverseCowlObjectPtr(__arg0);
        }

        public static void UvecShuffleCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecShuffleCowlObjectPtr(__arg0);
        }

        public static uint UvecIndexOfCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static uint UvecIndexOfReverseCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecIndexOfReverseCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecRemoveCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecRemoveCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecUnorderedRemoveCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecUnorderedRemoveCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static bool UvecEqualsCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, global::cowl.UVecCowlObjectPtr other)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.UvecEqualsCowlObjectPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecPushUniqueCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecPushUniqueCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        public static global::cowl.UVecCowlObjectPtr UvecCowlObjectPtr()
        {
            var ___ret = new global::cowl.UVecCowlObjectPtr.__Internal();
            __Internal.UvecCowlObjectPtr(new IntPtr(&___ret));
            return global::cowl.UVecCowlObjectPtr.__CreateInstance(___ret);
        }

        public static global::cowl.UVecCowlObjectPtr UvecAssignCowlObjectPtr(__IntPtr* array, uint count)
        {
            var ___ret = new global::cowl.UVecCowlObjectPtr.__Internal();
            __Internal.UvecAssignCowlObjectPtr(new IntPtr(&___ret), array, count);
            return global::cowl.UVecCowlObjectPtr.__CreateInstance(___ret);
        }

        public static global::cowl.UVecCowlObjectPtr UvecWrapCowlObjectPtr(__IntPtr* array, uint count)
        {
            var ___ret = new global::cowl.UVecCowlObjectPtr.__Internal();
            __Internal.UvecWrapCowlObjectPtr(new IntPtr(&___ret), array, count);
            return global::cowl.UVecCowlObjectPtr.__CreateInstance(___ret);
        }

        public static __IntPtr* UvecDataCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecDataCowlObjectPtr(__arg0);
            return ___ret;
        }

        public static uint UvecSizeCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecSizeCowlObjectPtr(__arg0);
            return ___ret;
        }

        public static uint UvecCountCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecCountCowlObjectPtr(__arg0);
            return ___ret;
        }

        public static void PUvecSetCountCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint count)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.PUvecSetCountCowlObjectPtr(__arg0, count);
        }

        public static __IntPtr UvecLastCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecLastCowlObjectPtr(__arg0);
            return ___ret;
        }

        public static global::cowl.UVecCowlObjectPtr UvecViewFromCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint start)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecCowlObjectPtr.__Internal();
            __Internal.UvecViewFromCowlObjectPtr(new IntPtr(&___ret), __arg0, start);
            return global::cowl.UVecCowlObjectPtr.__CreateInstance(___ret);
        }

        public static void UvecDeinitCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecDeinitCowlObjectPtr(__arg0);
        }

        public static global::cowl.UVecCowlObjectPtr UvecMoveCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecCowlObjectPtr.__Internal();
            __Internal.UvecMoveCowlObjectPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecCowlObjectPtr.__CreateInstance(___ret);
        }

        public static global::cowl.UvecRet UvecExpandCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint size)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecExpandCowlObjectPtr(__arg0, size);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, global::cowl.UVecCowlObjectPtr src)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.UvecAppendCowlObjectPtr(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecAppendArrayCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr* src, uint n)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecAppendArrayCowlObjectPtr(__arg0, src, n);
            return ___ret;
        }

        public static global::cowl.UvecRet UvecInsertAtCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint idx, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecInsertAtCowlObjectPtr(__arg0, idx, item);
            return ___ret;
        }

        public static void UvecUnorderedRemoveAtCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecUnorderedRemoveAtCowlObjectPtr(__arg0, idx);
        }

        public static void UvecClearCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            __Internal.UvecClearCowlObjectPtr(__arg0);
        }

        public static global::cowl.UVecLoopCowlObjectPtr PUvecLoopInitCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoopCowlObjectPtr.__Internal();
            __Internal.PUvecLoopInitCowlObjectPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoopCowlObjectPtr.__CreateInstance(___ret);
        }

        public static global::cowl.UVecLoopCowlObjectPtr PUvecLoopReverseInitCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = new global::cowl.UVecLoopCowlObjectPtr.__Internal();
            __Internal.PUvecLoopReverseInitCowlObjectPtr(new IntPtr(&___ret), __arg0);
            return global::cowl.UVecLoopCowlObjectPtr.__CreateInstance(___ret);
        }

        public static bool UvecContainsCowlObjectPtr(global::cowl.UVecCowlObjectPtr vec, __IntPtr item)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.UvecContainsCowlObjectPtr(__arg0, item);
            return ___ret;
        }

        /// <summary>Returns a vector.</summary>
        /// <param name="vec">Underlying raw vector.</param>
        /// <returns>Vector, or NULL on error.</returns>
        /// <remarks>
        /// <para>You must not use the raw vector after passing it to this function.</para>
        /// <para>Elements in the raw vector are retained by this constructor.</para>
        /// </remarks>
        public static global::cowl.CowlVector CowlVector(global::cowl.UVecCowlObjectPtr vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.CowlVector(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the underlying raw vector.</summary>
        /// <param name="vec">The vector.</param>
        /// <returns>Underlying raw vector.</returns>
        public static global::cowl.UVecCowlObjectPtr CowlVectorGetData(global::cowl.CowlVector vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.CowlVectorGetData(__arg0);
            var __result0 = global::cowl.UVecCowlObjectPtr.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the number of elements in the vector.</summary>
        /// <param name="vec">The vector.</param>
        /// <returns>Number of elements in the vector.</returns>
        public static uint CowlVectorCount(global::cowl.CowlVector vec)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.CowlVectorCount(__arg0);
            return ___ret;
        }

        /// <summary>Returns the element at the specified index.</summary>
        /// <param name="vec">The vector.</param>
        /// <param name="idx">The index.</param>
        /// <returns>The element at the specified index.</returns>
        public static __IntPtr CowlVectorGetItem(global::cowl.CowlVector vec, uint idx)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.CowlVectorGetItem(__arg0, idx);
            return ___ret;
        }

        /// <summary>Checks whether the vector contains the specified element.</summary>
        /// <param name="vec">The vector.</param>
        /// <param name="object">The object.</param>
        /// <returns>True if the vector contains the specified element, false otherwise.</returns>
        public static bool CowlVectorContains(global::cowl.CowlVector vec, __IntPtr @object)
        {
            var __arg0 = vec is null ? __IntPtr.Zero : vec.__Instance;
            var ___ret = __Internal.CowlVectorContains(__arg0, @object);
            return ___ret;
        }
    }

    /// <summary>Axiom filter.</summary>
    /// <summary>Axiom filter.</summary>
    public unsafe partial class CowlAxiomFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal ulong types;
            internal global::cowl.UVecCowlObjectPtr.__Internal primitives;
            internal global::cowl.CowlFilter.__Internal closure;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlAxiomFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAxiomFilter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlAxiomFilter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlAxiomFilter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlAxiomFilter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlAxiomFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlAxiomFilter(native.ToPointer(), skipVTables);
        }

        internal static CowlAxiomFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlAxiomFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlAxiomFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlAxiomFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlAxiomFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlAxiomFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlAxiomFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlAxiomFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlAxiomFilter(global::cowl.CowlAxiomFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlAxiomFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlAxiomFilter.__Internal*) __Instance) = *((global::cowl.CowlAxiomFilter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Match axioms of the specified types.</summary>
        public ulong Types
        {
            get
            {
                return ((__Internal*)__Instance)->types;
            }

            set
            {
                ((__Internal*)__Instance)->types = value;
            }
        }

        /// <summary>Match axioms referencing all the specified primitives.</summary>
        public global::cowl.UVecCowlObjectPtr Primitives
        {
            get
            {
                return global::cowl.UVecCowlObjectPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->primitives));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->primitives = *(global::cowl.UVecCowlObjectPtr.__Internal*) value.__Instance;
            }
        }

        /// <summary>Match axioms based on the specified closure.</summary>
        public global::cowl.CowlFilter Closure
        {
            get
            {
                return global::cowl.CowlFilter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->closure));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->closure = *(global::cowl.CowlFilter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_axiom_filter
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter@@YA?AUCowlAxiomFilter@@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cowl_axiom_filter(__IntPtr @return, ulong types);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_deinit@@YAXPEAUCowlAxiomFilter@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlAxiomFilterDeinit(__IntPtr filter);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_add_type@@YAXPEAUCowlAxiomFilter@@W4CowlAxiomType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlAxiomFilterAddType(__IntPtr filter, global::cowl.CowlAxiomType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_remove_type@@YAXPEAUCowlAxiomFilter@@W4CowlAxiomType@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlAxiomFilterRemoveType(__IntPtr filter, global::cowl.CowlAxiomType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_add_primitive@@YA?AW4cowl_ret@@PEAUCowlAxiomFilter@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlAxiomFilterAddPrimitive(__IntPtr filter, __IntPtr primitive);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_remove_primitive@@YAXPEAUCowlAxiomFilter@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlAxiomFilterRemovePrimitive(__IntPtr filter, __IntPtr primitive);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_axiom_filter_set_closure@@YAXPEAUCowlAxiomFilter@@UCowlFilter@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlAxiomFilterSetClosure(__IntPtr filter, __IntPtr closure);
        }

        /// <summary>Returns a new axiom filter.</summary>
        /// <param name="types">Axiom types.</param>
        /// <returns>Axiom filter.</returns>
        public static global::cowl.CowlAxiomFilter cowl_axiom_filter_(ulong types)
        {
            var ___ret = new global::cowl.CowlAxiomFilter.__Internal();
            __Internal.cowl_axiom_filter(new IntPtr(&___ret), types);
            return global::cowl.CowlAxiomFilter.__CreateInstance(___ret);
        }

        /// <summary>De-initializes an axiom filter previously initialized via</summary>
        /// <param name="filter">Axiom filter.</param>
        public static void CowlAxiomFilterDeinit(global::cowl.CowlAxiomFilter filter)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            __Internal.CowlAxiomFilterDeinit(__arg0);
        }

        /// <summary>Adds the specified axiom type to the filter.</summary>
        /// <param name="filter">Axiom filter.</param>
        /// <param name="type">Axiom type.</param>
        public static void CowlAxiomFilterAddType(global::cowl.CowlAxiomFilter filter, global::cowl.CowlAxiomType type)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            __Internal.CowlAxiomFilterAddType(__arg0, type);
        }

        /// <summary>Removes the specified axiom type from the filter.</summary>
        /// <param name="filter">Axiom filter.</param>
        /// <param name="type">Axiom type.</param>
        public static void CowlAxiomFilterRemoveType(global::cowl.CowlAxiomFilter filter, global::cowl.CowlAxiomType type)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            __Internal.CowlAxiomFilterRemoveType(__arg0, type);
        }

        /// <summary>Adds the specified primitive to the filter.</summary>
        /// <param name="filter">Axiom filter.</param>
        /// <param name="primitive">Primitive.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlAxiomFilterAddPrimitive(global::cowl.CowlAxiomFilter filter, __IntPtr primitive)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            var ___ret = __Internal.CowlAxiomFilterAddPrimitive(__arg0, primitive);
            return ___ret;
        }

        /// <summary>Removes the specified primitive from the filter.</summary>
        /// <param name="filter">Axiom filter.</param>
        /// <param name="primitive">Primitive.</param>
        public static void CowlAxiomFilterRemovePrimitive(global::cowl.CowlAxiomFilter filter, __IntPtr primitive)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            __Internal.CowlAxiomFilterRemovePrimitive(__arg0, primitive);
        }

        /// <summary>Sets the filter closure.</summary>
        /// <param name="filter">Axiom filter.</param>
        /// <param name="closure">Filter closure.</param>
        public static void CowlAxiomFilterSetClosure(global::cowl.CowlAxiomFilter filter, global::cowl.CowlFilter closure)
        {
            var __arg0 = filter is null ? __IntPtr.Zero : filter.__Instance;
            if (ReferenceEquals(closure, null))
                throw new global::System.ArgumentNullException("closure", "Cannot be null because it is passed by value.");
            var __arg1 = closure.__Instance;
            __Internal.CowlAxiomFilterSetClosure(__arg0, __arg1);
        }
    }

    /// <summary>Represents the type ofand</summary>
    public enum CowlCardType
    {
        /// <summary>Minimum cardinality.</summary>
        COWL_CT_MIN = 0,
        /// <summary>Maximum cardinality.</summary>
        COWL_CT_MAX = 1,
        /// <summary>Exact cardinality.</summary>
        COWL_CT_EXACT = 2,
        /// <summary>Number of enum values.</summary>
        COWL_CT_COUNT = 3,
        /// <summary>First enum value.</summary>
        COWL_CT_FIRST = 0
    }

    /// <summary>Represents the type ofand</summary>
    /// <summary>Represents the type of</summary>
    public enum CowlCharAxiomType
    {
        /// <summary>Functional object property.</summary>
        COWL_CAT_FUNC = 0,
        /// <summary>Inverse functional object property.</summary>
        COWL_CAT_INV_FUNC = 1,
        /// <summary>Symmetric object property.</summary>
        COWL_CAT_SYMM = 2,
        /// <summary>Asymmetric object property.</summary>
        COWL_CAT_ASYMM = 3,
        /// <summary>Transitive object property.</summary>
        COWL_CAT_TRANS = 4,
        /// <summary>Reflexive object property.</summary>
        COWL_CAT_REFL = 5,
        /// <summary>Irreflexive object property.</summary>
        COWL_CAT_IRREFL = 6,
        /// <summary>Number of enum values.</summary>
        COWL_CAT_COUNT = 7,
        /// <summary>First enum value.</summary>
        COWL_CAT_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class CowlClass
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClass> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClass>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlClass managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlClass managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlClass __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlClass(native.ToPointer(), skipVTables);
        }

        internal static CowlClass __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlClass)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlClass __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlClass(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlClass(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_class
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_class", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClass(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_class_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClassFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_class_get_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClassGetIri(__IntPtr cls);
        }

        /// <summary>Returns a class.</summary>
        /// <param name="iri">IRI of the class.</param>
        /// <returns>Class, or NULL on error.</returns>
        public static global::cowl.CowlClass CowlClass(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlClass(__arg0);
            var __result0 = global::cowl.CowlClass.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a class given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Class, or NULL on error.</returns>
        public static global::cowl.CowlClass CowlClassFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlClassFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlClass.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the specified class.</summary>
        /// <param name="cls">The class.</param>
        /// <returns>IRI of the class.</returns>
        public static global::cowl.CowlIRI CowlClassGetIri(global::cowl.CowlClass cls)
        {
            var __arg0 = cls is null ? __IntPtr.Zero : cls.__Instance;
            var ___ret = __Internal.CowlClassGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlClsExp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClsExp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClsExp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlClsExp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlClsExp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlClsExp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlClsExp(native.ToPointer(), skipVTables);
        }

        internal static CowlClsExp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlClsExp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlClsExp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlClsExp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlClsExp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlClsExp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlIndividual
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIndividual> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIndividual>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlIndividual managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlIndividual managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlIndividual __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlIndividual(native.ToPointer(), skipVTables);
        }

        internal static CowlIndividual __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlIndividual)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlIndividual __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlIndividual(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlIndividual(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlIndividual(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlClsAssertAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClsAssertAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlClsAssertAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlClsAssertAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlClsAssertAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlClsAssertAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlClsAssertAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlClsAssertAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlClsAssertAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlClsAssertAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlClsAssertAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlClsAssertAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlClsAssertAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_cls_assert_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_cls_assert_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClsAssertAxiom(__IntPtr exp, __IntPtr ind, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_cls_assert_axiom_get_cls_exp@@YAPEAUCowlClsExp@@PEAUCowlClsAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClsAssertAxiomGetClsExp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_cls_assert_axiom_get_ind@@YAPEAUCowlIndividual@@PEAUCowlClsAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlClsAssertAxiomGetInd(__IntPtr axiom);
        }

        /// <summary>Returns a class assertion axiom.</summary>
        /// <param name="exp">The asserted class expression.</param>
        /// <param name="ind">The assertion individual.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlClsAssertAxiom CowlClsAssertAxiom(__IntPtr exp, __IntPtr ind, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlClsAssertAxiom(exp, ind, __arg2);
            var __result0 = global::cowl.CowlClsAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the class expression that is asserted to be a type for an individual by this axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The class expression.</returns>
        public static global::cowl.CowlClsExp CowlClsAssertAxiomGetClsExp(global::cowl.CowlClsAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlClsAssertAxiomGetClsExp(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the individual that is asserted to be an instance of a class expression by this axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The individual.</returns>
        public static global::cowl.CowlIndividual CowlClsAssertAxiomGetInd(global::cowl.CowlClsAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlClsAssertAxiomGetInd(__arg0);
            var __result0 = global::cowl.CowlIndividual.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlClsExpType
    {
        /// <summary>- class.</summary>
        COWL_CET_CLASS = 0,
        /// <summary>- &quot;some values from&quot; object property restriction.</summary>
        COWL_CET_OBJ_SOME = 1,
        /// <summary>- &quot;all values from&quot; object property restriction.</summary>
        COWL_CET_OBJ_ALL = 2,
        /// <summary>- &quot;minimum cardinality&quot; object property restriction.</summary>
        COWL_CET_OBJ_MIN_CARD = 3,
        /// <summary>- &quot;maximum cardinality&quot; object property restriction.</summary>
        COWL_CET_OBJ_MAX_CARD = 4,
        /// <summary>- &quot;exact cardinality&quot; object property restriction.</summary>
        COWL_CET_OBJ_EXACT_CARD = 5,
        /// <summary>- &quot;has value&quot; object property restriction.</summary>
        COWL_CET_OBJ_HAS_VALUE = 6,
        /// <summary>- &quot;has self&quot; object property restriction.</summary>
        COWL_CET_OBJ_HAS_SELF = 7,
        /// <summary>- &quot;some values from&quot; data property restriction.</summary>
        COWL_CET_DATA_SOME = 8,
        /// <summary>- &quot;all values from&quot; data property restriction.</summary>
        COWL_CET_DATA_ALL = 9,
        /// <summary>- &quot;min cardinality&quot; data property restriction.</summary>
        COWL_CET_DATA_MIN_CARD = 10,
        /// <summary>- &quot;max cardinality&quot; data property restriction.</summary>
        COWL_CET_DATA_MAX_CARD = 11,
        /// <summary>- &quot;exact cardinality&quot; data property restriction.</summary>
        COWL_CET_DATA_EXACT_CARD = 12,
        /// <summary>- &quot;has value&quot; data property restriction.</summary>
        COWL_CET_DATA_HAS_VALUE = 13,
        /// <summary>- Intersection of class expressions.</summary>
        COWL_CET_OBJ_INTERSECT = 14,
        /// <summary>- Union of class expressions.</summary>
        COWL_CET_OBJ_UNION = 15,
        /// <summary>- Complement of a class expression.</summary>
        COWL_CET_OBJ_COMPL = 16,
        /// <summary>- Enumeration of individuals.</summary>
        COWL_CET_OBJ_ONE_OF = 17,
        /// <summary>Number of enum values.</summary>
        COWL_CET_COUNT = 18,
        /// <summary>First enum value.</summary>
        COWL_CET_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class cowl_cls_exp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_cls_exp_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlClsExpType CowlClsExpGetType(__IntPtr exp);
        }

        /// <summary>Gets the type of the specified class expression.</summary>
        /// <param name="exp">The class expression.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlClsExpType CowlClsExpGetType(__IntPtr exp)
        {
            var ___ret = __Internal.CowlClsExpGetType(exp);
            return ___ret;
        }
    }

    /// <summary>Error location.</summary>
    /// <summary>Error data structure.</summary>
    /// <summary>Syntax error.</summary>
    /// <remarks>{CowlError}</remarks>
    /// <summary>Error location.</summary>
    public unsafe partial class CowlErrorLoc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint line;
            internal __IntPtr source;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlErrorLoc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlErrorLoc> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlErrorLoc>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlErrorLoc managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlErrorLoc managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlErrorLoc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlErrorLoc(native.ToPointer(), skipVTables);
        }

        internal static CowlErrorLoc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlErrorLoc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlErrorLoc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlErrorLoc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlErrorLoc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlErrorLoc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlErrorLoc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlErrorLoc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlErrorLoc(global::cowl.CowlErrorLoc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlErrorLoc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlErrorLoc.__Internal*) __Instance) = *((global::cowl.CowlErrorLoc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Line where the error occurred.</summary>
        public uint Line
        {
            get
            {
                return ((__Internal*)__Instance)->line;
            }

            set
            {
                ((__Internal*)__Instance)->line = value;
            }
        }

        /// <summary>Location of the ontology where the error occurred.</summary>
        public global::cowl.CowlString Source
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->source, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->source = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Error data structure.</summary>
    public unsafe partial class CowlError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::cowl.CowlRet code;
            internal __IntPtr description;
            internal __IntPtr origin;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlError@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlError> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlError>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlError managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlError managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlError __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlError(native.ToPointer(), skipVTables);
        }

        internal static CowlError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlError)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlError __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlError(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlError(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlError(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlError()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlError.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlError(global::cowl.CowlError _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlError.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlError.__Internal*) __Instance) = *((global::cowl.CowlError.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Error code.</summary>
        public global::cowl.CowlRet Code
        {
            get
            {
                return ((__Internal*)__Instance)->code;
            }

            set
            {
                ((__Internal*)__Instance)->code = value;
            }
        }

        /// <summary>Human readable description of the error.</summary>
        public global::cowl.CowlString Description
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->description, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->description = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Object that originated the error.</summary>
        public __IntPtr Origin
        {
            get
            {
                return ((__Internal*)__Instance)->origin;
            }

            set
            {
                ((__Internal*)__Instance)->origin = (__IntPtr) value;
            }
        }
    }

    /// <summary>Syntax error.</summary>
    public unsafe partial class CowlSyntaxError : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal global::cowl.CowlError.__Internal super;
            internal global::cowl.CowlErrorLoc.__Internal loc;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlSyntaxError@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSyntaxError> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSyntaxError>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSyntaxError managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSyntaxError managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSyntaxError __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSyntaxError(native.ToPointer(), skipVTables);
        }

        internal static CowlSyntaxError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSyntaxError)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSyntaxError __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSyntaxError(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSyntaxError(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSyntaxError(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlSyntaxError()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlSyntaxError.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlSyntaxError(global::cowl.CowlSyntaxError _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlSyntaxError.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlSyntaxError.__Internal*) __Instance) = *((global::cowl.CowlSyntaxError.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Base error.</summary>
        public global::cowl.CowlError Super
        {
            get
            {
                return global::cowl.CowlError.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->super));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->super = *(global::cowl.CowlError.__Internal*) value.__Instance;
            }
        }

        /// <summary>Error location.</summary>
        public global::cowl.CowlErrorLoc Loc
        {
            get
            {
                return global::cowl.CowlErrorLoc.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->loc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->loc = *(global::cowl.CowlErrorLoc.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_error
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_error_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlErrorToString(__IntPtr error);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_error_to_ustring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlErrorToUstring(__IntPtr @return, __IntPtr error);
        }

        /// <summary>Returns a human-readable string representation of the specified error.</summary>
        /// <param name="error">The error.</param>
        /// <returns>String representation, or NULL on error.</returns>
        public static global::cowl.CowlString CowlErrorToString(global::cowl.CowlError error)
        {
            var __arg0 = error is null ? __IntPtr.Zero : error.__Instance;
            var ___ret = __Internal.CowlErrorToString(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a human-readable string representation of the specified error.</summary>
        /// <param name="error">The error.</param>
        /// <returns>String representation, or ustring_null on error.</returns>
        public static global::cowl.UString CowlErrorToUstring(global::cowl.CowlError error)
        {
            var __arg0 = error is null ? __IntPtr.Zero : error.__Instance;
            var ___ret = new global::cowl.UString.__Internal();
            __Internal.CowlErrorToUstring(new IntPtr(&___ret), __arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }
    }

    /// <summary>Provides a mechanism for error handling.</summary>
    /// <summary>Provides a mechanism for error handling.</summary>
    public unsafe partial class CowlErrorHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr ctx;
            internal __IntPtr handle_error;
            internal __IntPtr free;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlErrorHandler@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlErrorHandler> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlErrorHandler>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlErrorHandler managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlErrorHandler managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlErrorHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlErrorHandler(native.ToPointer(), skipVTables);
        }

        internal static CowlErrorHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlErrorHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlErrorHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlErrorHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlErrorHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlErrorHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlErrorHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlErrorHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlErrorHandler(global::cowl.CowlErrorHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlErrorHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlErrorHandler.__Internal*) __Instance) = *((global::cowl.CowlErrorHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Error handler context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Pointer to a function called when an error occurs.</summary>
        /// <param name="ctx">Error handler context.</param>
        /// <param name="error">Error.</param>
        public global::cowl.Delegates.Action___IntPtr___IntPtr HandleError
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->handle_error;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->handle_error = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a resource deallocator function for the context.</summary>
        /// <param name="ctx">Error handler context.</param>
        /// <remarks>Can be NULL if the context does not need to release resources.</remarks>
        public global::cowl.Delegates.Action___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class cowl_error_handler
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_handle_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlHandleError(global::cowl.CowlRet code, __IntPtr desc, __IntPtr origin);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_handle_syntax_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlHandleSyntaxError(__IntPtr desc, __IntPtr origin, __IntPtr loc);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_handle_error_code", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlHandleErrorCode(global::cowl.CowlRet code, __IntPtr origin);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_handle_stream_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlHandleStreamError(global::cowl.UstreamRet code, __IntPtr origin);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_handle_path_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlHandlePathError(__IntPtr path, __IntPtr reason, __IntPtr origin);
        }

        /// <summary>Handles an error by using the most specific error handler available.</summary>
        /// <param name="code">Error code.</param>
        /// <param name="desc">Error description.</param>
        /// <param name="origin">Object that originated the error.</param>
        /// <returns>Error code.</returns>
        public static global::cowl.CowlRet CowlHandleError(global::cowl.CowlRet code, global::cowl.UString desc, __IntPtr origin)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is passed by value.");
            var __arg1 = desc.__Instance;
            var ___ret = __Internal.CowlHandleError(code, __arg1, origin);
            return ___ret;
        }

        /// <summary>Handles a syntax error via the most specific error handler available.</summary>
        /// <param name="desc">Error description.</param>
        /// <param name="origin">Object that originated the error.</param>
        /// <param name="loc">Error location.</param>
        /// <returns>Error code.</returns>
        public static global::cowl.CowlRet CowlHandleSyntaxError(global::cowl.UString desc, __IntPtr origin, global::cowl.CowlErrorLoc loc)
        {
            if (ReferenceEquals(desc, null))
                throw new global::System.ArgumentNullException("desc", "Cannot be null because it is passed by value.");
            var __arg0 = desc.__Instance;
            if (ReferenceEquals(loc, null))
                throw new global::System.ArgumentNullException("loc", "Cannot be null because it is passed by value.");
            var __arg2 = loc.__Instance;
            var ___ret = __Internal.CowlHandleSyntaxError(__arg0, origin, __arg2);
            return ___ret;
        }

        /// <summary>Handles a generic error of the specified type via the most specific error handler available.</summary>
        /// <param name="code">Error code.</param>
        /// <param name="origin">Object that originated the error.</param>
        /// <returns>Error code.</returns>
        public static global::cowl.CowlRet CowlHandleErrorCode(global::cowl.CowlRet code, __IntPtr origin)
        {
            var ___ret = __Internal.CowlHandleErrorCode(code, origin);
            return ___ret;
        }

        /// <summary>Handles an IO stream error via the most specific error handler available.</summary>
        /// <param name="code">Error code.</param>
        /// <param name="origin">Object that originated the error.</param>
        /// <returns>Error code.</returns>
        public static global::cowl.CowlRet CowlHandleStreamError(global::cowl.UstreamRet code, __IntPtr origin)
        {
            var ___ret = __Internal.CowlHandleStreamError(code, origin);
            return ___ret;
        }

        /// <summary>Handles an error triggered while accessing the file at the specified path.</summary>
        /// <param name="path">File path.</param>
        /// <param name="reason">Why the error was triggered.</param>
        /// <param name="origin">Object that originated the error.</param>
        /// <returns>Error code.</returns>
        public static global::cowl.CowlRet CowlHandlePathError(global::cowl.UString path, global::cowl.UString reason, __IntPtr origin)
        {
            if (ReferenceEquals(path, null))
                throw new global::System.ArgumentNullException("path", "Cannot be null because it is passed by value.");
            var __arg0 = path.__Instance;
            if (ReferenceEquals(reason, null))
                throw new global::System.ArgumentNullException("reason", "Cannot be null because it is passed by value.");
            var __arg1 = reason.__Instance;
            var ___ret = __Internal.CowlHandlePathError(__arg0, __arg1, origin);
            return ___ret;
        }
    }

    /// <summary>Provides a mechanism for generic handling of [ontology imports].</summary>
    /// <remarks>
    /// <para>The `load_ontology` function should return the ontology that has the specified</para>
    /// <para>Imports retrieval and loading is deliberately left to the implementor.</para>
    /// <para>[ontology imports]: https://www.w3.org/TR/owl2-syntax/#Imports</para>
    /// </remarks>
    public unsafe partial class CowlOntology
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntology> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntology>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOntology managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOntology managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOntology __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOntology(native.ToPointer(), skipVTables);
        }

        internal static CowlOntology __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOntology)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOntology __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOntology(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOntology(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOntology(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Provides a mechanism for generic handling of [ontology imports].</summary>
    /// <remarks>
    /// <para>The `load_ontology` function should return the ontology that has the specified</para>
    /// <para>Imports retrieval and loading is deliberately left to the implementor.</para>
    /// <para>[ontology imports]: https://www.w3.org/TR/owl2-syntax/#Imports</para>
    /// </remarks>
    public unsafe partial class CowlImportLoader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr ctx;
            internal __IntPtr load_ontology;
            internal __IntPtr free;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlImportLoader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlImportLoader> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlImportLoader>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlImportLoader managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlImportLoader managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlImportLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlImportLoader(native.ToPointer(), skipVTables);
        }

        internal static CowlImportLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlImportLoader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlImportLoader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlImportLoader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlImportLoader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlImportLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlImportLoader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlImportLoader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlImportLoader(global::cowl.CowlImportLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlImportLoader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlImportLoader.__Internal*) __Instance) = *((global::cowl.CowlImportLoader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Loader context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Pointer to a function that returns the ontology having the specified IRI.</summary>
        /// <param name="ctx">Loader context.</param>
        /// <param name="iri">IRI of the ontology to load.</param>
        /// <returns>The imported ontology, or NULL on error.</returns>
        public global::cowl.Delegates.Func___IntPtr___IntPtr___IntPtr LoadOntology
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->load_ontology;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->load_ontology = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a resource deallocator function for the context.</summary>
        /// <param name="ctx">Loader context.</param>
        /// <remarks>Can be NULL if the context does not need to release resources.</remarks>
        public global::cowl.Delegates.Action___IntPtr Free
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->free = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Defines a reader.</summary>
    public unsafe partial class CowlIStream
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlIStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlIStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlIStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlIStream(native.ToPointer(), skipVTables);
        }

        internal static CowlIStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlIStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlIStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlIStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlIStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlIStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Defines a reader.</summary>
    public unsafe partial class CowlReader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal __IntPtr read;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlReader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlReader> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlReader>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlReader managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlReader managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static CowlReader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlReader(native.ToPointer(), skipVTables);
        }

        internal static CowlReader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlReader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlReader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlReader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlReader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlReader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlReader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlReader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlReader(global::cowl.CowlReader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlReader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlReader.__Internal*) __Instance) = *((global::cowl.CowlReader.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Name of the reader.</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Pointer to a function that reads an ontology from an input stream.</summary>
        /// <param name="state">Reader state.</param>
        /// <param name="istream">Input stream.</param>
        /// <param name="stream">Ontology input stream.</param>
        /// <returns>Return code.</returns>
        /// <remarks>This member is mandatory.</remarks>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>An object that identifies an ontology.</summary>
    /// <remarks>
    /// <para>[Ontology IRI and version IRI]</para>
    /// <para>[Ontology IRI and version IRI]: https://www.w3.org/TR/owl2-syntax/#Ontology_IRI_and_Version_IRI</para>
    /// </remarks>
    /// <summary>An object that identifies an ontology.</summary>
    /// <remarks>
    /// <para>[Ontology IRI and version IRI]</para>
    /// <para>[Ontology IRI and version IRI]: https://www.w3.org/TR/owl2-syntax/#Ontology_IRI_and_Version_IRI</para>
    /// </remarks>
    public unsafe partial class CowlOntologyId : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr iri;
            internal __IntPtr version;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOntologyId@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntologyId> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntologyId>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOntologyId managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOntologyId managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOntologyId __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOntologyId(native.ToPointer(), skipVTables);
        }

        internal static CowlOntologyId __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOntologyId)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOntologyId __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOntologyId(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOntologyId(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOntologyId(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOntologyId()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOntologyId.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOntologyId(global::cowl.CowlOntologyId _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOntologyId.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOntologyId.__Internal*) __Instance) = *((global::cowl.CowlOntologyId.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The ontology IRI.</summary>
        public global::cowl.CowlIRI Iri
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->iri, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->iri = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The version IRI.</summary>
        public global::cowl.CowlIRI Version
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->version, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->version = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_ontology_id
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_id_anonymous", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlOntologyIdAnonymous(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_id_equals", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIdEquals(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_id_hash", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyIdHash(__IntPtr id);
        }

        /// <summary>Creates the ID of an anonymous ontology.</summary>
        /// <returns>ID of an anonymous ontology.</returns>
        public static global::cowl.CowlOntologyId CowlOntologyIdAnonymous()
        {
            var ___ret = new global::cowl.CowlOntologyId.__Internal();
            __Internal.CowlOntologyIdAnonymous(new IntPtr(&___ret));
            return global::cowl.CowlOntologyId.__CreateInstance(___ret);
        }

        /// <summary>Equality function.</summary>
        /// <param name="lhs">LHS of the equality relation.</param>
        /// <param name="rhs">RHS of the equality relation.</param>
        /// <returns>True if the equality relation holds, false otherwise.</returns>
        /// <remarks>
        /// <para>Ontology IDs are considered equal if they have the same ontology IRI and version IRI.</para>
        /// <para>Since OWL 2 allows for both the ontology and version IRIs to be simultaneously empty,</para>
        /// <para>in that case the ontology IDs are considered different unless they are the same instance.</para>
        /// </remarks>
        public static bool CowlOntologyIdEquals(global::cowl.CowlOntologyId lhs, global::cowl.CowlOntologyId rhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg1 = rhs.__Instance;
            var ___ret = __Internal.CowlOntologyIdEquals(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Hash function.</summary>
        /// <param name="id">The ontology ID.</param>
        /// <returns>The hash value.</returns>
        public static uint CowlOntologyIdHash(global::cowl.CowlOntologyId id)
        {
            if (ReferenceEquals(id, null))
                throw new global::System.ArgumentNullException("id", "Cannot be null because it is passed by value.");
            var __arg0 = id.__Instance;
            var ___ret = __Internal.CowlOntologyIdHash(__arg0);
            return ___ret;
        }
    }

    /// <summary>Models an ontology header.</summary>
    /// <summary>Models an ontology header.</summary>
    public unsafe partial class CowlOntologyHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::cowl.CowlOntologyId.__Internal id;
            internal __IntPtr imports;
            internal __IntPtr annotations;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOntologyHeader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntologyHeader> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOntologyHeader>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOntologyHeader managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOntologyHeader managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOntologyHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOntologyHeader(native.ToPointer(), skipVTables);
        }

        internal static CowlOntologyHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOntologyHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOntologyHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOntologyHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOntologyHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOntologyHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOntologyHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOntologyHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOntologyHeader(global::cowl.CowlOntologyHeader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOntologyHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOntologyHeader.__Internal*) __Instance) = *((global::cowl.CowlOntologyHeader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Ontology identifier.</summary>
        public global::cowl.CowlOntologyId Id
        {
            get
            {
                return global::cowl.CowlOntologyId.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->id));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->id = *(global::cowl.CowlOntologyId.__Internal*) value.__Instance;
            }
        }

        /// <summary>Import IRIs.</summary>
        public global::cowl.UVecCowlObjectPtr Imports
        {
            get
            {
                var __result0 = global::cowl.UVecCowlObjectPtr.__GetOrCreateInstance(((__Internal*)__Instance)->imports, false);
                return __result0;
            }
        }

        /// <summary>Annotations.</summary>
        public global::cowl.UVecCowlObjectPtr Annotations
        {
            get
            {
                var __result0 = global::cowl.UVecCowlObjectPtr.__GetOrCreateInstance(((__Internal*)__Instance)->annotations, false);
                return __result0;
            }
        }
    }

    public unsafe partial class cowl_ontology_header
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_header_empty@@YA?AUCowlOntologyHeader@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlOntologyHeaderEmpty(__IntPtr @return);
        }

        /// <summary>Returns an empty ontology header.</summary>
        /// <returns>Empty ontology header.</returns>
        public static global::cowl.CowlOntologyHeader CowlOntologyHeaderEmpty()
        {
            var ___ret = new global::cowl.CowlOntologyHeader.__Internal();
            __Internal.CowlOntologyHeaderEmpty(new IntPtr(&___ret));
            return global::cowl.CowlOntologyHeader.__CreateInstance(___ret);
        }
    }

    /// <summary>Defines functions that must be implemented by stream writers.</summary>
    /// <summary>Defines a writer.</summary>
    public unsafe partial class CowlLiteral
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlLiteral> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlLiteral>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlLiteral managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlLiteral managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlLiteral __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlLiteral(native.ToPointer(), skipVTables);
        }

        internal static CowlLiteral __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlLiteral)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlLiteral __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlLiteral(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlLiteral(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlLiteral(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlSymTable
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSymTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSymTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSymTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSymTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSymTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSymTable(native.ToPointer(), skipVTables);
        }

        internal static CowlSymTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSymTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSymTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSymTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSymTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSymTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Defines functions that must be implemented by stream writers.</summary>
    public unsafe partial class CowlStreamWriter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr write_header;
            internal __IntPtr write_axiom;
            internal __IntPtr write_footer;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlStreamWriter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlStreamWriter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlStreamWriter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlStreamWriter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlStreamWriter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlStreamWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlStreamWriter(native.ToPointer(), skipVTables);
        }

        internal static CowlStreamWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlStreamWriter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlStreamWriter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlStreamWriter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlStreamWriter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlStreamWriter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlStreamWriter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlStreamWriter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlStreamWriter(global::cowl.CowlStreamWriter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlStreamWriter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlStreamWriter.__Internal*) __Instance) = *((global::cowl.CowlStreamWriter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to a function that writes an ontology header to an output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="st">Symbol table.</param>
        /// <param name="header">Ontology header.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr_cowl_CowlOntologyHeader___Internal WriteHeader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_header;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr_cowl_CowlOntologyHeader___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr_cowl_CowlOntologyHeader___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->write_header = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that writes an axiom to an output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="st">Symbol table.</param>
        /// <param name="axiom">Axiom.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr___IntPtr WriteAxiom
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_axiom;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write_axiom = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that writes the ontology footer to an output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="st">Symbol table.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr WriteFooter
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_footer;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write_footer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Defines a writer.</summary>
    public unsafe partial class CowlWriter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal __IntPtr write_ontology;
            internal __IntPtr write;
            internal global::cowl.CowlStreamWriter.__Internal stream;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlWriter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlWriter> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlWriter>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlWriter managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlWriter managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static CowlWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlWriter(native.ToPointer(), skipVTables);
        }

        internal static CowlWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlWriter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlWriter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlWriter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlWriter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlWriter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlWriter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlWriter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlWriter(global::cowl.CowlWriter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlWriter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlWriter.__Internal*) __Instance) = *((global::cowl.CowlWriter.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Name of the writer.</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Pointer to a function that writes an ontology to an output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="onto">Ontology.</param>
        /// <returns>Return code.</returns>
        /// <remarks>
        /// <para>Should only be implemented by writers that either require the ontology object</para>
        /// <para>as a whole, or that can more efficiently encode the ontology if they</para>
        /// <para>have access to it. In all other cases, it is best left unimplemented.</para>
        /// </remarks>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr WriteOntology
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_ontology;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write_ontology = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that writes an object to an output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="object">Object to write.</param>
        /// <returns>Return code.</returns>
        /// <remarks>
        /// <para>Should only be implemented by writers used as default writers</para>
        /// <para>(i.e. passed to{cowl_set_writer()}), so that they are able to write</para>
        /// <para>the string representation of arbitrary objects.</para>
        /// </remarks>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Write
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Contains the streaming implementation of this writer.</summary>
        /// <remarks>This is the preferred implementation for writers.</remarks>
        public global::cowl.CowlStreamWriter Stream
        {
            get
            {
                return global::cowl.CowlStreamWriter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->stream));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->stream = *(global::cowl.CowlStreamWriter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_writer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_writer_can_write_stream@@YA_NPEBUCowlWriter@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlWriterCanWriteStream(__IntPtr writer);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_writer_can_write_object@@YA_NPEBUCowlWriter@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlWriterCanWriteObject(__IntPtr writer);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_writer_can_write_ontology@@YA_NPEBUCowlWriter@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlWriterCanWriteOntology(__IntPtr writer);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlWrite(__IntPtr stream, __IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_debug", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteDebug(__IntPtr stream, __IntPtr @object);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteString(__IntPtr stream, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteIri(__IntPtr stream, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_object_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteObjectType(__IntPtr stream, global::cowl.CowlObjectType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_uint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteUint(__IntPtr stream, uint @uint);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_write_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteError(__IntPtr stream, __IntPtr error);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_write_ustring@@YA?AW4ustream_ret@@PEAUUOStream@@PEBUUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteUstring(__IntPtr stream, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_write_cstring@@YA?AW4ustream_ret@@PEAUUOStream@@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UstreamRet CowlWriteCstring(__IntPtr stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string);
        }

        /// <summary>Checks whether the writer supports stream writing.</summary>
        /// <param name="writer">The writer.</param>
        /// <returns>True if the writer supports stream writing, false otherwise.</returns>
        public static bool CowlWriterCanWriteStream(global::cowl.CowlWriter writer)
        {
            var __arg0 = writer is null ? __IntPtr.Zero : writer.__Instance;
            var ___ret = __Internal.CowlWriterCanWriteStream(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the writer supports writing arbitrary objects.</summary>
        /// <param name="writer">The writer.</param>
        /// <returns>True if the writer supports writing objects, false otherwise.</returns>
        public static bool CowlWriterCanWriteObject(global::cowl.CowlWriter writer)
        {
            var __arg0 = writer is null ? __IntPtr.Zero : writer.__Instance;
            var ___ret = __Internal.CowlWriterCanWriteObject(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the writer has a specialized method to write ontologies.</summary>
        /// <param name="writer">The writer.</param>
        /// <returns>True if the writer has a specialized method to write ontologies, false otherwise.</returns>
        public static bool CowlWriterCanWriteOntology(global::cowl.CowlWriter writer)
        {
            var __arg0 = writer is null ? __IntPtr.Zero : writer.__Instance;
            var ___ret = __Internal.CowlWriterCanWriteOntology(__arg0);
            return ___ret;
        }

        /// <summary>Writes an object to the specified stream via the default writer.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="object">Object.</param>
        /// <returns>Return code.</returns>
        /// <remarks>If no default writer is set, falls back to{#cowl_write_debug()}.</remarks>
        public static global::cowl.CowlRet CowlWrite(global::cowl.UOStream stream, __IntPtr @object)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlWrite(__arg0, @object);
            return ___ret;
        }

        /// <summary>Writes a debug representation of an object to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="object">Object.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteDebug(global::cowl.UOStream stream, __IntPtr @object)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlWriteDebug(__arg0, @object);
            return ___ret;
        }

        /// <summary>Writes a string to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="string">String.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteString(global::cowl.UOStream stream, global::cowl.CowlString @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlWriteString(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Writes an IRI to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="iri">IRI.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteIri(global::cowl.UOStream stream, global::cowl.CowlIRI iri)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlWriteIri(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Writes the object type to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteObjectType(global::cowl.UOStream stream, global::cowl.CowlObjectType type)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlWriteObjectType(__arg0, type);
            return ___ret;
        }

        /// <summary>Writes an unsigned integer to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="uint">Unsigned integer.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteUint(global::cowl.UOStream stream, uint @uint)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlWriteUint(__arg0, @uint);
            return ___ret;
        }

        /// <summary>Writes an human readable representation of an error to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="error">Error.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteError(global::cowl.UOStream stream, global::cowl.CowlError error)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = error is null ? __IntPtr.Zero : error.__Instance;
            var ___ret = __Internal.CowlWriteError(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Writes a string to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="string">String.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteUstring(global::cowl.UOStream stream, global::cowl.UString @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlWriteUstring(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Writes a string to the specified output stream.</summary>
        /// <param name="stream">Output stream.</param>
        /// <param name="string">String.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.UstreamRet CowlWriteCstring(global::cowl.UOStream stream, string @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlWriteCstring(__arg0, @string);
            return ___ret;
        }
    }

    public unsafe partial class cowl_config
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlInit();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_reader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlGetReader(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_set_reader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlSetReader(__IntPtr reader);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_writer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlGetWriter(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_set_writer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlSetWriter(__IntPtr writer);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_error_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlGetErrorHandler(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_set_error_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlSetErrorHandler(__IntPtr handler);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_import_loader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlGetImportLoader(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_set_import_loader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlSetImportLoader(__IntPtr loader);
        }

        /// <summary>Initializes the library.</summary>
        /// <returns>Return code.</returns>
        /// <remarks>It's mandatory to call this function before making any other function call.</remarks>
        public static global::cowl.CowlRet CowlInit()
        {
            var ___ret = __Internal.CowlInit();
            return ___ret;
        }

        /// <summary>Deinitializes the library.</summary>
        /// <remarks>
        /// <para>Calling this function releases any resource loaded when the library was initialized.</para>
        /// <para>You **must not** use objects retrieved before deinitializing the library, even</para>
        /// <para>if you later re-initialize it.</para>
        /// </remarks>
        public static void CowlDeinit()
        {
            __Internal.CowlDeinit();
        }

        /// <summary>Gets the default reader.</summary>
        /// <returns>The default reader.</returns>
        public static global::cowl.CowlReader CowlGetReader()
        {
            var ___ret = new global::cowl.CowlReader.__Internal();
            __Internal.CowlGetReader(new IntPtr(&___ret));
            return global::cowl.CowlReader.__CreateInstance(___ret);
        }

        /// <summary>Sets the default reader.</summary>
        /// <param name="reader">The reader.</param>
        /// <remarks>This function must be called again if you reinitialize library API after deinitializing it.</remarks>
        public static void CowlSetReader(global::cowl.CowlReader reader)
        {
            if (ReferenceEquals(reader, null))
                throw new global::System.ArgumentNullException("reader", "Cannot be null because it is passed by value.");
            var __arg0 = reader.__Instance;
            __Internal.CowlSetReader(__arg0);
        }

        /// <summary>Gets the default writer.</summary>
        /// <returns>The default writer.</returns>
        public static global::cowl.CowlWriter CowlGetWriter()
        {
            var ___ret = new global::cowl.CowlWriter.__Internal();
            __Internal.CowlGetWriter(new IntPtr(&___ret));
            return global::cowl.CowlWriter.__CreateInstance(___ret);
        }

        /// <summary>Sets the default writer.</summary>
        /// <param name="writer">The writer.</param>
        /// <remarks>This function must be called again if you reinitialize the library after deinitializing it.</remarks>
        public static void CowlSetWriter(global::cowl.CowlWriter writer)
        {
            if (ReferenceEquals(writer, null))
                throw new global::System.ArgumentNullException("writer", "Cannot be null because it is passed by value.");
            var __arg0 = writer.__Instance;
            __Internal.CowlSetWriter(__arg0);
        }

        /// <summary>Gets the global error handler.</summary>
        /// <returns>The global error handler.</returns>
        public static global::cowl.CowlErrorHandler CowlGetErrorHandler()
        {
            var ___ret = new global::cowl.CowlErrorHandler.__Internal();
            __Internal.CowlGetErrorHandler(new IntPtr(&___ret));
            return global::cowl.CowlErrorHandler.__CreateInstance(___ret);
        }

        /// <summary>Sets the global error handler.</summary>
        /// <param name="handler">The error handler.</param>
        /// <remarks>This function must be called again if you reinitialize the library after deinitializing it.</remarks>
        public static void CowlSetErrorHandler(global::cowl.CowlErrorHandler handler)
        {
            if (ReferenceEquals(handler, null))
                throw new global::System.ArgumentNullException("handler", "Cannot be null because it is passed by value.");
            var __arg0 = handler.__Instance;
            __Internal.CowlSetErrorHandler(__arg0);
        }

        /// <summary>Gets the global import loader.</summary>
        /// <returns>The global import loader.</returns>
        public static global::cowl.CowlImportLoader CowlGetImportLoader()
        {
            var ___ret = new global::cowl.CowlImportLoader.__Internal();
            __Internal.CowlGetImportLoader(new IntPtr(&___ret));
            return global::cowl.CowlImportLoader.__CreateInstance(___ret);
        }

        /// <summary>Sets the global import loader.</summary>
        /// <param name="loader">The import loader.</param>
        /// <remarks>This function must be called again if you reinitialize the library after deinitializing it.</remarks>
        public static void CowlSetImportLoader(global::cowl.CowlImportLoader loader)
        {
            if (ReferenceEquals(loader, null))
                throw new global::System.ArgumentNullException("loader", "Cannot be null because it is passed by value.");
            var __arg0 = loader.__Instance;
            __Internal.CowlSetImportLoader(__arg0);
        }
    }

    public unsafe partial class CowlDataRange
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataRange> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataRange>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataRange managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataRange managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataRange(native.ToPointer(), skipVTables);
        }

        internal static CowlDataRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlDataPropExp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropExp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropExp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataPropExp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataPropExp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataPropExp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataPropExp(native.ToPointer(), skipVTables);
        }

        internal static CowlDataPropExp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataPropExp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataPropExp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataPropExp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataPropExp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataPropExp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlDataCard
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataCard> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataCard>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataCard managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataCard managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataCard __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataCard(native.ToPointer(), skipVTables);
        }

        internal static CowlDataCard __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataCard)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataCard __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataCard(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataCard(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataCard(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_card
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_card", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataCard(global::cowl.CowlCardType type, __IntPtr prop, __IntPtr range, uint cardinality);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_card_get_type@@YA?AW4CowlCardType@@PEAUCowlDataCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlCardType CowlDataCardGetType(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_card_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlDataCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataCardGetProp(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_card_get_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataCardGetRange(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_card_get_cardinality@@YAIPEAUCowlDataCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlDataCardGetCardinality(__IntPtr restr);
        }

        /// <summary>Returns a data property cardinality restriction.</summary>
        /// <param name="type">The type.</param>
        /// <param name="prop">The data property.</param>
        /// <param name="range">{optional} Range of the restriction.</param>
        /// <param name="cardinality">Cardinality of the restriction.</param>
        /// <returns>Restriction, or NULL on error.</returns>
        public static global::cowl.CowlDataCard CowlDataCard(global::cowl.CowlCardType type, __IntPtr prop, __IntPtr range, uint cardinality)
        {
            var ___ret = __Internal.CowlDataCard(type, prop, range, cardinality);
            var __result0 = global::cowl.CowlDataCard.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified data property cardinality restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlCardType CowlDataCardGetType(global::cowl.CowlDataCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataCardGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the property of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataCardGetProp(global::cowl.CowlDataCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataCardGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The range.</returns>
        public static global::cowl.CowlDataRange CowlDataCardGetRange(global::cowl.CowlDataCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataCardGetRange(__arg0);
            var __result0 = global::cowl.CowlDataRange.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the cardinality of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The cardinality.</returns>
        public static uint CowlDataCardGetCardinality(global::cowl.CowlDataCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataCardGetCardinality(__arg0);
            return ___ret;
        }
    }

    public unsafe partial class CowlDataCompl
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataCompl> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataCompl>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataCompl managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataCompl managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataCompl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataCompl(native.ToPointer(), skipVTables);
        }

        internal static CowlDataCompl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataCompl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataCompl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataCompl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataCompl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataCompl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_compl
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_compl@@YAPEAUCowlDataCompl@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataCompl(__IntPtr operand);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_compl_get_operand@@YAPEAUCowlDataRange@@PEAUCowlDataCompl@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataComplGetOperand(__IntPtr range);
        }

        /// <summary>Returns the complement of a data range.</summary>
        /// <param name="operand">The data range which this data range is a complement of.</param>
        /// <returns>Data range complement, or NULL on error.</returns>
        public static global::cowl.CowlDataCompl CowlDataCompl(__IntPtr operand)
        {
            var ___ret = __Internal.CowlDataCompl(operand);
            var __result0 = global::cowl.CowlDataCompl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the data range which this data range is a complement of.</summary>
        /// <param name="range">The data range complement.</param>
        /// <returns>The operand.</returns>
        public static global::cowl.CowlDataRange CowlDataComplGetOperand(global::cowl.CowlDataCompl range)
        {
            var __arg0 = range is null ? __IntPtr.Zero : range.__Instance;
            var ___ret = __Internal.CowlDataComplGetOperand(__arg0);
            var __result0 = global::cowl.CowlDataRange.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataHasValue
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataHasValue> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataHasValue>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataHasValue managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataHasValue managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataHasValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataHasValue(native.ToPointer(), skipVTables);
        }

        internal static CowlDataHasValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataHasValue)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataHasValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataHasValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataHasValue(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataHasValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_has_value
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_has_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataHasValue(__IntPtr prop, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_has_value_get_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataHasValueGetProp(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_has_value_get_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataHasValueGetValue(__IntPtr restr);
        }

        /// <summary>Returns a literal value restriction.</summary>
        /// <param name="prop">The data property expression.</param>
        /// <param name="value">The restriction value.</param>
        /// <returns>Restriction, or NULL on error.</returns>
        public static global::cowl.CowlDataHasValue CowlDataHasValue(__IntPtr prop, global::cowl.CowlLiteral value)
        {
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            var ___ret = __Internal.CowlDataHasValue(prop, __arg1);
            var __result0 = global::cowl.CowlDataHasValue.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the property of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataHasValueGetProp(global::cowl.CowlDataHasValue restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataHasValueGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the value of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The value.</returns>
        public static global::cowl.CowlLiteral CowlDataHasValueGetValue(global::cowl.CowlDataHasValue restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataHasValueGetValue(__arg0);
            var __result0 = global::cowl.CowlLiteral.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataOneOf
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataOneOf> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataOneOf>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataOneOf managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataOneOf managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataOneOf __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataOneOf(native.ToPointer(), skipVTables);
        }

        internal static CowlDataOneOf __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataOneOf)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataOneOf __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataOneOf(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataOneOf(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataOneOf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_one_of
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_one_of", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataOneOf(__IntPtr values);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_one_of_get_values", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataOneOfGetValues(__IntPtr range);
        }

        /// <summary>Returns a literal enumeration.</summary>
        /// <param name="values">The enumeration values.</param>
        /// <returns>Literal enumeration, or NULL on error.</returns>
        public static global::cowl.CowlDataOneOf CowlDataOneOf(global::cowl.CowlVector values)
        {
            var __arg0 = values is null ? __IntPtr.Zero : values.__Instance;
            var ___ret = __Internal.CowlDataOneOf(__arg0);
            var __result0 = global::cowl.CowlDataOneOf.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the values of the specified literal enumeration.</summary>
        /// <param name="range">The literal enumeration.</param>
        /// <returns>The values.</returns>
        public static global::cowl.CowlVector CowlDataOneOfGetValues(global::cowl.CowlDataOneOf range)
        {
            var __arg0 = range is null ? __IntPtr.Zero : range.__Instance;
            var ___ret = __Internal.CowlDataOneOfGetValues(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataProp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataProp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataProp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataProp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataProp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataProp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataProp(native.ToPointer(), skipVTables);
        }

        internal static CowlDataProp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataProp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataProp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataProp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataProp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataProp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_prop
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataProp(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop_get_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropGetIri(__IntPtr prop);
        }

        /// <summary>Returns a data property.</summary>
        /// <param name="iri">IRI of the data property.</param>
        /// <returns>Data property, or NULL on error.</returns>
        public static global::cowl.CowlDataProp CowlDataProp(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlDataProp(__arg0);
            var __result0 = global::cowl.CowlDataProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a data property given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Data property, or NULL on error.</returns>
        public static global::cowl.CowlDataProp CowlDataPropFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlDataPropFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlDataProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the specified data property.</summary>
        /// <param name="prop">The data property.</param>
        /// <returns>The IRI.</returns>
        public static global::cowl.CowlIRI CowlDataPropGetIri(global::cowl.CowlDataProp prop)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var ___ret = __Internal.CowlDataPropGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataPropAssertAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropAssertAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropAssertAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataPropAssertAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataPropAssertAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataPropAssertAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataPropAssertAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDataPropAssertAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataPropAssertAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataPropAssertAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataPropAssertAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataPropAssertAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataPropAssertAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_prop_assert_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop_assert_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropAssertAxiom(__IntPtr prop, __IntPtr subj, __IntPtr obj, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_neg_data_prop_assert_axiom@@YAPEAUCowlDataPropAssertAxiom@@PEAX0PEAUCowlLiteral@@PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNegDataPropAssertAxiom(__IntPtr prop, __IntPtr subj, __IntPtr obj, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_assert_axiom_is_negative@@YA_NPEAUCowlDataPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlDataPropAssertAxiomIsNegative(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_assert_axiom_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlDataPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropAssertAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_assert_axiom_get_subject@@YAPEAUCowlIndividual@@PEAUCowlDataPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropAssertAxiomGetSubject(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_assert_axiom_get_object@@YAPEAUCowlLiteral@@PEAUCowlDataPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropAssertAxiomGetObject(__IntPtr axiom);
        }

        /// <summary>Returns a data property assertion axiom.</summary>
        /// <param name="prop">The data property.</param>
        /// <param name="subj">The assertion subject.</param>
        /// <param name="obj">The assertion object.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDataPropAssertAxiom CowlDataPropAssertAxiom(__IntPtr prop, __IntPtr subj, global::cowl.CowlLiteral obj, global::cowl.CowlVector annot)
        {
            var __arg2 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDataPropAssertAxiom(prop, subj, __arg2, __arg3);
            var __result0 = global::cowl.CowlDataPropAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a negative data property assertion axiom.</summary>
        /// <param name="subj">The assertion subject.</param>
        /// <param name="prop">The data property.</param>
        /// <param name="obj">The assertion object.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDataPropAssertAxiom CowlNegDataPropAssertAxiom(__IntPtr prop, __IntPtr subj, global::cowl.CowlLiteral obj, global::cowl.CowlVector annot)
        {
            var __arg2 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNegDataPropAssertAxiom(prop, subj, __arg2, __arg3);
            var __result0 = global::cowl.CowlDataPropAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns true if the specified data property assertion axiom is negative.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>True if the assertion is negative, false otherwise.</returns>
        public static bool CowlDataPropAssertAxiomIsNegative(global::cowl.CowlDataPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropAssertAxiomIsNegative(__arg0);
            return ___ret;
        }

        /// <summary>Gets the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataPropAssertAxiomGetProp(global::cowl.CowlDataPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropAssertAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the assertion subject.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The assertion subject.</returns>
        public static global::cowl.CowlIndividual CowlDataPropAssertAxiomGetSubject(global::cowl.CowlDataPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropAssertAxiomGetSubject(__arg0);
            var __result0 = global::cowl.CowlIndividual.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the assertion object.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The assertion object.</returns>
        public static global::cowl.CowlLiteral CowlDataPropAssertAxiomGetObject(global::cowl.CowlDataPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropAssertAxiomGetObject(__arg0);
            var __result0 = global::cowl.CowlLiteral.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataPropDomainAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropDomainAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropDomainAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataPropDomainAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataPropDomainAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataPropDomainAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataPropDomainAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDataPropDomainAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataPropDomainAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataPropDomainAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataPropDomainAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataPropDomainAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataPropDomainAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_prop_domain_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop_domain_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropDomainAxiom(__IntPtr prop, __IntPtr domain, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_domain_axiom_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlDataPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropDomainAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_domain_axiom_get_domain@@YAPEAUCowlClsExp@@PEAUCowlDataPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropDomainAxiomGetDomain(__IntPtr axiom);
        }

        /// <summary>Returns a data property domain axiom.</summary>
        /// <param name="prop">The data property.</param>
        /// <param name="domain">Domain of the data property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDataPropDomainAxiom CowlDataPropDomainAxiom(__IntPtr prop, __IntPtr domain, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDataPropDomainAxiom(prop, domain, __arg2);
            var __result0 = global::cowl.CowlDataPropDomainAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataPropDomainAxiomGetProp(global::cowl.CowlDataPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropDomainAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the domain of the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Domain of the data property.</returns>
        public static global::cowl.CowlClsExp CowlDataPropDomainAxiomGetDomain(global::cowl.CowlDataPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropDomainAxiomGetDomain(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class cowl_data_prop_exp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_exp_get_prop@@YAPEAUCowlDataProp@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropExpGetProp(__IntPtr exp);
        }

        /// <summary>Gets the underlying data property.</summary>
        /// <param name="exp">The data property expression.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataProp CowlDataPropExpGetProp(__IntPtr exp)
        {
            var ___ret = __Internal.CowlDataPropExpGetProp(exp);
            var __result0 = global::cowl.CowlDataProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDataPropRangeAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropRangeAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataPropRangeAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataPropRangeAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataPropRangeAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataPropRangeAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataPropRangeAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDataPropRangeAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataPropRangeAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataPropRangeAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataPropRangeAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataPropRangeAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataPropRangeAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_prop_range_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_prop_range_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropRangeAxiom(__IntPtr prop, __IntPtr range, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_range_axiom_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlDataPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropRangeAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_prop_range_axiom_get_range@@YAPEAUCowlDataRange@@PEAUCowlDataPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataPropRangeAxiomGetRange(__IntPtr axiom);
        }

        /// <summary>Returns a data property range axiom.</summary>
        /// <param name="prop">The data property.</param>
        /// <param name="range">Range of the data property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDataPropRangeAxiom CowlDataPropRangeAxiom(__IntPtr prop, __IntPtr range, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDataPropRangeAxiom(prop, range, __arg2);
            var __result0 = global::cowl.CowlDataPropRangeAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataPropRangeAxiomGetProp(global::cowl.CowlDataPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropRangeAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Range of the data property.</returns>
        public static global::cowl.CowlDataRange CowlDataPropRangeAxiomGetRange(global::cowl.CowlDataPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDataPropRangeAxiomGetRange(__arg0);
            var __result0 = global::cowl.CowlDataRange.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type ofand</summary>
    public enum CowlQuantType
    {
        /// <summary>Existential quantifier (SomeValuesFrom).</summary>
        COWL_QT_SOME = 0,
        /// <summary>Universal quantifier (AllValuesFrom).</summary>
        COWL_QT_ALL = 1,
        /// <summary>Number of enum values.</summary>
        COWL_QT_COUNT = 2,
        /// <summary>First enum value.</summary>
        COWL_QT_FIRST = 0
    }

    /// <summary>Represents the type ofand</summary>
    public unsafe partial class CowlDataQuant
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataQuant> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDataQuant>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDataQuant managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDataQuant managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDataQuant __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDataQuant(native.ToPointer(), skipVTables);
        }

        internal static CowlDataQuant __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDataQuant)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDataQuant __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDataQuant(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDataQuant(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDataQuant(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_quant
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_quant", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataQuant(global::cowl.CowlQuantType type, __IntPtr prop, __IntPtr range);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_quant_get_type@@YA?AW4CowlQuantType@@PEAUCowlDataQuant@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlQuantType CowlDataQuantGetType(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_quant_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlDataQuant@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataQuantGetProp(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_data_quant_get_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDataQuantGetRange(__IntPtr restr);
        }

        /// <summary>Returns a data quantifier.</summary>
        /// <param name="type">Data quantifier type.</param>
        /// <param name="prop">The data property.</param>
        /// <param name="range">Range of the quantifier.</param>
        /// <returns>Data quantifier, or NULL on error.</returns>
        public static global::cowl.CowlDataQuant CowlDataQuant(global::cowl.CowlQuantType type, __IntPtr prop, __IntPtr range)
        {
            var ___ret = __Internal.CowlDataQuant(type, prop, range);
            var __result0 = global::cowl.CowlDataQuant.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified data quantifier.</summary>
        /// <param name="restr">The data quantifier.</param>
        /// <returns>The type of the data quantifier.</returns>
        public static global::cowl.CowlQuantType CowlDataQuantGetType(global::cowl.CowlDataQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataQuantGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the data property.</summary>
        /// <param name="restr">The data quantifier.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataPropExp CowlDataQuantGetProp(global::cowl.CowlDataQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataQuantGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the specified data quantifier.</summary>
        /// <param name="restr">The data quantifier.</param>
        /// <returns>Range of the data quantifier.</returns>
        public static global::cowl.CowlDataRange CowlDataQuantGetRange(global::cowl.CowlDataQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDataQuantGetRange(__arg0);
            var __result0 = global::cowl.CowlDataRange.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Represents the type of</summary>
    public enum CowlDataRangeType
    {
        /// <summary>- Datatype.</summary>
        COWL_DRT_DATATYPE = 0,
        /// <summary>- Datatype restriction.</summary>
        COWL_DRT_DATATYPE_RESTR = 1,
        /// <summary>- Intersection of data ranges.</summary>
        COWL_DRT_DATA_INTERSECT = 2,
        /// <summary>- Union of data ranges.</summary>
        COWL_DRT_DATA_UNION = 3,
        /// <summary>- Complement of data ranges.</summary>
        COWL_DRT_DATA_COMPL = 4,
        /// <summary>- Enumeration of literals.</summary>
        COWL_DRT_DATA_ONE_OF = 5,
        /// <summary>Number of enum values.</summary>
        COWL_DRT_COUNT = 6,
        /// <summary>First enum value.</summary>
        COWL_DRT_FIRST = 0
    }

    /// <summary>Represents the type of</summary>
    public unsafe partial class CowlObjPropExp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropExp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropExp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjPropExp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjPropExp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjPropExp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjPropExp(native.ToPointer(), skipVTables);
        }

        internal static CowlObjPropExp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjPropExp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjPropExp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjPropExp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjPropExp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjPropExp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_data_range
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_data_range_get_type@@YA?AW4CowlDataRangeType@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlDataRangeType CowlDataRangeGetType(__IntPtr range);
        }

        /// <summary>Gets the type of the specified data range.</summary>
        /// <param name="range">The data range.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlDataRangeType CowlDataRangeGetType(__IntPtr range)
        {
            var ___ret = __Internal.CowlDataRangeGetType(range);
            return ___ret;
        }
    }

    public unsafe partial class CowlDatatype
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatype> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatype>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDatatype managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDatatype managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDatatype __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDatatype(native.ToPointer(), skipVTables);
        }

        internal static CowlDatatype __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDatatype)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDatatype __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDatatype(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDatatype(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDatatype(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_datatype
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_datatype", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatype(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_datatype_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_get_iri@@YAPEAUCowlIRI@@PEAUCowlDatatype@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeGetIri(__IntPtr dt);
        }

        /// <summary>Returns a datatype.</summary>
        /// <param name="iri">IRI of the datatype.</param>
        /// <returns>Datatype, or NULL on error.</returns>
        public static global::cowl.CowlDatatype CowlDatatype(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlDatatype(__arg0);
            var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a datatype given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Datatype, or NULL on error.</returns>
        public static global::cowl.CowlDatatype CowlDatatypeFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlDatatypeFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the specified datatype.</summary>
        /// <param name="dt">The datatype.</param>
        /// <returns>The IRI.</returns>
        public static global::cowl.CowlIRI CowlDatatypeGetIri(global::cowl.CowlDatatype dt)
        {
            var __arg0 = dt is null ? __IntPtr.Zero : dt.__Instance;
            var ___ret = __Internal.CowlDatatypeGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDatatypeDefAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatypeDefAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatypeDefAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDatatypeDefAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDatatypeDefAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDatatypeDefAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDatatypeDefAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDatatypeDefAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDatatypeDefAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDatatypeDefAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDatatypeDefAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDatatypeDefAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDatatypeDefAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_datatype_def_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_def_axiom@@YAPEAUCowlDatatypeDefAxiom@@PEAUCowlDatatype@@PEAXPEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeDefAxiom(__IntPtr dt, __IntPtr range, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_def_axiom_get_datatype@@YAPEAUCowlDatatype@@PEAUCowlDatatypeDefAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeDefAxiomGetDatatype(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_def_axiom_get_range@@YAPEAUCowlDataRange@@PEAUCowlDatatypeDefAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeDefAxiomGetRange(__IntPtr axiom);
        }

        /// <summary>Returns a datatype definition axiom.</summary>
        /// <param name="dt">The defined datatype.</param>
        /// <param name="range">Range of the defined datatype.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDatatypeDefAxiom CowlDatatypeDefAxiom(global::cowl.CowlDatatype dt, __IntPtr range, global::cowl.CowlVector annot)
        {
            var __arg0 = dt is null ? __IntPtr.Zero : dt.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDatatypeDefAxiom(__arg0, range, __arg2);
            var __result0 = global::cowl.CowlDatatypeDefAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the defined datatype.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The datatype.</returns>
        public static global::cowl.CowlDatatype CowlDatatypeDefAxiomGetDatatype(global::cowl.CowlDatatypeDefAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDatatypeDefAxiomGetDatatype(__arg0);
            var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the defined datatype.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The range.</returns>
        public static global::cowl.CowlDataRange CowlDatatypeDefAxiomGetRange(global::cowl.CowlDatatypeDefAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDatatypeDefAxiomGetRange(__arg0);
            var __result0 = global::cowl.CowlDataRange.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDatatypeRestr
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatypeRestr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDatatypeRestr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDatatypeRestr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDatatypeRestr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDatatypeRestr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDatatypeRestr(native.ToPointer(), skipVTables);
        }

        internal static CowlDatatypeRestr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDatatypeRestr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDatatypeRestr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDatatypeRestr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDatatypeRestr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDatatypeRestr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_datatype_restr
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_datatype_restr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeRestr(__IntPtr datatype, __IntPtr restrictions);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_restr_get_datatype@@YAPEAUCowlDatatype@@PEAUCowlDatatypeRestr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeRestrGetDatatype(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_datatype_restr_get_restrictions@@YAPEAUCowlVector@@PEAUCowlDatatypeRestr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDatatypeRestrGetRestrictions(__IntPtr restr);
        }

        /// <summary>Returns a datatype restriction.</summary>
        /// <param name="datatype">The datatype that this data range restricts.</param>
        /// <param name="restrictions">Set of facet restrictions.</param>
        /// <returns>Datatype restriction, or NULL on error.</returns>
        public static global::cowl.CowlDatatypeRestr CowlDatatypeRestr(global::cowl.CowlDatatype datatype, global::cowl.CowlVector restrictions)
        {
            var __arg0 = datatype is null ? __IntPtr.Zero : datatype.__Instance;
            var __arg1 = restrictions is null ? __IntPtr.Zero : restrictions.__Instance;
            var ___ret = __Internal.CowlDatatypeRestr(__arg0, __arg1);
            var __result0 = global::cowl.CowlDatatypeRestr.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the datatype that this data range restricts.</summary>
        /// <param name="restr">The datatype restriction.</param>
        /// <returns>The datatype.</returns>
        public static global::cowl.CowlDatatype CowlDatatypeRestrGetDatatype(global::cowl.CowlDatatypeRestr restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDatatypeRestrGetDatatype(__arg0);
            var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the facet restrictions.</summary>
        /// <param name="restr">The datatype restriction.</param>
        /// <returns>The facet restrictions.</returns>
        public static global::cowl.CowlVector CowlDatatypeRestrGetRestrictions(global::cowl.CowlDatatypeRestr restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlDatatypeRestrGetRestrictions(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDeclAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDeclAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDeclAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDeclAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDeclAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDeclAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDeclAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDeclAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDeclAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDeclAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDeclAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDeclAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDeclAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_decl_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_decl_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDeclAxiom(__IntPtr entity, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_decl_axiom_get_entity@@YAPEAUCowlEntity@@PEAUCowlDeclAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDeclAxiomGetEntity(__IntPtr axiom);
        }

        /// <summary>Returns a declaration axiom.</summary>
        /// <param name="entity">The declared entity.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDeclAxiom CowlDeclAxiom(__IntPtr entity, global::cowl.CowlVector annot)
        {
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDeclAxiom(entity, __arg1);
            var __result0 = global::cowl.CowlDeclAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the declared entity.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The entity.</returns>
        public static global::cowl.CowlEntity CowlDeclAxiomGetEntity(global::cowl.CowlDeclAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDeclAxiomGetEntity(__arg0);
            var __result0 = global::cowl.CowlEntity.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlDisjUnionAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDisjUnionAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlDisjUnionAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlDisjUnionAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlDisjUnionAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlDisjUnionAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlDisjUnionAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlDisjUnionAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlDisjUnionAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlDisjUnionAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlDisjUnionAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlDisjUnionAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlDisjUnionAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_disj_union_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_disj_union_axiom@@YAPEAUCowlDisjUnionAxiom@@PEAUCowlClass@@PEAUCowlVector@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDisjUnionAxiom(__IntPtr cls, __IntPtr disjoints, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_disj_union_axiom_get_class@@YAPEAUCowlClass@@PEAUCowlDisjUnionAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDisjUnionAxiomGetClass(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_disj_union_axiom_get_disjoints@@YAPEAUCowlVector@@PEAUCowlDisjUnionAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlDisjUnionAxiomGetDisjoints(__IntPtr axiom);
        }

        /// <summary>Returns a disjoint union axiom.</summary>
        /// <param name="cls">The class which is equivalent to the disjoint union.</param>
        /// <param name="disjoints">The class expressions which are operands of the disjoint union.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlDisjUnionAxiom CowlDisjUnionAxiom(global::cowl.CowlClass cls, global::cowl.CowlVector disjoints, global::cowl.CowlVector annot)
        {
            var __arg0 = cls is null ? __IntPtr.Zero : cls.__Instance;
            var __arg1 = disjoints is null ? __IntPtr.Zero : disjoints.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlDisjUnionAxiom(__arg0, __arg1, __arg2);
            var __result0 = global::cowl.CowlDisjUnionAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the class which is equivalent to the disjoint union.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The class.</returns>
        public static global::cowl.CowlClass CowlDisjUnionAxiomGetClass(global::cowl.CowlDisjUnionAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDisjUnionAxiomGetClass(__arg0);
            var __result0 = global::cowl.CowlClass.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the class expressions which are operands of the disjoint union.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The class expressions.</returns>
        public static global::cowl.CowlVector CowlDisjUnionAxiomGetDisjoints(global::cowl.CowlDisjUnionAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlDisjUnionAxiomGetDisjoints(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlFacetRestr
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFacetRestr> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFacetRestr>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlFacetRestr managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlFacetRestr managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlFacetRestr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlFacetRestr(native.ToPointer(), skipVTables);
        }

        internal static CowlFacetRestr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlFacetRestr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlFacetRestr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlFacetRestr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlFacetRestr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlFacetRestr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_facet_restr
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_facet_restr@@YAPEAUCowlFacetRestr@@PEAUCowlIRI@@PEAUCowlLiteral@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlFacetRestr(__IntPtr facet, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_facet_restr_get_facet@@YAPEAUCowlIRI@@PEAUCowlFacetRestr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlFacetRestrGetFacet(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_facet_restr_get_value@@YAPEAUCowlLiteral@@PEAUCowlFacetRestr@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlFacetRestrGetValue(__IntPtr restr);
        }

        /// <summary>Returns a facet restriction.</summary>
        /// <param name="facet">The facet.</param>
        /// <param name="value">The restriction value.</param>
        /// <returns>Facet restriction, or NULL on error.</returns>
        public static global::cowl.CowlFacetRestr CowlFacetRestr(global::cowl.CowlIRI facet, global::cowl.CowlLiteral value)
        {
            var __arg0 = facet is null ? __IntPtr.Zero : facet.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            var ___ret = __Internal.CowlFacetRestr(__arg0, __arg1);
            var __result0 = global::cowl.CowlFacetRestr.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the facet.</summary>
        /// <param name="restr">The facet restriction.</param>
        /// <returns>The facet.</returns>
        public static global::cowl.CowlIRI CowlFacetRestrGetFacet(global::cowl.CowlFacetRestr restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlFacetRestrGetFacet(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the restriction value.</summary>
        /// <param name="restr">The facet restriction.</param>
        /// <returns>The restriction value.</returns>
        public static global::cowl.CowlLiteral CowlFacetRestrGetValue(global::cowl.CowlFacetRestr restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlFacetRestrGetValue(__arg0);
            var __result0 = global::cowl.CowlLiteral.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlFuncDataPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFuncDataPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlFuncDataPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlFuncDataPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlFuncDataPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlFuncDataPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlFuncDataPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlFuncDataPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlFuncDataPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlFuncDataPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlFuncDataPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlFuncDataPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlFuncDataPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_func_data_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_func_data_prop_axiom@@YAPEAUCowlFuncDataPropAxiom@@PEAXPEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlFuncDataPropAxiom(__IntPtr prop, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_func_data_prop_axiom_get_prop@@YAPEAUCowlDataPropExp@@PEAUCowlFuncDataPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlFuncDataPropAxiomGetProp(__IntPtr axiom);
        }

        /// <summary>Returns a functional data property axiom.</summary>
        /// <param name="prop">The data property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlFuncDataPropAxiom CowlFuncDataPropAxiom(__IntPtr prop, global::cowl.CowlVector annot)
        {
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlFuncDataPropAxiom(prop, __arg1);
            var __result0 = global::cowl.CowlFuncDataPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the data property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data property.</returns>
        public static global::cowl.CowlDataPropExp CowlFuncDataPropAxiomGetProp(global::cowl.CowlFuncDataPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlFuncDataPropAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlHasKeyAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlHasKeyAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlHasKeyAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlHasKeyAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlHasKeyAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlHasKeyAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlHasKeyAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlHasKeyAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlHasKeyAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlHasKeyAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlHasKeyAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlHasKeyAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlHasKeyAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_has_key_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_has_key_axiom@@YAPEAUCowlHasKeyAxiom@@PEAXPEAUCowlVector@@11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlHasKeyAxiom(__IntPtr cls_exp, __IntPtr obj_props, __IntPtr data_props, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_has_key_axiom_get_cls_exp@@YAPEAUCowlClsExp@@PEAUCowlHasKeyAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlHasKeyAxiomGetClsExp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_has_key_axiom_get_obj_props@@YAPEAUCowlVector@@PEAUCowlHasKeyAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlHasKeyAxiomGetObjProps(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_has_key_axiom_get_data_props@@YAPEAUCowlVector@@PEAUCowlHasKeyAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlHasKeyAxiomGetDataProps(__IntPtr axiom);
        }

        /// <summary>Returns a 'has key' axiom.</summary>
        /// <param name="cls_exp">The class expression, instances of which this axiom acts as the key for.</param>
        /// <param name="obj_props">Object property expressions that make up the key.</param>
        /// <param name="data_props">Data property expressions that make up the key.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlHasKeyAxiom CowlHasKeyAxiom(__IntPtr cls_exp, global::cowl.CowlVector obj_props, global::cowl.CowlVector data_props, global::cowl.CowlVector annot)
        {
            var __arg1 = obj_props is null ? __IntPtr.Zero : obj_props.__Instance;
            var __arg2 = data_props is null ? __IntPtr.Zero : data_props.__Instance;
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlHasKeyAxiom(cls_exp, __arg1, __arg2, __arg3);
            var __result0 = global::cowl.CowlHasKeyAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the class expression, instances of which this axiom acts as the key for.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The class expression.</returns>
        public static global::cowl.CowlClsExp CowlHasKeyAxiomGetClsExp(global::cowl.CowlHasKeyAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlHasKeyAxiomGetClsExp(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the set of object property expressions that make up the key.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object property expressions.</returns>
        public static global::cowl.CowlVector CowlHasKeyAxiomGetObjProps(global::cowl.CowlHasKeyAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlHasKeyAxiomGetObjProps(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the set of data property expressions that make up the key.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data property expressions.</returns>
        public static global::cowl.CowlVector CowlHasKeyAxiomGetDataProps(global::cowl.CowlHasKeyAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlHasKeyAxiomGetDataProps(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class cowl_individual
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_individual_is_named@@YA_NPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIndividualIsNamed(__IntPtr ind);
        }

        /// <summary>Returns true if the underlying individual is named.</summary>
        /// <param name="ind">The individual.</param>
        /// <returns>True if the underlying individual is named, false otherwise.</returns>
        public static bool CowlIndividualIsNamed(__IntPtr ind)
        {
            var ___ret = __Internal.CowlIndividualIsNamed(ind);
            return ___ret;
        }
    }

    public unsafe partial class CowlObjProp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjProp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjProp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjProp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjProp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjProp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjProp(native.ToPointer(), skipVTables);
        }

        internal static CowlObjProp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjProp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjProp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjProp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjProp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjProp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class CowlInvObjProp
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlInvObjProp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlInvObjProp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlInvObjProp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlInvObjProp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlInvObjProp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlInvObjProp(native.ToPointer(), skipVTables);
        }

        internal static CowlInvObjProp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlInvObjProp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlInvObjProp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlInvObjProp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlInvObjProp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlInvObjProp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_inv_obj_prop
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_inv_obj_prop@@YAPEAUCowlInvObjProp@@PEAUCowlObjProp@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlInvObjProp(__IntPtr prop);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_inv_obj_prop_get_prop@@YAPEAUCowlObjProp@@PEAUCowlInvObjProp@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlInvObjPropGetProp(__IntPtr inv);
        }

        /// <summary>Returns an inverse object property.</summary>
        /// <param name="prop">The object property of which the expression is the inverse of.</param>
        /// <returns>Inverse object property, or NULL on error.</returns>
        public static global::cowl.CowlInvObjProp CowlInvObjProp(global::cowl.CowlObjProp prop)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var ___ret = __Internal.CowlInvObjProp(__arg0);
            var __result0 = global::cowl.CowlInvObjProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the property of which the expression is the inverse of.</summary>
        /// <param name="inv">The inverse object property.</param>
        /// <returns>The property.</returns>
        public static global::cowl.CowlObjProp CowlInvObjPropGetProp(global::cowl.CowlInvObjProp inv)
        {
            var __arg0 = inv is null ? __IntPtr.Zero : inv.__Instance;
            var ___ret = __Internal.CowlInvObjPropGetProp(__arg0);
            var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlInvObjPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlInvObjPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlInvObjPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlInvObjPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlInvObjPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlInvObjPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlInvObjPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlInvObjPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlInvObjPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlInvObjPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlInvObjPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlInvObjPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlInvObjPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_inv_obj_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_inv_obj_prop_axiom@@YAPEAUCowlInvObjPropAxiom@@PEAX0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlInvObjPropAxiom(__IntPtr first, __IntPtr second, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_inv_obj_prop_axiom_get_first_prop@@YAPEAUCowlObjPropExp@@PEAUCowlInvObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlInvObjPropAxiomGetFirstProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_inv_obj_prop_axiom_get_second_prop@@YAPEAUCowlObjPropExp@@PEAUCowlInvObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlInvObjPropAxiomGetSecondProp(__IntPtr axiom);
        }

        /// <summary>Returns an inverse object properties axiom.</summary>
        /// <param name="first">The first object property expression.</param>
        /// <param name="second">The second object property expression.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlInvObjPropAxiom CowlInvObjPropAxiom(__IntPtr first, __IntPtr second, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlInvObjPropAxiom(first, second, __arg2);
            var __result0 = global::cowl.CowlInvObjPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the first of the two object property expressions.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The first object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlInvObjPropAxiomGetFirstProp(global::cowl.CowlInvObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlInvObjPropAxiomGetFirstProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the second of the two object property expressions.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The second object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlInvObjPropAxiomGetSecondProp(global::cowl.CowlInvObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlInvObjPropAxiomGetSecondProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>String creation options.</summary>
    /// <remarks>
    /// <para>{#cowl_string_opt()}</para>
    /// <para>typedef UBit(N) CowlStringOpts;</para>
    /// </remarks>
    public unsafe partial class cowl_string
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_opt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringOpt(global::cowl.UString.__Internal @string, byte opts);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_empty", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringEmpty();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_intern", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringIntern(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_release_copying_raw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UString.__Internal CowlStringReleaseCopyingRaw(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_release_copying_cstring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* CowlStringReleaseCopyingCstring(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_get_cstring", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringGetCstring(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_get_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlStringGetLength(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_get_raw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringGetRaw(__IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_with_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringWithFormat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_string_concat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlStringConcat(__IntPtr lhs, __IntPtr rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_string_to_int@@YA?AW4cowl_ret@@PEAUCowlString@@PEAHI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlStringToInt(__IntPtr @string, int* @out, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_string_to_uint@@YA?AW4cowl_ret@@PEAUCowlString@@PEAII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlStringToUint(__IntPtr @string, uint* @out, uint @base);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_string_to_float@@YA?AW4cowl_ret@@PEAUCowlString@@PEAN@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlStringToFloat(__IntPtr @string, double* @out);
        }

        /// <summary>Returns a string.</summary>
        /// <param name="string">The underlying string object.</param>
        /// <returns>String, or NULL on error.</returns>
        /// <remarks>
        /// <para>The buffer of the raw string must have been dynamically allocated.</para>
        /// <para>Ownership of the raw string is transferred to the newly created{#CowlString},</para>
        /// <para>meaning you must not deinitialize it.</para>
        /// <para>Equivalent to calling{#cowl_string_opt()} with</para>
        /// </remarks>
        public static global::cowl.CowlString CowlString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a string.</summary>
        /// <param name="string">The underlying string object.</param>
        /// <param name="opts">String creation options.</param>
        /// <returns>String, or NULL on error.</returns>
        /// <remarks>
        /// <para>String creation is governed by the following options:</para>
        /// <para>-</para>
        /// <para>assigned. Note that in the latter case the raw string must have been</para>
        /// <para>dynamically allocated, and you must not deinitialize it after passing it</para>
        /// <para>to this method.</para>
        /// <para>-</para>
        /// <para>instance pool, or if an instance with the same raw string already</para>
        /// <para>exists in the pool, that instance is retained and returned.</para>
        /// <para>This entails that all instances created with this flag are guaranteed</para>
        /// <para>to be unique in memory.</para>
        /// </remarks>
        public static global::cowl.CowlString CowlStringOpt(global::cowl.UString @string, byte opts)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlStringOpt(*(global::cowl.UString.__Internal*) __arg0, opts);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an empty string.</summary>
        /// <returns>String, or NULL on error.</returns>
        public static global::cowl.CowlString CowlStringEmpty()
        {
            var ___ret = __Internal.CowlStringEmpty();
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Interns the specified string.</summary>
        /// <param name="string">The string.</param>
        /// <returns>Interned string.</returns>
        /// <remarks>
        /// <para>The string is either added to an internal instance pool, or if an instance with the same</para>
        /// <para>raw string already exists in the pool, that instance is returned.</para>
        /// <para>The reference counts of the original string and that of the returned instance are not</para>
        /// <para>changed. This means you are still responsible for releasing the original string if</para>
        /// <para>you created it, and you should retain the returned string if you need to keep it alive.</para>
        /// </remarks>
        public static global::cowl.CowlString CowlStringIntern(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringIntern(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Releases the specified string, returning its raw string as a copy.</summary>
        /// <param name="string">The string.</param>
        /// <returns>Copy of the underlying string object.</returns>
        /// <remarks>
        /// <para>As an optimization, if the string is deallocated due to the release call,</para>
        /// <para>then the original raw string is returned.</para>
        /// </remarks>
        public static global::cowl.UString CowlStringReleaseCopyingRaw(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringReleaseCopyingRaw(__arg0);
            return global::cowl.UString.__CreateInstance(___ret);
        }

        /// <summary>Releases the specified string, returning its buffer as a copy.</summary>
        /// <param name="string">The string.</param>
        /// <returns>The copied buffer.</returns>
        /// <remarks>
        /// <para>As an optimization, if the string is deallocated due to the release call,</para>
        /// <para>then the original buffer is returned.</para>
        /// </remarks>
        public static sbyte* CowlStringReleaseCopyingCstring(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringReleaseCopyingCstring(__arg0);
            return ___ret;
        }

        /// <summary>Gets the underlying string buffer.</summary>
        /// <param name="string">The string.</param>
        /// <returns>The buffer.</returns>
        public static string CowlStringGetCstring(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringGetCstring(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Gets the length of the string, excluding the NULL terminator.</summary>
        /// <param name="string">The string.</param>
        /// <returns>The length.</returns>
        public static uint CowlStringGetLength(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringGetLength(__arg0);
            return ___ret;
        }

        /// <summary>Gets the underlying string object.</summary>
        /// <param name="string">The string.</param>
        /// <returns>Underlying string object.</returns>
        public static global::cowl.UString CowlStringGetRaw(global::cowl.CowlString @string)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlStringGetRaw(__arg0);
            var __result0 = global::cowl.UString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a string with the specified format.</summary>
        /// <param name="format">Format string.</param>
        /// <param name="...">Format arguments.</param>
        /// <returns>String, or NULL on error.</returns>
        public static global::cowl.CowlString CowlStringWithFormat(string format)
        {
            var ___ret = __Internal.CowlStringWithFormat(format);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a string obtained by concatenating two strings.</summary>
        /// <param name="lhs">LHS of the concatenation.</param>
        /// <param name="rhs">RHS of the concatenation.</param>
        /// <returns>String, or NULL on error.</returns>
        public static global::cowl.CowlString CowlStringConcat(global::cowl.CowlString lhs, global::cowl.CowlString rhs)
        {
            var __arg0 = lhs is null ? __IntPtr.Zero : lhs.__Instance;
            var __arg1 = rhs is null ? __IntPtr.Zero : rhs.__Instance;
            var ___ret = __Internal.CowlStringConcat(__arg0, __arg1);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Converts the string into an integer.</summary>
        /// <param name="string">The string.</param>
        /// <param name="out">Output value.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlStringToInt(global::cowl.CowlString @string, ref int @out, uint @base)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            fixed (int* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.CowlStringToInt(__arg0, __arg1, @base);
                return ___ret;
            }
        }

        /// <summary>Converts the string into an unsigned integer.</summary>
        /// <param name="string">The string.</param>
        /// <param name="out">Output value.</param>
        /// <param name="base">Numeric base.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlStringToUint(global::cowl.CowlString @string, ref uint @out, uint @base)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            fixed (uint* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.CowlStringToUint(__arg0, __arg1, @base);
                return ___ret;
            }
        }

        /// <summary>Converts the string into a float.</summary>
        /// <param name="string">The string.</param>
        /// <param name="out">Output value.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlStringToFloat(global::cowl.CowlString @string, ref double @out)
        {
            var __arg0 = @string is null ? __IntPtr.Zero : @string.__Instance;
            fixed (double* __out1 = &@out)
            {
                var __arg1 = __out1;
                var ___ret = __Internal.CowlStringToFloat(__arg0, __arg1);
                return ___ret;
            }
        }
    }

    public unsafe partial class cowl_iri
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIri(__IntPtr prefix, __IntPtr suffix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iri_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIriFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iri_get_ns", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIriGetNs(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iri_get_rem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIriGetRem(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_iri_has_rem@@YA_NPEAUCowlIRI@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIriHasRem(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_iri_is_reserved", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlIriIsReserved(__IntPtr iri);
        }

        /// <summary>Returns an IRI whose string representation is the concatenation of the specified strings.</summary>
        /// <param name="prefix">The prefix.</param>
        /// <param name="suffix">The suffix.</param>
        /// <returns>IRI, or NULL on error</returns>
        public static global::cowl.CowlIRI CowlIri(global::cowl.CowlString prefix, global::cowl.CowlString suffix)
        {
            var __arg0 = prefix is null ? __IntPtr.Zero : prefix.__Instance;
            var __arg1 = suffix is null ? __IntPtr.Zero : suffix.__Instance;
            var ___ret = __Internal.CowlIri(__arg0, __arg1);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an IRI given its string representation.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>IRI, or NULL on error</returns>
        public static global::cowl.CowlIRI CowlIriFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlIriFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the namespace of the specified IRI.</summary>
        /// <param name="iri">The IRI.</param>
        /// <returns>The namespace.</returns>
        public static global::cowl.CowlString CowlIriGetNs(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlIriGetNs(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the remainder of the specified IRI.</summary>
        /// <param name="iri">The IRI.</param>
        /// <returns>The remainder.</returns>
        public static global::cowl.CowlString CowlIriGetRem(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlIriGetRem(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Checks whether the IRI has a remainder.</summary>
        /// <param name="iri">The IRI.</param>
        /// <returns>True if the IRI has a remainder, false otherwise.</returns>
        public static bool CowlIriHasRem(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlIriHasRem(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the IRI is in the reserved vocabulary.</summary>
        /// <param name="iri">The IRI.</param>
        /// <returns>True if the IRI is reserved, false otherwise.</returns>
        public static bool CowlIriIsReserved(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlIriIsReserved(__arg0);
            return ___ret;
        }
    }

    /// <summary>Ontology input stream handlers.</summary>
    /// <summary>Ontology input stream handlers.</summary>
    public unsafe partial class CowlIStreamHandlers : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr ctx;
            internal __IntPtr iri;
            internal __IntPtr version;
            internal __IntPtr import;
            internal __IntPtr annot;
            internal __IntPtr axiom;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlIStreamHandlers@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIStreamHandlers> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlIStreamHandlers>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlIStreamHandlers managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlIStreamHandlers managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlIStreamHandlers __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlIStreamHandlers(native.ToPointer(), skipVTables);
        }

        internal static CowlIStreamHandlers __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlIStreamHandlers)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlIStreamHandlers __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlIStreamHandlers(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlIStreamHandlers(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlIStreamHandlers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlIStreamHandlers()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlIStreamHandlers.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlIStreamHandlers(global::cowl.CowlIStreamHandlers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlIStreamHandlers.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlIStreamHandlers.__Internal*) __Instance) = *((global::cowl.CowlIStreamHandlers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Stream context, can be anything.</summary>
        public __IntPtr Ctx
        {
            get
            {
                return ((__Internal*)__Instance)->ctx;
            }

            set
            {
                ((__Internal*)__Instance)->ctx = (__IntPtr) value;
            }
        }

        /// <summary>Pointer to a function that handles the specified ontology IRI.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="iri">The ontology IRI.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Iri
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->iri;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->iri = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that handles the specified version IRI.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="version">The version IRI.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Version
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->version;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->version = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that handles the specified import IRI.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="import">The import IRI.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Import
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->import;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->import = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that handles the specified annotation.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="annot">The annotation.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Annot
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->annot;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->annot = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to a function that handles the specified axiom.</summary>
        /// <param name="ctx">Stream context.</param>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Return code.</returns>
        public global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr Axiom
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->axiom;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_cowl_cowl_ret___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->axiom = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class CowlManager
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlManager> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlManager>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlManager managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlManager managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlManager __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlManager(native.ToPointer(), skipVTables);
        }

        internal static CowlManager __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlManager)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlManager __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlManager(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlManager(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_istream
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_get_manager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIstreamGetManager(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_get_sym_table", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlIstreamGetSymTable(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_handle_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamHandleIri(__IntPtr stream, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_handle_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamHandleVersion(__IntPtr stream, __IntPtr version);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_handle_import", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamHandleImport(__IntPtr stream, __IntPtr import);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_handle_annot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamHandleAnnot(__IntPtr stream, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_handle_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamHandleAxiom(__IntPtr stream, __IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_process_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamProcessPath(__IntPtr stream, global::cowl.UString.__Internal path);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_process_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamProcessFile(__IntPtr stream, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_process_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamProcessString(__IntPtr stream, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_process_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamProcessStream(__IntPtr stream, __IntPtr istream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_istream_process_ontology", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlIstreamProcessOntology(__IntPtr stream, __IntPtr onto);
        }

        /// <summary>Gets the manager of this ontology input stream.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <returns>The manager.</returns>
        public static global::cowl.CowlManager CowlIstreamGetManager(global::cowl.CowlIStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlIstreamGetManager(__arg0);
            var __result0 = global::cowl.CowlManager.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the symbol table of this ontology input stream.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <returns>The symbol table.</returns>
        public static global::cowl.CowlSymTable CowlIstreamGetSymTable(global::cowl.CowlIStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlIstreamGetSymTable(__arg0);
            var __result0 = global::cowl.CowlSymTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Handles the specified ontology IRI.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="iri">The ontology IRI.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamHandleIri(global::cowl.CowlIStream stream, global::cowl.CowlIRI iri)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlIstreamHandleIri(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Handles the specified ontology version IRI.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="version">The version IRI.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamHandleVersion(global::cowl.CowlIStream stream, global::cowl.CowlIRI version)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = version is null ? __IntPtr.Zero : version.__Instance;
            var ___ret = __Internal.CowlIstreamHandleVersion(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Handles the specified import IRI.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="import">The import IRI.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamHandleImport(global::cowl.CowlIStream stream, global::cowl.CowlIRI import)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = import is null ? __IntPtr.Zero : import.__Instance;
            var ___ret = __Internal.CowlIstreamHandleImport(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Handles the specified ontology annotation.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="annot">The annotation.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamHandleAnnot(global::cowl.CowlIStream stream, global::cowl.CowlAnnotation annot)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlIstreamHandleAnnot(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Handles the specified axiom.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamHandleAxiom(global::cowl.CowlIStream stream, __IntPtr axiom)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlIstreamHandleAxiom(__arg0, axiom);
            return ___ret;
        }

        /// <summary>Streams through the ontology at the specified path.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="path">The file path.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamProcessPath(global::cowl.CowlIStream stream, global::cowl.UString path)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            if (ReferenceEquals(path, null))
                throw new global::System.ArgumentNullException("path", "Cannot be null because it is passed by value.");
            var __arg1 = path.__Instance;
            var ___ret = __Internal.CowlIstreamProcessPath(__arg0, *(global::cowl.UString.__Internal*) __arg1);
            return ___ret;
        }

        /// <summary>Streams through the ontology read from the specified file.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="file">The file.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamProcessFile(global::cowl.CowlIStream stream, global::System.IntPtr file)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlIstreamProcessFile(__arg0, file);
            return ___ret;
        }

        /// <summary>Streams through the ontology read from the specified string.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="string">The string.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamProcessString(global::cowl.CowlIStream stream, global::cowl.UString @string)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlIstreamProcessString(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Streams through the ontology read from the specified input stream.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="istream">The input stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamProcessStream(global::cowl.CowlIStream stream, global::cowl.UIStream istream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = istream is null ? __IntPtr.Zero : istream.__Instance;
            var ___ret = __Internal.CowlIstreamProcessStream(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Streams through the specified ontology.</summary>
        /// <param name="stream">The ontology input stream.</param>
        /// <param name="onto">The ontology.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlIstreamProcessOntology(global::cowl.CowlIStream stream, global::cowl.CowlOntology onto)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlIstreamProcessOntology(__arg0, __arg1);
            return ___ret;
        }
    }

    public unsafe partial class cowl_literal
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_literal", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlLiteral(__IntPtr dt, __IntPtr value, __IntPtr lang);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_literal_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlLiteralFromString(global::cowl.UString.__Internal dt, global::cowl.UString.__Internal value, global::cowl.UString.__Internal lang);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_literal_get_datatype", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlLiteralGetDatatype(__IntPtr literal);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_literal_get_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlLiteralGetValue(__IntPtr literal);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_literal_get_lang", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlLiteralGetLang(__IntPtr literal);
        }

        /// <summary>Returns a literal.</summary>
        /// <param name="dt">{optional} The datatype.</param>
        /// <param name="value">The value.</param>
        /// <param name="lang">{optional} The language tag.</param>
        /// <returns>Literal, or NULL on error.</returns>
        public static global::cowl.CowlLiteral CowlLiteral(global::cowl.CowlDatatype dt, global::cowl.CowlString value, global::cowl.CowlString lang)
        {
            var __arg0 = dt is null ? __IntPtr.Zero : dt.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            var __arg2 = lang is null ? __IntPtr.Zero : lang.__Instance;
            var ___ret = __Internal.CowlLiteral(__arg0, __arg1, __arg2);
            var __result0 = global::cowl.CowlLiteral.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a literal given the string representations of its components.</summary>
        /// <param name="dt">{optional} The datatype.</param>
        /// <param name="value">The value.</param>
        /// <param name="lang">{optional} The language tag.</param>
        /// <returns>Literal, or NULL on error.</returns>
        public static global::cowl.CowlLiteral CowlLiteralFromString(global::cowl.UString dt, global::cowl.UString value, global::cowl.UString lang)
        {
            if (ReferenceEquals(dt, null))
                throw new global::System.ArgumentNullException("dt", "Cannot be null because it is passed by value.");
            var __arg0 = dt.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            if (ReferenceEquals(lang, null))
                throw new global::System.ArgumentNullException("lang", "Cannot be null because it is passed by value.");
            var __arg2 = lang.__Instance;
            var ___ret = __Internal.CowlLiteralFromString(*(global::cowl.UString.__Internal*) __arg0, *(global::cowl.UString.__Internal*) __arg1, *(global::cowl.UString.__Internal*) __arg2);
            var __result0 = global::cowl.CowlLiteral.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the datatype.</summary>
        /// <param name="literal">The literal.</param>
        /// <returns>The datatype.</returns>
        public static global::cowl.CowlDatatype CowlLiteralGetDatatype(global::cowl.CowlLiteral literal)
        {
            var __arg0 = literal is null ? __IntPtr.Zero : literal.__Instance;
            var ___ret = __Internal.CowlLiteralGetDatatype(__arg0);
            var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the value.</summary>
        /// <param name="literal">The literal.</param>
        /// <returns>The value.</returns>
        public static global::cowl.CowlString CowlLiteralGetValue(global::cowl.CowlLiteral literal)
        {
            var __arg0 = literal is null ? __IntPtr.Zero : literal.__Instance;
            var ___ret = __Internal.CowlLiteralGetValue(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the language tag.</summary>
        /// <param name="literal">The literal.</param>
        /// <returns>The language tag.</returns>
        public static global::cowl.CowlString CowlLiteralGetLang(global::cowl.CowlLiteral literal)
        {
            var __arg0 = literal is null ? __IntPtr.Zero : literal.__Instance;
            var ___ret = __Internal.CowlLiteralGetLang(__arg0);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>An object that identifies an ontology.</summary>
    /// <remarks>
    /// <para>[Ontology IRI and version IRI]</para>
    /// <para>[Ontology IRI and version IRI]: https://www.w3.org/TR/owl2-syntax/#Ontology_IRI_and_Version_IRI</para>
    /// </remarks>
    public unsafe partial class CowlOStream
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOStream(native.ToPointer(), skipVTables);
        }

        internal static CowlOStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_manager
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManager();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_reader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlReader.__Internal CowlManagerGetReader(__IntPtr manager);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_set_reader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlManagerSetReader(__IntPtr manager, global::cowl.CowlReader.__Internal reader);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_writer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlWriter.__Internal CowlManagerGetWriter(__IntPtr manager);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_set_writer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlManagerSetWriter(__IntPtr manager, global::cowl.CowlWriter.__Internal writer);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_import_loader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlImportLoader.__Internal CowlManagerGetImportLoader(__IntPtr manager);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_set_import_loader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlManagerSetImportLoader(__IntPtr manager, global::cowl.CowlImportLoader.__Internal loader);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_error_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlErrorHandler.__Internal CowlManagerGetErrorHandler(__IntPtr manager);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_set_error_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlManagerSetErrorHandler(__IntPtr manager, global::cowl.CowlErrorHandler.__Internal handler);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_ontology_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlManagerOntologyCount(__IntPtr manager);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_iterate_ontologies", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlManagerIterateOntologies(__IntPtr manager, __IntPtr iter);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_ontology", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerGetOntology(__IntPtr manager, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_retrieve_ontology", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerRetrieveOntology(__IntPtr manager, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_read_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerReadPath(__IntPtr manager, global::cowl.UString.__Internal path);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_read_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerReadFile(__IntPtr manager, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_read_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerReadString(__IntPtr manager, __IntPtr @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_read_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerReadStream(__IntPtr manager, __IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_write_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlManagerWritePath(__IntPtr manager, __IntPtr onto, global::cowl.UString.__Internal path);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_write_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlManagerWriteFile(__IntPtr manager, __IntPtr onto, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_write_strbuf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlManagerWriteStrbuf(__IntPtr manager, __IntPtr onto, __IntPtr buf);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_write_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlManagerWriteStream(__IntPtr manager, __IntPtr onto, __IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_istream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerGetIstream(__IntPtr manager, global::cowl.CowlIStreamHandlers.__Internal handlers);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_istream_to_ontology", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerGetIstreamToOntology(__IntPtr manager, __IntPtr onto);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_manager_get_ostream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlManagerGetOstream(__IntPtr manager, __IntPtr stream);
        }

        /// <summary>Returns a manager that uses the default reader and writer.</summary>
        /// <returns>Manager, or NULL on error.</returns>
        /// <remarks>
        /// <para>You can specify the default reader and writer</para>
        /// <para>via{#cowl_set_reader()} and{#cowl_set_writer()}.</para>
        /// </remarks>
        public static global::cowl.CowlManager CowlManager()
        {
            var ___ret = __Internal.CowlManager();
            var __result0 = global::cowl.CowlManager.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the reader.</summary>
        /// <param name="manager">The manager.</param>
        /// <returns>The reader.</returns>
        public static global::cowl.CowlReader CowlManagerGetReader(global::cowl.CowlManager manager)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerGetReader(__arg0);
            return global::cowl.CowlReader.__CreateInstance(___ret);
        }

        /// <summary>Sets the reader.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="reader">The reader.</param>
        public static void CowlManagerSetReader(global::cowl.CowlManager manager, global::cowl.CowlReader reader)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(reader, null))
                throw new global::System.ArgumentNullException("reader", "Cannot be null because it is passed by value.");
            var __arg1 = reader.__Instance;
            __Internal.CowlManagerSetReader(__arg0, *(global::cowl.CowlReader.__Internal*) __arg1);
        }

        /// <summary>Gets the writer.</summary>
        /// <param name="manager">The manager.</param>
        /// <returns>The writer.</returns>
        public static global::cowl.CowlWriter CowlManagerGetWriter(global::cowl.CowlManager manager)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerGetWriter(__arg0);
            return global::cowl.CowlWriter.__CreateInstance(___ret);
        }

        /// <summary>Sets the writer.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="writer">The writer.</param>
        public static void CowlManagerSetWriter(global::cowl.CowlManager manager, global::cowl.CowlWriter writer)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(writer, null))
                throw new global::System.ArgumentNullException("writer", "Cannot be null because it is passed by value.");
            var __arg1 = writer.__Instance;
            __Internal.CowlManagerSetWriter(__arg0, *(global::cowl.CowlWriter.__Internal*) __arg1);
        }

        /// <summary>Gets the import loader.</summary>
        /// <param name="manager">The manager.</param>
        /// <returns>The import loader.</returns>
        public static global::cowl.CowlImportLoader CowlManagerGetImportLoader(global::cowl.CowlManager manager)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerGetImportLoader(__arg0);
            return global::cowl.CowlImportLoader.__CreateInstance(___ret);
        }

        /// <summary>Sets the import loader.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="loader">The import loader.</param>
        public static void CowlManagerSetImportLoader(global::cowl.CowlManager manager, global::cowl.CowlImportLoader loader)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(loader, null))
                throw new global::System.ArgumentNullException("loader", "Cannot be null because it is passed by value.");
            var __arg1 = loader.__Instance;
            __Internal.CowlManagerSetImportLoader(__arg0, *(global::cowl.CowlImportLoader.__Internal*) __arg1);
        }

        /// <summary>Gets the error handler.</summary>
        /// <param name="manager">The manager.</param>
        /// <returns>The error handler.</returns>
        public static global::cowl.CowlErrorHandler CowlManagerGetErrorHandler(global::cowl.CowlManager manager)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerGetErrorHandler(__arg0);
            return global::cowl.CowlErrorHandler.__CreateInstance(___ret);
        }

        /// <summary>Sets the error handler.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="handler">The error handler.</param>
        public static void CowlManagerSetErrorHandler(global::cowl.CowlManager manager, global::cowl.CowlErrorHandler handler)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(handler, null))
                throw new global::System.ArgumentNullException("handler", "Cannot be null because it is passed by value.");
            var __arg1 = handler.__Instance;
            __Internal.CowlManagerSetErrorHandler(__arg0, *(global::cowl.CowlErrorHandler.__Internal*) __arg1);
        }

        /// <summary>Returns the number of ontologies managed by this manager.</summary>
        /// <param name="manager">The manager.</param>
        /// <returns>Number of ontologies.</returns>
        public static uint CowlManagerOntologyCount(global::cowl.CowlManager manager)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerOntologyCount(__arg0);
            return ___ret;
        }

        /// <summary>Iterates over the ontologies held by the manager.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="iter">The iterator.</param>
        /// <returns>True if iteration was completed, false if it was stopped.</returns>
        public static bool CowlManagerIterateOntologies(global::cowl.CowlManager manager, global::cowl.CowlIterator iter)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlManagerIterateOntologies(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Gets the ontology with the specified identifier.</para>
        /// <para>If no existing ontology has the specified identifier, a new ontology is returned.</para>
        /// </summary>
        /// <param name="manager">The manager.</param>
        /// <param name="id">The ontology identifier.</param>
        /// <returns>Ontology with the specified identifier.</returns>
        /// <remarks>
        /// <para>You can pass NULL as the ontology identifier, in which case the function returns</para>
        /// <para>a new anonymous ontology.</para>
        /// </remarks>
        public static global::cowl.CowlOntology CowlManagerGetOntology(global::cowl.CowlManager manager, global::cowl.CowlOntologyId id)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = id is null ? __IntPtr.Zero : id.__Instance;
            var ___ret = __Internal.CowlManagerGetOntology(__arg0, __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the ontology with the specified identifier, if it exists.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="id">The ontology identifier.</param>
        /// <returns>Ontology with the specified identifier, or NULL if it does not exist.</returns>
        public static global::cowl.CowlOntology CowlManagerRetrieveOntology(global::cowl.CowlManager manager, global::cowl.CowlOntologyId id)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = id is null ? __IntPtr.Zero : id.__Instance;
            var ___ret = __Internal.CowlManagerRetrieveOntology(__arg0, __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Reads an ontology from the file at the specified path.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="path">The file path.</param>
        /// <returns>The read ontology, or NULL on error.</returns>
        public static global::cowl.CowlOntology CowlManagerReadPath(global::cowl.CowlManager manager, global::cowl.UString path)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(path, null))
                throw new global::System.ArgumentNullException("path", "Cannot be null because it is passed by value.");
            var __arg1 = path.__Instance;
            var ___ret = __Internal.CowlManagerReadPath(__arg0, *(global::cowl.UString.__Internal*) __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Reads an ontology from the specified file.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="file">The input file.</param>
        /// <returns>The read ontology, or NULL on error.</returns>
        public static global::cowl.CowlOntology CowlManagerReadFile(global::cowl.CowlManager manager, global::System.IntPtr file)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var ___ret = __Internal.CowlManagerReadFile(__arg0, file);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Reads an ontology from the specified string.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="string">The input string.</param>
        /// <returns>The read ontology, or NULL on error.</returns>
        public static global::cowl.CowlOntology CowlManagerReadString(global::cowl.CowlManager manager, global::cowl.UString @string)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = @string is null ? __IntPtr.Zero : @string.__Instance;
            var ___ret = __Internal.CowlManagerReadString(__arg0, __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Reads an ontology from the specified input stream.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="stream">The input stream.</param>
        /// <returns>The read ontology, or NULL on error.</returns>
        /// <remarks>The stream is not released by the manager, you must do it yourself.</remarks>
        public static global::cowl.CowlOntology CowlManagerReadStream(global::cowl.CowlManager manager, global::cowl.UIStream stream)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlManagerReadStream(__arg0, __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Writes the ontology to the file at the specified path.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="onto">The ontology.</param>
        /// <param name="path">The file path.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlManagerWritePath(global::cowl.CowlManager manager, global::cowl.CowlOntology onto, global::cowl.UString path)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            if (ReferenceEquals(path, null))
                throw new global::System.ArgumentNullException("path", "Cannot be null because it is passed by value.");
            var __arg2 = path.__Instance;
            var ___ret = __Internal.CowlManagerWritePath(__arg0, __arg1, *(global::cowl.UString.__Internal*) __arg2);
            return ___ret;
        }

        /// <summary>Writes the ontology to the specified file.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="onto">The ontology.</param>
        /// <param name="file">The output file.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlManagerWriteFile(global::cowl.CowlManager manager, global::cowl.CowlOntology onto, global::System.IntPtr file)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlManagerWriteFile(__arg0, __arg1, file);
            return ___ret;
        }

        /// <summary>Writes the ontology to the specified string buffer.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="onto">The ontology.</param>
        /// <param name="buf">The string buffer.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlManagerWriteStrbuf(global::cowl.CowlManager manager, global::cowl.CowlOntology onto, global::cowl.UVec_char buf)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.CowlManagerWriteStrbuf(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Writes the ontology to the specified output stream.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="onto">The ontology.</param>
        /// <param name="stream">The output stream.</param>
        /// <returns>Return code.</returns>
        /// <remarks>The stream is not released by the manager, you must do it yourself.</remarks>
        public static global::cowl.CowlRet CowlManagerWriteStream(global::cowl.CowlManager manager, global::cowl.CowlOntology onto, global::cowl.UOStream stream)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlManagerWriteStream(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Returns an ontology input stream.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="handlers">The handlers.</param>
        /// <returns>Ontology input stream.</returns>
        public static global::cowl.CowlIStream CowlManagerGetIstream(global::cowl.CowlManager manager, global::cowl.CowlIStreamHandlers handlers)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            if (ReferenceEquals(handlers, null))
                throw new global::System.ArgumentNullException("handlers", "Cannot be null because it is passed by value.");
            var __arg1 = handlers.__Instance;
            var ___ret = __Internal.CowlManagerGetIstream(__arg0, *(global::cowl.CowlIStreamHandlers.__Internal*) __arg1);
            var __result0 = global::cowl.CowlIStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an ontology input stream that stores constructs in the specified ontology.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="onto">The ontology.</param>
        /// <returns>Ontology input stream.</returns>
        public static global::cowl.CowlIStream CowlManagerGetIstreamToOntology(global::cowl.CowlManager manager, global::cowl.CowlOntology onto)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlManagerGetIstreamToOntology(__arg0, __arg1);
            var __result0 = global::cowl.CowlIStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an ontology output stream.</summary>
        /// <param name="manager">The manager.</param>
        /// <param name="stream">The output stream.</param>
        /// <returns>Ontology output stream.</returns>
        public static global::cowl.CowlOStream CowlManagerGetOstream(global::cowl.CowlManager manager, global::cowl.UOStream stream)
        {
            var __arg0 = manager is null ? __IntPtr.Zero : manager.__Instance;
            var __arg1 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlManagerGetOstream(__arg0, __arg1);
            var __result0 = global::cowl.CowlOStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNamedInd
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNamedInd> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNamedInd>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNamedInd managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNamedInd managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNamedInd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNamedInd(native.ToPointer(), skipVTables);
        }

        internal static CowlNamedInd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNamedInd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNamedInd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNamedInd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNamedInd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNamedInd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_named_ind
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_named_ind@@YAPEAUCowlNamedInd@@PEAUCowlIRI@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNamedInd(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_named_ind_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNamedIndFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_named_ind_get_iri@@YAPEAUCowlIRI@@PEAUCowlNamedInd@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNamedIndGetIri(__IntPtr ind);
        }

        /// <summary>Returns a named individual.</summary>
        /// <param name="iri">IRI of the individual.</param>
        /// <returns>Named individual, or NULL on error.</returns>
        public static global::cowl.CowlNamedInd CowlNamedInd(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlNamedInd(__arg0);
            var __result0 = global::cowl.CowlNamedInd.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a named individual given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Named individual, or NULL on error.</returns>
        public static global::cowl.CowlNamedInd CowlNamedIndFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlNamedIndFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlNamedInd.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the named individual.</summary>
        /// <param name="ind">The named individual.</param>
        /// <returns>IRI of the named individual.</returns>
        public static global::cowl.CowlIRI CowlNamedIndGetIri(global::cowl.CowlNamedInd ind)
        {
            var __arg0 = ind is null ? __IntPtr.Zero : ind.__Instance;
            var ___ret = __Internal.CowlNamedIndGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>
    /// <para>Represents the type of</para>
    /// <para>and</para>
    /// </summary>
    public enum CowlNAryAxiomType
    {
        /// <summary>Equivalence.</summary>
        COWL_NAT_EQUIV = 0,
        /// <summary>Disjointness.</summary>
        COWL_NAT_DISJ = 1,
        /// <summary>Number of enum values.</summary>
        COWL_NAT_COUNT = 2,
        /// <summary>First enum value.</summary>
        COWL_NAT_FIRST = 0,
        /// <summary>Same individuals.</summary>
        COWL_NAT_SAME = 0,
        /// <summary>Different individuals.</summary>
        COWL_NAT_DIFF = 1
    }

    /// <summary>
    /// <para>Represents the type of</para>
    /// <para>and</para>
    /// </summary>
    /// <summary>Represents the type ofand</summary>
    public enum CowlNAryType
    {
        /// <summary>Intersection.</summary>
        COWL_NT_INTERSECT = 0,
        /// <summary>Union.</summary>
        COWL_NT_UNION = 1,
        /// <summary>Number of enum values.</summary>
        COWL_NT_COUNT = 2,
        /// <summary>First enum value.</summary>
        COWL_NT_FIRST = 0
    }

    /// <summary>Represents the type ofand</summary>
    public unsafe partial class CowlNAryBool
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryBool> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryBool>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryBool managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryBool managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryBool __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryBool(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryBool __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryBool)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryBool __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryBool(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryBool(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryBool(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_bool
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_nary_bool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryBool(global::cowl.CowlNAryType type, __IntPtr operands);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_nary_bool_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryType CowlNaryBoolGetType(__IntPtr exp);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_nary_bool_get_operands", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryBoolGetOperands(__IntPtr exp);
        }

        /// <summary>Returns a N-ary boolean class expression.</summary>
        /// <param name="type">N-ary class expression type.</param>
        /// <param name="operands">The operands.</param>
        /// <returns>Expression, or NULL on error.</returns>
        public static global::cowl.CowlNAryBool CowlNaryBool(global::cowl.CowlNAryType type, global::cowl.CowlVector operands)
        {
            var __arg1 = operands is null ? __IntPtr.Zero : operands.__Instance;
            var ___ret = __Internal.CowlNaryBool(type, __arg1);
            var __result0 = global::cowl.CowlNAryBool.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary boolean class expression.</summary>
        /// <param name="exp">The expression.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryType CowlNaryBoolGetType(global::cowl.CowlNAryBool exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlNaryBoolGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the operands of the specified N-ary boolean class expression.</summary>
        /// <param name="exp">The expression.</param>
        /// <returns>The operands.</returns>
        public static global::cowl.CowlVector CowlNaryBoolGetOperands(global::cowl.CowlNAryBool exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlNaryBoolGetOperands(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNAryClsAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryClsAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryClsAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryClsAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryClsAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryClsAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryClsAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryClsAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryClsAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryClsAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryClsAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryClsAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryClsAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_cls_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_nary_cls_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryClsAxiom(global::cowl.CowlNAryAxiomType type, __IntPtr classes, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_cls_axiom_get_type@@YA?AW4CowlNAryAxiomType@@PEAUCowlNAryClsAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryAxiomType CowlNaryClsAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_cls_axiom_get_classes@@YAPEAUCowlVector@@PEAUCowlNAryClsAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryClsAxiomGetClasses(__IntPtr axiom);
        }

        /// <summary>Returns a N-ary class expression axiom.</summary>
        /// <param name="type">N-ary class expression axiom type.</param>
        /// <param name="classes">The classes.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlNAryClsAxiom CowlNaryClsAxiom(global::cowl.CowlNAryAxiomType type, global::cowl.CowlVector classes, global::cowl.CowlVector annot)
        {
            var __arg1 = classes is null ? __IntPtr.Zero : classes.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNaryClsAxiom(type, __arg1, __arg2);
            var __result0 = global::cowl.CowlNAryClsAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary class expression axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryAxiomType CowlNaryClsAxiomGetType(global::cowl.CowlNAryClsAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryClsAxiomGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the classes of the specified N-ary class expression axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The classes.</returns>
        public static global::cowl.CowlVector CowlNaryClsAxiomGetClasses(global::cowl.CowlNAryClsAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryClsAxiomGetClasses(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNAryData
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryData(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_data
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data@@YAPEAUCowlNAryData@@W4CowlNAryType@@PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryData(global::cowl.CowlNAryType type, __IntPtr operands);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data_get_type@@YA?AW4CowlNAryType@@PEAUCowlNAryData@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryType CowlNaryDataGetType(__IntPtr range);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data_get_operands@@YAPEAUCowlVector@@PEAUCowlNAryData@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryDataGetOperands(__IntPtr range);
        }

        /// <summary>Returns a N-ary data range.</summary>
        /// <param name="type">N-ary data range type.</param>
        /// <param name="operands">The operands.</param>
        /// <returns>N-ary data range, or NULL on error.</returns>
        public static global::cowl.CowlNAryData CowlNaryData(global::cowl.CowlNAryType type, global::cowl.CowlVector operands)
        {
            var __arg1 = operands is null ? __IntPtr.Zero : operands.__Instance;
            var ___ret = __Internal.CowlNaryData(type, __arg1);
            var __result0 = global::cowl.CowlNAryData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary data range.</summary>
        /// <param name="range">The data range.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryType CowlNaryDataGetType(global::cowl.CowlNAryData range)
        {
            var __arg0 = range is null ? __IntPtr.Zero : range.__Instance;
            var ___ret = __Internal.CowlNaryDataGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the operands of the specified N-ary data range.</summary>
        /// <param name="range">The data range.</param>
        /// <returns>The operands.</returns>
        public static global::cowl.CowlVector CowlNaryDataGetOperands(global::cowl.CowlNAryData range)
        {
            var __arg0 = range is null ? __IntPtr.Zero : range.__Instance;
            var ___ret = __Internal.CowlNaryDataGetOperands(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNAryDataPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryDataPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryDataPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryDataPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryDataPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryDataPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryDataPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryDataPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryDataPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryDataPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryDataPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryDataPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryDataPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_data_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data_prop_axiom@@YAPEAUCowlNAryDataPropAxiom@@W4CowlNAryAxiomType@@PEAUCowlVector@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryDataPropAxiom(global::cowl.CowlNAryAxiomType type, __IntPtr props, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data_prop_axiom_get_type@@YA?AW4CowlNAryAxiomType@@PEAUCowlNAryDataPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryAxiomType CowlNaryDataPropAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_data_prop_axiom_get_props@@YAPEAUCowlVector@@PEAUCowlNAryDataPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryDataPropAxiomGetProps(__IntPtr axiom);
        }

        /// <summary>Returns a N-ary data property axiom.</summary>
        /// <param name="type">The type.</param>
        /// <param name="props">The data properties.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlNAryDataPropAxiom CowlNaryDataPropAxiom(global::cowl.CowlNAryAxiomType type, global::cowl.CowlVector props, global::cowl.CowlVector annot)
        {
            var __arg1 = props is null ? __IntPtr.Zero : props.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNaryDataPropAxiom(type, __arg1, __arg2);
            var __result0 = global::cowl.CowlNAryDataPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary data property axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryAxiomType CowlNaryDataPropAxiomGetType(global::cowl.CowlNAryDataPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryDataPropAxiomGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the data properties of the specified N-ary data property axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The data properties.</returns>
        public static global::cowl.CowlVector CowlNaryDataPropAxiomGetProps(global::cowl.CowlNAryDataPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryDataPropAxiomGetProps(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNAryIndAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryIndAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryIndAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryIndAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryIndAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryIndAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryIndAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryIndAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryIndAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryIndAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryIndAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryIndAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryIndAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_ind_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_ind_axiom@@YAPEAUCowlNAryIndAxiom@@W4CowlNAryAxiomType@@PEAUCowlVector@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryIndAxiom(global::cowl.CowlNAryAxiomType type, __IntPtr individuals, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_ind_axiom_get_type@@YA?AW4CowlNAryAxiomType@@PEAUCowlNAryIndAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryAxiomType CowlNaryIndAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_ind_axiom_get_individuals@@YAPEAUCowlVector@@PEAUCowlNAryIndAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryIndAxiomGetIndividuals(__IntPtr axiom);
        }

        /// <summary>Returns a N-ary individual axiom.</summary>
        /// <param name="type">The type.</param>
        /// <param name="individuals">The individuals.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlNAryIndAxiom CowlNaryIndAxiom(global::cowl.CowlNAryAxiomType type, global::cowl.CowlVector individuals, global::cowl.CowlVector annot)
        {
            var __arg1 = individuals is null ? __IntPtr.Zero : individuals.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNaryIndAxiom(type, __arg1, __arg2);
            var __result0 = global::cowl.CowlNAryIndAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary individual axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryAxiomType CowlNaryIndAxiomGetType(global::cowl.CowlNAryIndAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryIndAxiomGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the individuals of the specified N-ary individual axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The individuals.</returns>
        public static global::cowl.CowlVector CowlNaryIndAxiomGetIndividuals(global::cowl.CowlNAryIndAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryIndAxiomGetIndividuals(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlNAryObjPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryObjPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlNAryObjPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlNAryObjPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlNAryObjPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlNAryObjPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlNAryObjPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlNAryObjPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlNAryObjPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlNAryObjPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlNAryObjPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlNAryObjPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlNAryObjPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_nary_obj_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_obj_prop_axiom@@YAPEAUCowlNAryObjPropAxiom@@W4CowlNAryAxiomType@@PEAUCowlVector@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryObjPropAxiom(global::cowl.CowlNAryAxiomType type, __IntPtr props, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_obj_prop_axiom_get_type@@YA?AW4CowlNAryAxiomType@@PEAUCowlNAryObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlNAryAxiomType CowlNaryObjPropAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_nary_obj_prop_axiom_get_props@@YAPEAUCowlVector@@PEAUCowlNAryObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNaryObjPropAxiomGetProps(__IntPtr axiom);
        }

        /// <summary>Returns a N-ary object property axiom.</summary>
        /// <param name="type">The type.</param>
        /// <param name="props">The object properties.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlNAryObjPropAxiom CowlNaryObjPropAxiom(global::cowl.CowlNAryAxiomType type, global::cowl.CowlVector props, global::cowl.CowlVector annot)
        {
            var __arg1 = props is null ? __IntPtr.Zero : props.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNaryObjPropAxiom(type, __arg1, __arg2);
            var __result0 = global::cowl.CowlNAryObjPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified N-ary object property axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlNAryAxiomType CowlNaryObjPropAxiomGetType(global::cowl.CowlNAryObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryObjPropAxiomGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the object properties of the specified N-ary object property axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object properties.</returns>
        public static global::cowl.CowlVector CowlNaryObjPropAxiomGetProps(global::cowl.CowlNAryObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlNaryObjPropAxiomGetProps(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjCard
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjCard> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjCard>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjCard managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjCard managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjCard __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjCard(native.ToPointer(), skipVTables);
        }

        internal static CowlObjCard __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjCard)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjCard __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjCard(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjCard(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjCard(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_card
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_card", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjCard(global::cowl.CowlCardType type, __IntPtr prop, __IntPtr filler, uint cardinality);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_card_get_type@@YA?AW4CowlCardType@@PEAUCowlObjCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlCardType CowlObjCardGetType(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_card_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjCardGetProp(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_card_get_filler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjCardGetFiller(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_card_get_cardinality@@YAIPEAUCowlObjCard@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlObjCardGetCardinality(__IntPtr restr);
        }

        /// <summary>Returns an object property cardinality restriction.</summary>
        /// <param name="type">The type.</param>
        /// <param name="prop">The object property.</param>
        /// <param name="filler">{optional} Filler of the restriction.</param>
        /// <param name="cardinality">Cardinality of the restriction.</param>
        /// <returns>Restriction, or NULL on error.</returns>
        public static global::cowl.CowlObjCard CowlObjCard(global::cowl.CowlCardType type, __IntPtr prop, __IntPtr filler, uint cardinality)
        {
            var ___ret = __Internal.CowlObjCard(type, prop, filler, cardinality);
            var __result0 = global::cowl.CowlObjCard.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified object property cardinality restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlCardType CowlObjCardGetType(global::cowl.CowlObjCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjCardGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the property of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The property.</returns>
        public static global::cowl.CowlObjPropExp CowlObjCardGetProp(global::cowl.CowlObjCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjCardGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the filler of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The filler.</returns>
        public static global::cowl.CowlClsExp CowlObjCardGetFiller(global::cowl.CowlObjCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjCardGetFiller(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the cardinality of the restriction.</summary>
        /// <param name="restr">The restriction.</param>
        /// <returns>The cardinality.</returns>
        public static uint CowlObjCardGetCardinality(global::cowl.CowlObjCard restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjCardGetCardinality(__arg0);
            return ___ret;
        }
    }

    public unsafe partial class CowlObjCompl
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjCompl> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjCompl>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjCompl managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjCompl managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjCompl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjCompl(native.ToPointer(), skipVTables);
        }

        internal static CowlObjCompl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjCompl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjCompl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjCompl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjCompl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjCompl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_compl
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_compl@@YAPEAUCowlObjCompl@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjCompl(__IntPtr operand);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_compl_get_operand@@YAPEAUCowlClsExp@@PEAUCowlObjCompl@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjComplGetOperand(__IntPtr exp);
        }

        /// <summary>Returns the complement of a class expression.</summary>
        /// <param name="operand">The operand.</param>
        /// <returns>Class expression complement, or NULL on error.</returns>
        public static global::cowl.CowlObjCompl CowlObjCompl(__IntPtr operand)
        {
            var ___ret = __Internal.CowlObjCompl(operand);
            var __result0 = global::cowl.CowlObjCompl.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the operand of the specified class expression complement.</summary>
        /// <param name="exp">The complement.</param>
        /// <returns>The operand.</returns>
        public static global::cowl.CowlClsExp CowlObjComplGetOperand(global::cowl.CowlObjCompl exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlObjComplGetOperand(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjHasSelf
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjHasSelf> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjHasSelf>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjHasSelf managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjHasSelf managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjHasSelf __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjHasSelf(native.ToPointer(), skipVTables);
        }

        internal static CowlObjHasSelf __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjHasSelf)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjHasSelf __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjHasSelf(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjHasSelf(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjHasSelf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_has_self
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_has_self@@YAPEAUCowlObjHasSelf@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjHasSelf(__IntPtr prop);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_has_self_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjHasSelf@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjHasSelfGetProp(__IntPtr exp);
        }

        /// <summary>Returns a self-restriction.</summary>
        /// <param name="prop">The property expression.</param>
        /// <returns>Restriction, or NULL on error.</returns>
        public static global::cowl.CowlObjHasSelf CowlObjHasSelf(__IntPtr prop)
        {
            var ___ret = __Internal.CowlObjHasSelf(prop);
            var __result0 = global::cowl.CowlObjHasSelf.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the object property expression of the specified self-restriction.</summary>
        /// <param name="exp">The restriction.</param>
        /// <returns>The object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlObjHasSelfGetProp(global::cowl.CowlObjHasSelf exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlObjHasSelfGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjHasValue
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjHasValue> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjHasValue>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjHasValue managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjHasValue managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjHasValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjHasValue(native.ToPointer(), skipVTables);
        }

        internal static CowlObjHasValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjHasValue)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjHasValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjHasValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjHasValue(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjHasValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_has_value
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_has_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjHasValue(__IntPtr prop, __IntPtr individual);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_has_value_get_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjHasValueGetProp(__IntPtr exp);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_has_value_get_ind", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjHasValueGetInd(__IntPtr exp);
        }

        /// <summary>Returns an individual value restriction.</summary>
        /// <param name="prop">The object property expression.</param>
        /// <param name="individual">The individual.</param>
        /// <returns>Restriction, or NULL on error.</returns>
        public static global::cowl.CowlObjHasValue CowlObjHasValue(__IntPtr prop, __IntPtr individual)
        {
            var ___ret = __Internal.CowlObjHasValue(prop, individual);
            var __result0 = global::cowl.CowlObjHasValue.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the object property expression of the specified individual value restriction.</summary>
        /// <param name="exp">The restriction.</param>
        /// <returns>The object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlObjHasValueGetProp(global::cowl.CowlObjHasValue exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlObjHasValueGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the individual of the specified individual value restriction.</summary>
        /// <param name="exp">The restriction.</param>
        /// <returns>The individual.</returns>
        public static global::cowl.CowlIndividual CowlObjHasValueGetInd(global::cowl.CowlObjHasValue exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlObjHasValueGetInd(__arg0);
            var __result0 = global::cowl.CowlIndividual.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjOneOf
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjOneOf> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjOneOf>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjOneOf managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjOneOf managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjOneOf __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjOneOf(native.ToPointer(), skipVTables);
        }

        internal static CowlObjOneOf __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjOneOf)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjOneOf __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjOneOf(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjOneOf(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjOneOf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_one_of
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_one_of@@YAPEAUCowlObjOneOf@@PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjOneOf(__IntPtr inds);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_one_of_get_inds@@YAPEAUCowlVector@@PEAUCowlObjOneOf@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjOneOfGetInds(__IntPtr exp);
        }

        /// <summary>Returns an individual enumeration.</summary>
        /// <param name="inds">The individuals.</param>
        /// <returns>Individual enumeration, or NULL on error.</returns>
        public static global::cowl.CowlObjOneOf CowlObjOneOf(global::cowl.CowlVector inds)
        {
            var __arg0 = inds is null ? __IntPtr.Zero : inds.__Instance;
            var ___ret = __Internal.CowlObjOneOf(__arg0);
            var __result0 = global::cowl.CowlObjOneOf.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the individuals of the specified enumeration.</summary>
        /// <param name="exp">The individual enumeration.</param>
        /// <returns>The individuals.</returns>
        public static global::cowl.CowlVector CowlObjOneOfGetInds(global::cowl.CowlObjOneOf exp)
        {
            var __arg0 = exp is null ? __IntPtr.Zero : exp.__Instance;
            var ___ret = __Internal.CowlObjOneOfGetInds(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class cowl_obj_prop
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop@@YAPEAUCowlObjProp@@PEAUCowlIRI@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjProp(__IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_prop_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropFromString(global::cowl.UString.__Internal @string);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_get_iri@@YAPEAUCowlIRI@@PEAUCowlObjProp@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropGetIri(__IntPtr prop);
        }

        /// <summary>Returns an object property.</summary>
        /// <param name="iri">IRI of the object property.</param>
        /// <returns>Object property, or NULL on error.</returns>
        public static global::cowl.CowlObjProp CowlObjProp(global::cowl.CowlIRI iri)
        {
            var __arg0 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlObjProp(__arg0);
            var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an object property given the string representation of its IRI.</summary>
        /// <param name="string">String representation of the IRI.</param>
        /// <returns>Object property, or NULL on error.</returns>
        public static global::cowl.CowlObjProp CowlObjPropFromString(global::cowl.UString @string)
        {
            if (ReferenceEquals(@string, null))
                throw new global::System.ArgumentNullException("@string", "Cannot be null because it is passed by value.");
            var __arg0 = @string.__Instance;
            var ___ret = __Internal.CowlObjPropFromString(*(global::cowl.UString.__Internal*) __arg0);
            var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the IRI of the specified object property.</summary>
        /// <param name="prop">The object property.</param>
        /// <returns>The IRI.</returns>
        public static global::cowl.CowlIRI CowlObjPropGetIri(global::cowl.CowlObjProp prop)
        {
            var __arg0 = prop is null ? __IntPtr.Zero : prop.__Instance;
            var ___ret = __Internal.CowlObjPropGetIri(__arg0);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjPropAssertAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropAssertAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropAssertAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjPropAssertAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjPropAssertAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjPropAssertAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjPropAssertAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlObjPropAssertAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjPropAssertAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjPropAssertAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjPropAssertAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjPropAssertAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjPropAssertAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_prop_assert_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_assert_axiom@@YAPEAUCowlObjPropAssertAxiom@@PEAX00PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropAssertAxiom(__IntPtr prop, __IntPtr subject, __IntPtr @object, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_neg_obj_prop_assert_axiom@@YAPEAUCowlObjPropAssertAxiom@@PEAX00PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlNegObjPropAssertAxiom(__IntPtr prop, __IntPtr subject, __IntPtr @object, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_assert_axiom_is_negative@@YA_NPEAUCowlObjPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlObjPropAssertAxiomIsNegative(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_assert_axiom_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropAssertAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_assert_axiom_get_subject@@YAPEAUCowlIndividual@@PEAUCowlObjPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropAssertAxiomGetSubject(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_assert_axiom_get_object@@YAPEAUCowlIndividual@@PEAUCowlObjPropAssertAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropAssertAxiomGetObject(__IntPtr axiom);
        }

        /// <summary>Returns an object property assertion axiom.</summary>
        /// <param name="prop">The object property.</param>
        /// <param name="subject">The assertion subject.</param>
        /// <param name="object">The assertion object.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlObjPropAssertAxiom CowlObjPropAssertAxiom(__IntPtr prop, __IntPtr subject, __IntPtr @object, global::cowl.CowlVector annot)
        {
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlObjPropAssertAxiom(prop, subject, @object, __arg3);
            var __result0 = global::cowl.CowlObjPropAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns a negative object property assertion axiom.</summary>
        /// <param name="prop">The object property.</param>
        /// <param name="subject">The assertion subject.</param>
        /// <param name="object">The assertion object.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlObjPropAssertAxiom CowlNegObjPropAssertAxiom(__IntPtr prop, __IntPtr subject, __IntPtr @object, global::cowl.CowlVector annot)
        {
            var __arg3 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlNegObjPropAssertAxiom(prop, subject, @object, __arg3);
            var __result0 = global::cowl.CowlObjPropAssertAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns true if the specified object property assertion axiom is negative.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>True if the assertion is negative, false otherwise.</returns>
        public static bool CowlObjPropAssertAxiomIsNegative(global::cowl.CowlObjPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropAssertAxiomIsNegative(__arg0);
            return ___ret;
        }

        /// <summary>Gets the object property expression.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlObjPropAssertAxiomGetProp(global::cowl.CowlObjPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropAssertAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the assertion subject.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The assertion subject.</returns>
        public static global::cowl.CowlIndividual CowlObjPropAssertAxiomGetSubject(global::cowl.CowlObjPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropAssertAxiomGetSubject(__arg0);
            var __result0 = global::cowl.CowlIndividual.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the assertion object.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The assertion object.</returns>
        public static global::cowl.CowlIndividual CowlObjPropAssertAxiomGetObject(global::cowl.CowlObjPropAssertAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropAssertAxiomGetObject(__arg0);
            var __result0 = global::cowl.CowlIndividual.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjPropCharAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropCharAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropCharAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjPropCharAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjPropCharAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjPropCharAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjPropCharAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlObjPropCharAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjPropCharAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjPropCharAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjPropCharAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjPropCharAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjPropCharAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_prop_char_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_char_axiom@@YAPEAUCowlObjPropCharAxiom@@W4CowlCharAxiomType@@PEAXPEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropCharAxiom(global::cowl.CowlCharAxiomType type, __IntPtr prop, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_char_axiom_get_type@@YA?AW4CowlCharAxiomType@@PEAUCowlObjPropCharAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlCharAxiomType CowlObjPropCharAxiomGetType(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_char_axiom_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjPropCharAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropCharAxiomGetProp(__IntPtr axiom);
        }

        /// <summary>Returns an object property characteristic axiom.</summary>
        /// <param name="type">The type.</param>
        /// <param name="prop">The object property expression.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlObjPropCharAxiom CowlObjPropCharAxiom(global::cowl.CowlCharAxiomType type, __IntPtr prop, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlObjPropCharAxiom(type, prop, __arg2);
            var __result0 = global::cowl.CowlObjPropCharAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified object property characteristic axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The type.</returns>
        public static global::cowl.CowlCharAxiomType CowlObjPropCharAxiomGetType(global::cowl.CowlObjPropCharAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropCharAxiomGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the object property expression of the specified characteristic axiom.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object property expression.</returns>
        public static global::cowl.CowlObjPropExp CowlObjPropCharAxiomGetProp(global::cowl.CowlObjPropCharAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropCharAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjPropDomainAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropDomainAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropDomainAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjPropDomainAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjPropDomainAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjPropDomainAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjPropDomainAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlObjPropDomainAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjPropDomainAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjPropDomainAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjPropDomainAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjPropDomainAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjPropDomainAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_prop_domain_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_domain_axiom@@YAPEAUCowlObjPropDomainAxiom@@PEAX0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropDomainAxiom(__IntPtr prop, __IntPtr domain, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_domain_axiom_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropDomainAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_domain_axiom_get_domain@@YAPEAUCowlClsExp@@PEAUCowlObjPropDomainAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropDomainAxiomGetDomain(__IntPtr axiom);
        }

        /// <summary>Returns an object property domain axiom.</summary>
        /// <param name="prop">The object property.</param>
        /// <param name="domain">Domain of the object property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlObjPropDomainAxiom CowlObjPropDomainAxiom(__IntPtr prop, __IntPtr domain, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlObjPropDomainAxiom(prop, domain, __arg2);
            var __result0 = global::cowl.CowlObjPropDomainAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the object property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object property.</returns>
        public static global::cowl.CowlObjPropExp CowlObjPropDomainAxiomGetProp(global::cowl.CowlObjPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropDomainAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the domain of the object property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Domain of the object property.</returns>
        public static global::cowl.CowlClsExp CowlObjPropDomainAxiomGetDomain(global::cowl.CowlObjPropDomainAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropDomainAxiomGetDomain(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class cowl_obj_prop_exp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_exp_is_inverse@@YA_NPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlObjPropExpIsInverse(__IntPtr exp);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_prop_exp_get_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropExpGetProp(__IntPtr exp);
        }

        /// <summary>Returns true if the object property expression is inverse.</summary>
        /// <param name="exp">The object property expression.</param>
        /// <returns>True if the expression is inverse, false otherwise.</returns>
        public static bool CowlObjPropExpIsInverse(__IntPtr exp)
        {
            var ___ret = __Internal.CowlObjPropExpIsInverse(exp);
            return ___ret;
        }

        /// <summary>Gets the underlying object property.</summary>
        /// <param name="exp">The object property expression.</param>
        /// <returns>The object property.</returns>
        public static global::cowl.CowlObjProp CowlObjPropExpGetProp(__IntPtr exp)
        {
            var ___ret = __Internal.CowlObjPropExpGetProp(exp);
            var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjPropRangeAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropRangeAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjPropRangeAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjPropRangeAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjPropRangeAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjPropRangeAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjPropRangeAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlObjPropRangeAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjPropRangeAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjPropRangeAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjPropRangeAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjPropRangeAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjPropRangeAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_prop_range_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_prop_range_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropRangeAxiom(__IntPtr prop, __IntPtr range, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_range_axiom_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropRangeAxiomGetProp(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_prop_range_axiom_get_range@@YAPEAUCowlClsExp@@PEAUCowlObjPropRangeAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjPropRangeAxiomGetRange(__IntPtr axiom);
        }

        /// <summary>Returns an object property range axiom.</summary>
        /// <param name="prop">The object property.</param>
        /// <param name="range">Range of the object property.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlObjPropRangeAxiom CowlObjPropRangeAxiom(__IntPtr prop, __IntPtr range, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlObjPropRangeAxiom(prop, range, __arg2);
            var __result0 = global::cowl.CowlObjPropRangeAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the object property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The object property.</returns>
        public static global::cowl.CowlObjPropExp CowlObjPropRangeAxiomGetProp(global::cowl.CowlObjPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropRangeAxiomGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the range of the object property.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Range of the object property.</returns>
        public static global::cowl.CowlClsExp CowlObjPropRangeAxiomGetRange(global::cowl.CowlObjPropRangeAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlObjPropRangeAxiomGetRange(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlObjQuant
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjQuant> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlObjQuant>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlObjQuant managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlObjQuant managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlObjQuant __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlObjQuant(native.ToPointer(), skipVTables);
        }

        internal static CowlObjQuant __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlObjQuant)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlObjQuant __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlObjQuant(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlObjQuant(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlObjQuant(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_obj_quant
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_quant", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjQuant(global::cowl.CowlQuantType type, __IntPtr prop, __IntPtr filler);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_quant_get_type@@YA?AW4CowlQuantType@@PEAUCowlObjQuant@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlQuantType CowlObjQuantGetType(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_obj_quant_get_prop@@YAPEAUCowlObjPropExp@@PEAUCowlObjQuant@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjQuantGetProp(__IntPtr restr);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_obj_quant_get_filler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlObjQuantGetFiller(__IntPtr restr);
        }

        /// <summary>Returns an object quantifier.</summary>
        /// <param name="type">Object quantifier type.</param>
        /// <param name="prop">The object property.</param>
        /// <param name="filler">Filler of the quantifier.</param>
        /// <returns>Object quantifier, or NULL on error.</returns>
        public static global::cowl.CowlObjQuant CowlObjQuant(global::cowl.CowlQuantType type, __IntPtr prop, __IntPtr filler)
        {
            var ___ret = __Internal.CowlObjQuant(type, prop, filler);
            var __result0 = global::cowl.CowlObjQuant.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the type of the specified object quantifier.</summary>
        /// <param name="restr">The object quantifier.</param>
        /// <returns>The type of the object quantifier.</returns>
        public static global::cowl.CowlQuantType CowlObjQuantGetType(global::cowl.CowlObjQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjQuantGetType(__arg0);
            return ___ret;
        }

        /// <summary>Gets the object property.</summary>
        /// <param name="restr">The object quantifier.</param>
        /// <returns>The object property.</returns>
        public static global::cowl.CowlObjPropExp CowlObjQuantGetProp(global::cowl.CowlObjQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjQuantGetProp(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the filler of the specified object quantifier.</summary>
        /// <param name="restr">The object quantifier.</param>
        /// <returns>Range of the object quantifier.</returns>
        public static global::cowl.CowlClsExp CowlObjQuantGetFiller(global::cowl.CowlObjQuant restr)
        {
            var __arg0 = restr is null ? __IntPtr.Zero : restr.__Instance;
            var ___ret = __Internal.CowlObjQuantGetFiller(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Axiom filter.</summary>
    public unsafe partial class cowl_ontology
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_manager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOntologyGetManager(__IntPtr onto);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_sym_table", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOntologyGetSymTable(__IntPtr onto);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlOntologyId.__Internal CowlOntologyGetId(__IntPtr onto);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_set_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlOntologySetIri(__IntPtr onto, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_set_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlOntologySetVersion(__IntPtr onto, __IntPtr version);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_annot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOntologyGetAnnot(__IntPtr onto);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_add_annot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOntologyAddAnnot(__IntPtr onto, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_remove_annot", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyRemoveAnnot(__IntPtr onto, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_import", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOntologyGetImport(__IntPtr onto, __IntPtr iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_get_import_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOntologyGetImportIri(__IntPtr onto, __IntPtr import);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_add_import", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOntologyAddImport(__IntPtr onto, __IntPtr import);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_remove_import", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyRemoveImport(__IntPtr onto, __IntPtr import);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_add_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOntologyAddAxiom(__IntPtr onto, __IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_remove_axiom", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyRemoveAxiom(__IntPtr onto, __IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_remove_axioms_matching", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyRemoveAxiomsMatching(__IntPtr onto, __IntPtr filter);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_axiom_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyAxiomCount(__IntPtr onto, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_imports_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyImportsCount(__IntPtr onto, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_axiom_count_for_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyAxiomCountForType(__IntPtr onto, global::cowl.CowlAxiomType type, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_axiom_count_for_types", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyAxiomCountForTypes(__IntPtr onto, ulong types, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_axiom_count_for_primitive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyAxiomCountForPrimitive(__IntPtr onto, __IntPtr primitive, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_primitives_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlOntologyPrimitivesCount(__IntPtr onto, byte flags, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_has_primitive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyHasPrimitive(__IntPtr onto, __IntPtr primitive, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_has_axiom", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyHasAxiom(__IntPtr onto, __IntPtr axiom, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_primitives", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIteratePrimitives(__IntPtr onto, byte flags, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_imports", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateImports(__IntPtr onto, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_import_iris", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateImportIris(__IntPtr onto, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_axioms", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateAxioms(__IntPtr onto, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_axioms_of_type", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateAxiomsOfType(__IntPtr onto, global::cowl.CowlAxiomType type, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_axioms_of_types", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateAxiomsOfTypes(__IntPtr onto, ulong types, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_axioms_for_primitive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateAxiomsForPrimitive(__IntPtr onto, __IntPtr primitive, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_axioms_matching", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateAxiomsMatching(__IntPtr onto, __IntPtr filter, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ontology_iterate_related", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateRelated(__IntPtr onto, __IntPtr primitive, global::cowl.CowlAxiomType type, byte position, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_iterate_sub_classes@@YA_NPEAUCowlOntology@@PEAUCowlClass@@PEAUCowlIterator@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateSubClasses(__IntPtr onto, __IntPtr owl_class, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_iterate_super_classes@@YA_NPEAUCowlOntology@@PEAUCowlClass@@PEAUCowlIterator@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateSuperClasses(__IntPtr onto, __IntPtr owl_class, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_iterate_eq_classes@@YA_NPEAUCowlOntology@@PEAUCowlClass@@PEAUCowlIterator@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateEqClasses(__IntPtr onto, __IntPtr owl_class, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_iterate_disjoint_classes@@YA_NPEAUCowlOntology@@PEAUCowlClass@@PEAUCowlIterator@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateDisjointClasses(__IntPtr onto, __IntPtr owl_class, __IntPtr iter, bool imports);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_ontology_iterate_types@@YA_NPEAUCowlOntology@@PEAXPEAUCowlIterator@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlOntologyIterateTypes(__IntPtr onto, __IntPtr ind, __IntPtr iter, bool imports);
        }

        /// <summary>Gets the manager of this ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <returns>The manager.</returns>
        public static global::cowl.CowlManager CowlOntologyGetManager(global::cowl.CowlOntology onto)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyGetManager(__arg0);
            var __result0 = global::cowl.CowlManager.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the symbol table of this ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <returns>The symbol table.</returns>
        public static global::cowl.CowlSymTable CowlOntologyGetSymTable(global::cowl.CowlOntology onto)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyGetSymTable(__arg0);
            var __result0 = global::cowl.CowlSymTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the ontology ID.</summary>
        /// <param name="onto">The ontology.</param>
        /// <returns>The ontology ID.</returns>
        public static global::cowl.CowlOntologyId CowlOntologyGetId(global::cowl.CowlOntology onto)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyGetId(__arg0);
            return global::cowl.CowlOntologyId.__CreateInstance(___ret);
        }

        /// <summary>Sets the IRI of the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="iri">The IRI.</param>
        public static void CowlOntologySetIri(global::cowl.CowlOntology onto, global::cowl.CowlIRI iri)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            __Internal.CowlOntologySetIri(__arg0, __arg1);
        }

        /// <summary>Sets the version IRI of the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="version">The version IRI.</param>
        public static void CowlOntologySetVersion(global::cowl.CowlOntology onto, global::cowl.CowlIRI version)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = version is null ? __IntPtr.Zero : version.__Instance;
            __Internal.CowlOntologySetVersion(__arg0, __arg1);
        }

        /// <summary>Gets the annotations of the specified ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <returns>The annotations.</returns>
        public static global::cowl.CowlVector CowlOntologyGetAnnot(global::cowl.CowlOntology onto)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyGetAnnot(__arg0);
            var __result0 = global::cowl.CowlVector.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Adds an annotation to the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="annot">The annotation.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOntologyAddAnnot(global::cowl.CowlOntology onto, global::cowl.CowlAnnotation annot)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlOntologyAddAnnot(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Removes an annotation from the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="annot">The annotation.</param>
        /// <returns>True if the annotation was removed (it was found), false otherwise.</returns>
        public static bool CowlOntologyRemoveAnnot(global::cowl.CowlOntology onto, global::cowl.CowlAnnotation annot)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlOntologyRemoveAnnot(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Gets an imported ontology given its import IRI.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="iri">Import IRI.</param>
        /// <returns>Imported ontology.</returns>
        public static global::cowl.CowlOntology CowlOntologyGetImport(global::cowl.CowlOntology onto, global::cowl.CowlIRI iri)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = iri is null ? __IntPtr.Zero : iri.__Instance;
            var ___ret = __Internal.CowlOntologyGetImport(__arg0, __arg1);
            var __result0 = global::cowl.CowlOntology.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the import IRI of an imported ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="import">The imported ontology.</param>
        /// <returns>Import IRI.</returns>
        public static global::cowl.CowlIRI CowlOntologyGetImportIri(global::cowl.CowlOntology onto, global::cowl.CowlOntology import)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = import is null ? __IntPtr.Zero : import.__Instance;
            var ___ret = __Internal.CowlOntologyGetImportIri(__arg0, __arg1);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Adds an import to the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="import">IRI of the imported ontology.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOntologyAddImport(global::cowl.CowlOntology onto, global::cowl.CowlIRI import)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = import is null ? __IntPtr.Zero : import.__Instance;
            var ___ret = __Internal.CowlOntologyAddImport(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Removes an import from the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="import">IRI of the imported ontology.</param>
        /// <returns>True if the import was removed (it was found), false otherwise.</returns>
        public static bool CowlOntologyRemoveImport(global::cowl.CowlOntology onto, global::cowl.CowlIRI import)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = import is null ? __IntPtr.Zero : import.__Instance;
            var ___ret = __Internal.CowlOntologyRemoveImport(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Adds an axiom to the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOntologyAddAxiom(global::cowl.CowlOntology onto, __IntPtr axiom)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyAddAxiom(__arg0, axiom);
            return ___ret;
        }

        /// <summary>Removes an axiom from the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="axiom">The axiom.</param>
        /// <returns>True if the axiom was removed (it was found), false otherwise.</returns>
        public static bool CowlOntologyRemoveAxiom(global::cowl.CowlOntology onto, __IntPtr axiom)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyRemoveAxiom(__arg0, axiom);
            return ___ret;
        }

        /// <summary>Removes the axioms matching the provided filter function.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="filter">The filter.</param>
        /// <returns>Number of removed axioms.</returns>
        /// <remarks>The filter must not be used anymore after calling this function.</remarks>
        public static uint CowlOntologyRemoveAxiomsMatching(global::cowl.CowlOntology onto, global::cowl.CowlAxiomFilter filter)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = filter is null ? __IntPtr.Zero : filter.__Instance;
            var ___ret = __Internal.CowlOntologyRemoveAxiomsMatching(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Gets the number of axioms in the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of axioms.</returns>
        public static uint CowlOntologyAxiomCount(global::cowl.CowlOntology onto, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyAxiomCount(__arg0, imports);
            return ___ret;
        }

        /// <summary>Gets the number of imported ontologies.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of imports.</returns>
        public static uint CowlOntologyImportsCount(global::cowl.CowlOntology onto, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyImportsCount(__arg0, imports);
            return ___ret;
        }

        /// <summary>Gets the number of axioms of the specified type.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="type">The axiom type.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of axioms.</returns>
        public static uint CowlOntologyAxiomCountForType(global::cowl.CowlOntology onto, global::cowl.CowlAxiomType type, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyAxiomCountForType(__arg0, type, imports);
            return ___ret;
        }

        /// <summary>Gets the number of axioms of the specified types.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="types">The axiom types.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of axioms.</returns>
        public static uint CowlOntologyAxiomCountForTypes(global::cowl.CowlOntology onto, ulong types, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyAxiomCountForTypes(__arg0, types, imports);
            return ___ret;
        }

        /// <summary>Gets the number of axioms referencing the specified primitive.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="primitive">The primitive.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of axioms.</returns>
        public static uint CowlOntologyAxiomCountForPrimitive(global::cowl.CowlOntology onto, __IntPtr primitive, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyAxiomCountForPrimitive(__arg0, primitive, imports);
            return ___ret;
        }

        /// <summary>Gets the number of primitives.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="flags">Primitive flags.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>Number of primitives.</returns>
        public static uint CowlOntologyPrimitivesCount(global::cowl.CowlOntology onto, byte flags, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyPrimitivesCount(__arg0, flags, imports);
            return ___ret;
        }

        /// <summary>Checks if the specified primitive is referenced by an axiom in the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="primitive">The primitive.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the primitive is referenced by an axiom, false otherwise.</returns>
        public static bool CowlOntologyHasPrimitive(global::cowl.CowlOntology onto, __IntPtr primitive, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyHasPrimitive(__arg0, primitive, imports);
            return ___ret;
        }

        /// <summary>Checks whether the ontology contains the specified axiom.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="axiom">The axiom.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the ontology contains the axiom, false otherwise.</returns>
        public static bool CowlOntologyHasAxiom(global::cowl.CowlOntology onto, __IntPtr axiom, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOntologyHasAxiom(__arg0, axiom, imports);
            return ___ret;
        }

        /// <summary>Iterates over the primitives referenced by the specified ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="flags">Primitive flags.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIteratePrimitives(global::cowl.CowlOntology onto, byte flags, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIteratePrimitives(__arg0, flags, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the imported ontologies.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateImports(global::cowl.CowlOntology onto, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateImports(__arg0, __arg1, imports);
            return ___ret;
        }

        /// <summary>Iterates over the import IRIs.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateImportIris(global::cowl.CowlOntology onto, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateImportIris(__arg0, __arg1, imports);
            return ___ret;
        }

        /// <summary>Iterates over the axioms in the ontology.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateAxioms(global::cowl.CowlOntology onto, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateAxioms(__arg0, __arg1, imports);
            return ___ret;
        }

        /// <summary>Iterates over the axioms of a certain type.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="type">The axiom type.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateAxiomsOfType(global::cowl.CowlOntology onto, global::cowl.CowlAxiomType type, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateAxiomsOfType(__arg0, type, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the axiom of some types.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="types">The axiom types.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateAxiomsOfTypes(global::cowl.CowlOntology onto, ulong types, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateAxiomsOfTypes(__arg0, types, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the axioms referencing the specified primitive.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="primitive">The primitive.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateAxiomsForPrimitive(global::cowl.CowlOntology onto, __IntPtr primitive, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateAxiomsForPrimitive(__arg0, primitive, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the axioms matching the specified filter.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="filter">The filter.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        /// <remarks>The filter must not be used anymore after calling this function.</remarks>
        public static bool CowlOntologyIterateAxiomsMatching(global::cowl.CowlOntology onto, global::cowl.CowlAxiomFilter filter, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = filter is null ? __IntPtr.Zero : filter.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateAxiomsMatching(__arg0, __arg1, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the constructs that are related to the specified primitive by some axiom.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="primitive">The primitive.</param>
        /// <param name="type">Axiom type.</param>
        /// <param name="position">Position of the related constructs.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateRelated(global::cowl.CowlOntology onto, __IntPtr primitive, global::cowl.CowlAxiomType type, byte position, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg4 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateRelated(__arg0, primitive, type, position, __arg4, imports);
            return ___ret;
        }

        /// <summary>Iterates over the subclasses of the specified class.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="owl_class">The class.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateSubClasses(global::cowl.CowlOntology onto, global::cowl.CowlClass owl_class, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = owl_class is null ? __IntPtr.Zero : owl_class.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateSubClasses(__arg0, __arg1, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the superclasses of the specified class.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="owl_class">The class.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateSuperClasses(global::cowl.CowlOntology onto, global::cowl.CowlClass owl_class, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = owl_class is null ? __IntPtr.Zero : owl_class.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateSuperClasses(__arg0, __arg1, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the equivalent classes of the specified class.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="owl_class">The class.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateEqClasses(global::cowl.CowlOntology onto, global::cowl.CowlClass owl_class, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = owl_class is null ? __IntPtr.Zero : owl_class.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateEqClasses(__arg0, __arg1, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the disjoint classes of the specified class.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="owl_class">The class.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateDisjointClasses(global::cowl.CowlOntology onto, global::cowl.CowlClass owl_class, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg1 = owl_class is null ? __IntPtr.Zero : owl_class.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateDisjointClasses(__arg0, __arg1, __arg2, imports);
            return ___ret;
        }

        /// <summary>Iterates over the types of the specified individual.</summary>
        /// <param name="onto">The ontology.</param>
        /// <param name="ind">The individual.</param>
        /// <param name="iter">The iterator.</param>
        /// <param name="imports">If true, the query recurses over imported ontologies.</param>
        /// <returns>True if the iteration was completed, false if it was stopped.</returns>
        public static bool CowlOntologyIterateTypes(global::cowl.CowlOntology onto, __IntPtr ind, global::cowl.CowlIterator iter, bool imports)
        {
            var __arg0 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var __arg2 = iter is null ? __IntPtr.Zero : iter.__Instance;
            var ___ret = __Internal.CowlOntologyIterateTypes(__arg0, ind, __arg2, imports);
            return ___ret;
        }
    }

    public unsafe partial class cowl_ostream
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_get_manager", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOstreamGetManager(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_get_sym_table", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOstreamGetSymTable(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_write_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOstreamWriteHeader(__IntPtr stream, global::cowl.CowlOntologyHeader.__Internal header);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_write_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOstreamWriteAxiom(__IntPtr stream, __IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_write_footer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOstreamWriteFooter(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_ostream_write_ontology", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlOstreamWriteOntology(__IntPtr stream, __IntPtr onto);
        }

        /// <summary>Gets the manager of this ontology output stream.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <returns>The manager.</returns>
        public static global::cowl.CowlManager CowlOstreamGetManager(global::cowl.CowlOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlOstreamGetManager(__arg0);
            var __result0 = global::cowl.CowlManager.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the symbol table of this ontology output stream.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <returns>The symbol table.</returns>
        public static global::cowl.CowlSymTable CowlOstreamGetSymTable(global::cowl.CowlOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlOstreamGetSymTable(__arg0);
            var __result0 = global::cowl.CowlSymTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Writes the ontology header.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <param name="header">The ontology header.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOstreamWriteHeader(global::cowl.CowlOStream stream, global::cowl.CowlOntologyHeader header)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            if (ReferenceEquals(header, null))
                throw new global::System.ArgumentNullException("header", "Cannot be null because it is passed by value.");
            var __arg1 = header.__Instance;
            var ___ret = __Internal.CowlOstreamWriteHeader(__arg0, *(global::cowl.CowlOntologyHeader.__Internal*) __arg1);
            return ___ret;
        }

        /// <summary>Writes an axiom.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <param name="axiom">The axiom.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOstreamWriteAxiom(global::cowl.CowlOStream stream, __IntPtr axiom)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlOstreamWriteAxiom(__arg0, axiom);
            return ___ret;
        }

        /// <summary>Writes the ontology footer.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOstreamWriteFooter(global::cowl.CowlOStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.CowlOstreamWriteFooter(__arg0);
            return ___ret;
        }

        /// <summary>Writes the specified ontology to the stream.</summary>
        /// <param name="stream">The ontology output stream.</param>
        /// <param name="onto">The ontology.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlOstreamWriteOntology(global::cowl.CowlOStream stream, global::cowl.CowlOntology onto)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = onto is null ? __IntPtr.Zero : onto.__Instance;
            var ___ret = __Internal.CowlOstreamWriteOntology(__arg0, __arg1);
            return ___ret;
        }
    }

    /// <summary>Vocabulary of OWL IRIs.</summary>
    /// <summary>Vocabulary of OWL classes.</summary>
    /// <summary>Vocabulary of OWL datatypes.</summary>
    /// <summary>Vocabulary of OWL object properties.</summary>
    /// <summary>Vocabulary of OWL data properties.</summary>
    /// <summary>Vocabulary of OWL annotation properties.</summary>
    /// <summary>The OWL 2 vocabulary.</summary>
    /// <summary>Vocabulary of OWL IRIs.</summary>
    public unsafe partial class CowlOWLIRIVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal __IntPtr backward_comp;
            internal __IntPtr bottom_data_prop;
            internal __IntPtr bottom_obj_prop;
            internal __IntPtr deprecated;
            internal __IntPtr incompatible;
            internal __IntPtr nothing;
            internal __IntPtr prior_version;
            internal __IntPtr rational;
            internal __IntPtr real;
            internal __IntPtr version_info;
            internal __IntPtr thing;
            internal __IntPtr top_data_prop;
            internal __IntPtr top_obj_prop;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLIRIVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLIRIVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLIRIVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLIRIVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLIRIVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLIRIVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLIRIVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLIRIVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLIRIVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLIRIVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLIRIVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLIRIVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLIRIVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLIRIVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLIRIVocab(global::cowl.CowlOWLIRIVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLIRIVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLIRIVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:backwardCompatibleWith</summary>
        public global::cowl.CowlIRI BackwardComp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->backward_comp, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->backward_comp = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:bottomDataProperty</summary>
        public global::cowl.CowlIRI BottomDataProp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->bottom_data_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->bottom_data_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:bottomObjectProperty</summary>
        public global::cowl.CowlIRI BottomObjProp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->bottom_obj_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->bottom_obj_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:deprecated</summary>
        public global::cowl.CowlIRI Deprecated
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->deprecated, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->deprecated = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:incompatibleWith</summary>
        public global::cowl.CowlIRI Incompatible
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->incompatible, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->incompatible = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:Nothing</summary>
        public global::cowl.CowlIRI Nothing
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->nothing, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nothing = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:priorVersion</summary>
        public global::cowl.CowlIRI PriorVersion
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->prior_version, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prior_version = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:rational</summary>
        public global::cowl.CowlIRI Rational
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->rational, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->rational = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:real</summary>
        public global::cowl.CowlIRI Real
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->real, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->real = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:version_info</summary>
        public global::cowl.CowlIRI VersionInfo
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->version_info, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->version_info = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:Thing</summary>
        public global::cowl.CowlIRI Thing
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->thing, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->thing = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:topDataProperty</summary>
        public global::cowl.CowlIRI TopDataProp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->top_data_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->top_data_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:topObjectProperty</summary>
        public global::cowl.CowlIRI TopObjProp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->top_obj_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->top_obj_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of OWL classes.</summary>
    public unsafe partial class CowlOWLClassVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr thing;
            internal __IntPtr nothing;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLClassVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLClassVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLClassVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLClassVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLClassVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLClassVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLClassVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLClassVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLClassVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLClassVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLClassVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLClassVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLClassVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLClassVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLClassVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLClassVocab(global::cowl.CowlOWLClassVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLClassVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLClassVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLClassVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:Thing</summary>
        public global::cowl.CowlClass Thing
        {
            get
            {
                var __result0 = global::cowl.CowlClass.__GetOrCreateInstance(((__Internal*)__Instance)->thing, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->thing = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:Nothing</summary>
        public global::cowl.CowlClass Nothing
        {
            get
            {
                var __result0 = global::cowl.CowlClass.__GetOrCreateInstance(((__Internal*)__Instance)->nothing, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nothing = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of OWL datatypes.</summary>
    public unsafe partial class CowlOWLDatatypeVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr rational;
            internal __IntPtr real;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLDatatypeVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLDatatypeVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLDatatypeVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLDatatypeVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLDatatypeVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLDatatypeVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLDatatypeVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLDatatypeVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLDatatypeVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLDatatypeVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLDatatypeVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLDatatypeVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLDatatypeVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLDatatypeVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLDatatypeVocab(global::cowl.CowlOWLDatatypeVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLDatatypeVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLDatatypeVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:rational</summary>
        public global::cowl.CowlDatatype Rational
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->rational, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->rational = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:real</summary>
        public global::cowl.CowlDatatype Real
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->real, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->real = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of OWL object properties.</summary>
    public unsafe partial class CowlOWLObjPropVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr top_obj_prop;
            internal __IntPtr bottom_obj_prop;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLObjPropVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLObjPropVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLObjPropVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLObjPropVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLObjPropVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLObjPropVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLObjPropVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLObjPropVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLObjPropVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLObjPropVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLObjPropVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLObjPropVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLObjPropVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLObjPropVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLObjPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLObjPropVocab(global::cowl.CowlOWLObjPropVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLObjPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLObjPropVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLObjPropVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:topObjectProperty</summary>
        public global::cowl.CowlObjProp TopObjProp
        {
            get
            {
                var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(((__Internal*)__Instance)->top_obj_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->top_obj_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:bottomObjectProperty</summary>
        public global::cowl.CowlObjProp BottomObjProp
        {
            get
            {
                var __result0 = global::cowl.CowlObjProp.__GetOrCreateInstance(((__Internal*)__Instance)->bottom_obj_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->bottom_obj_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of OWL data properties.</summary>
    public unsafe partial class CowlOWLDataPropVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr top_data_prop;
            internal __IntPtr bottom_data_prop;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLDataPropVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLDataPropVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLDataPropVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLDataPropVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLDataPropVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLDataPropVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLDataPropVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLDataPropVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLDataPropVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLDataPropVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLDataPropVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLDataPropVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLDataPropVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLDataPropVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLDataPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLDataPropVocab(global::cowl.CowlOWLDataPropVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLDataPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLDataPropVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLDataPropVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:topDataProperty</summary>
        public global::cowl.CowlDataProp TopDataProp
        {
            get
            {
                var __result0 = global::cowl.CowlDataProp.__GetOrCreateInstance(((__Internal*)__Instance)->top_data_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->top_data_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:bottomDataProperty</summary>
        public global::cowl.CowlDataProp BottomDataProp
        {
            get
            {
                var __result0 = global::cowl.CowlDataProp.__GetOrCreateInstance(((__Internal*)__Instance)->bottom_data_prop, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->bottom_data_prop = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of OWL annotation properties.</summary>
    public unsafe partial class CowlOWLAnnotPropVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr backward_comp;
            internal __IntPtr deprecated;
            internal __IntPtr incompatible;
            internal __IntPtr prior_version;
            internal __IntPtr version_info;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLAnnotPropVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLAnnotPropVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLAnnotPropVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLAnnotPropVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLAnnotPropVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLAnnotPropVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLAnnotPropVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLAnnotPropVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLAnnotPropVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLAnnotPropVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLAnnotPropVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLAnnotPropVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLAnnotPropVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLAnnotPropVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLAnnotPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLAnnotPropVocab(global::cowl.CowlOWLAnnotPropVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLAnnotPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLAnnotPropVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLAnnotPropVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>owl:backwardCompatibleWith</summary>
        public global::cowl.CowlAnnotProp BackwardComp
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->backward_comp, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->backward_comp = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:deprecated</summary>
        public global::cowl.CowlAnnotProp Deprecated
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->deprecated, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->deprecated = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:incompatibleWith</summary>
        public global::cowl.CowlAnnotProp Incompatible
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->incompatible, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->incompatible = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:priorVersion</summary>
        public global::cowl.CowlAnnotProp PriorVersion
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->prior_version, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prior_version = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>owl:version_info</summary>
        public global::cowl.CowlAnnotProp VersionInfo
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->version_info, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->version_info = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>The OWL 2 vocabulary.</summary>
    public unsafe partial class CowlOWLVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 224)]
        public partial struct __Internal
        {
            internal __IntPtr ns;
            internal __IntPtr prefix;
            internal global::cowl.CowlOWLIRIVocab.__Internal iri;
            internal global::cowl.CowlOWLClassVocab.__Internal cls;
            internal global::cowl.CowlOWLDatatypeVocab.__Internal dt;
            internal global::cowl.CowlOWLObjPropVocab.__Internal obj_prop;
            internal global::cowl.CowlOWLDataPropVocab.__Internal data_prop;
            internal global::cowl.CowlOWLAnnotPropVocab.__Internal annot_prop;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlOWLVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlOWLVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlOWLVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlOWLVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlOWLVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlOWLVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlOWLVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlOWLVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlOWLVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlOWLVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlOWLVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlOWLVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlOWLVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlOWLVocab(global::cowl.CowlOWLVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlOWLVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlOWLVocab.__Internal*) __Instance) = *((global::cowl.CowlOWLVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>OWL namespace.</summary>
        public global::cowl.CowlString Ns
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->ns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>OWL prefix.</summary>
        public global::cowl.CowlString Prefix
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->prefix, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prefix = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>IRIs sub-vocabulary.</summary>
        public global::cowl.CowlOWLIRIVocab Iri
        {
            get
            {
                return global::cowl.CowlOWLIRIVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->iri));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->iri = *(global::cowl.CowlOWLIRIVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Classes sub-vocabulary.</summary>
        public global::cowl.CowlOWLClassVocab Cls
        {
            get
            {
                return global::cowl.CowlOWLClassVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cls));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cls = *(global::cowl.CowlOWLClassVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Datatypes sub-vocabulary.</summary>
        public global::cowl.CowlOWLDatatypeVocab Dt
        {
            get
            {
                return global::cowl.CowlOWLDatatypeVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dt = *(global::cowl.CowlOWLDatatypeVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Object properties sub-vocabulary.</summary>
        public global::cowl.CowlOWLObjPropVocab ObjProp
        {
            get
            {
                return global::cowl.CowlOWLObjPropVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj_prop));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj_prop = *(global::cowl.CowlOWLObjPropVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Data properties sub-vocabulary.</summary>
        public global::cowl.CowlOWLDataPropVocab DataProp
        {
            get
            {
                return global::cowl.CowlOWLDataPropVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->data_prop));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->data_prop = *(global::cowl.CowlOWLDataPropVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Annotation properties sub-vocabulary.</summary>
        public global::cowl.CowlOWLAnnotPropVocab AnnotProp
        {
            get
            {
                return global::cowl.CowlOWLAnnotPropVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->annot_prop));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->annot_prop = *(global::cowl.CowlOWLAnnotPropVocab.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_owl_vocab
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_owl_vocab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlOwlVocab();
        }

        /// <summary>Returns the OWL 2 vocabulary.</summary>
        /// <returns>The OWL 2 vocabulary.</returns>
        public static global::cowl.CowlOWLVocab CowlOwlVocab()
        {
            var ___ret = __Internal.CowlOwlVocab();
            var __result0 = global::cowl.CowlOWLVocab.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Vocabulary of RDF IRIs.</summary>
    /// <summary>Vocabulary of RDF datatypes.</summary>
    /// <summary>The RDF vocabulary.</summary>
    /// <summary>Vocabulary of RDF IRIs.</summary>
    public unsafe partial class CowlRDFIRIVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr lang_range;
            internal __IntPtr lang_string;
            internal __IntPtr plain_literal;
            internal __IntPtr xml_literal;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFIRIVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFIRIVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFIRIVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFIRIVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFIRIVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFIRIVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFIRIVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFIRIVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFIRIVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFIRIVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFIRIVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFIRIVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFIRIVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFIRIVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFIRIVocab(global::cowl.CowlRDFIRIVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFIRIVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFIRIVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>rdf:langRange</summary>
        public global::cowl.CowlIRI LangRange
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->lang_range, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->lang_range = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdf:langString</summary>
        public global::cowl.CowlIRI LangString
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->lang_string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->lang_string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdf:PlainLiteral</summary>
        public global::cowl.CowlIRI PlainLiteral
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->plain_literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->plain_literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdf:XMLLiteral</summary>
        public global::cowl.CowlIRI XmlLiteral
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xml_literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xml_literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of RDF datatypes.</summary>
    public unsafe partial class CowlRDFDatatypeVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr lang_string;
            internal __IntPtr plain_literal;
            internal __IntPtr xml_literal;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFDatatypeVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFDatatypeVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFDatatypeVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFDatatypeVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFDatatypeVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFDatatypeVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFDatatypeVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFDatatypeVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFDatatypeVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFDatatypeVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFDatatypeVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFDatatypeVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFDatatypeVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFDatatypeVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFDatatypeVocab(global::cowl.CowlRDFDatatypeVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFDatatypeVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFDatatypeVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>rdf:langString</summary>
        public global::cowl.CowlDatatype LangString
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->lang_string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->lang_string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdf:PlainLiteral</summary>
        public global::cowl.CowlDatatype PlainLiteral
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->plain_literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->plain_literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdf:XMLLiteral</summary>
        public global::cowl.CowlDatatype XmlLiteral
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xml_literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xml_literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>The RDF vocabulary.</summary>
    public unsafe partial class CowlRDFVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal __IntPtr ns;
            internal __IntPtr prefix;
            internal global::cowl.CowlRDFIRIVocab.__Internal iri;
            internal global::cowl.CowlRDFDatatypeVocab.__Internal dt;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFVocab(global::cowl.CowlRDFVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>RDF namespace.</summary>
        public global::cowl.CowlString Ns
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->ns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>RDF prefix.</summary>
        public global::cowl.CowlString Prefix
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->prefix, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prefix = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>IRIs sub-vocabulary.</summary>
        public global::cowl.CowlRDFIRIVocab Iri
        {
            get
            {
                return global::cowl.CowlRDFIRIVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->iri));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->iri = *(global::cowl.CowlRDFIRIVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Datatypes sub-vocabulary.</summary>
        public global::cowl.CowlRDFDatatypeVocab Dt
        {
            get
            {
                return global::cowl.CowlRDFDatatypeVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dt = *(global::cowl.CowlRDFDatatypeVocab.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_rdf_vocab
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_rdf_vocab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlRdfVocab();
        }

        /// <summary>Returns the RDF vocabulary.</summary>
        /// <returns>The RDF vocabulary.</returns>
        public static global::cowl.CowlRDFVocab CowlRdfVocab()
        {
            var ___ret = __Internal.CowlRdfVocab();
            var __result0 = global::cowl.CowlRDFVocab.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Vocabulary of RDFS IRIs.</summary>
    /// <summary>Vocabulary of RDFS datatypes.</summary>
    /// <summary>Vocabulary of RDFS annotation properties.</summary>
    /// <summary>The RDFS vocabulary.</summary>
    /// <summary>Vocabulary of RDFS IRIs.</summary>
    public unsafe partial class CowlRDFSIRIVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr comment;
            internal __IntPtr defined_by;
            internal __IntPtr label;
            internal __IntPtr literal;
            internal __IntPtr see_also;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFSIRIVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSIRIVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSIRIVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFSIRIVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFSIRIVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFSIRIVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFSIRIVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFSIRIVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFSIRIVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFSIRIVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFSIRIVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFSIRIVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFSIRIVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFSIRIVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFSIRIVocab(global::cowl.CowlRDFSIRIVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFSIRIVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFSIRIVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>rdfs:comment</summary>
        public global::cowl.CowlIRI Comment
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->comment, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->comment = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:isDefinedBy</summary>
        public global::cowl.CowlIRI DefinedBy
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->defined_by, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->defined_by = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:label</summary>
        public global::cowl.CowlIRI Label
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->label, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->label = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:Literal</summary>
        public global::cowl.CowlIRI Literal
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:seeAlso</summary>
        public global::cowl.CowlIRI SeeAlso
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->see_also, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->see_also = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of RDFS datatypes.</summary>
    public unsafe partial class CowlRDFSDatatypeVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr literal;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFSDatatypeVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSDatatypeVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSDatatypeVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFSDatatypeVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFSDatatypeVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFSDatatypeVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFSDatatypeVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFSDatatypeVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFSDatatypeVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFSDatatypeVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFSDatatypeVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFSDatatypeVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFSDatatypeVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFSDatatypeVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFSDatatypeVocab(global::cowl.CowlRDFSDatatypeVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFSDatatypeVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFSDatatypeVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>rdfs:Literal</summary>
        public global::cowl.CowlDatatype Literal
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->literal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->literal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of RDFS annotation properties.</summary>
    public unsafe partial class CowlRDFSAnnotPropVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr comment;
            internal __IntPtr defined_by;
            internal __IntPtr label;
            internal __IntPtr see_also;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFSAnnotPropVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSAnnotPropVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSAnnotPropVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFSAnnotPropVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFSAnnotPropVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFSAnnotPropVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFSAnnotPropVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFSAnnotPropVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFSAnnotPropVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFSAnnotPropVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFSAnnotPropVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFSAnnotPropVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFSAnnotPropVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFSAnnotPropVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSAnnotPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFSAnnotPropVocab(global::cowl.CowlRDFSAnnotPropVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSAnnotPropVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFSAnnotPropVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFSAnnotPropVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>rdfs:comment</summary>
        public global::cowl.CowlAnnotProp Comment
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->comment, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->comment = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:isDefinedBy</summary>
        public global::cowl.CowlAnnotProp DefinedBy
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->defined_by, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->defined_by = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:label</summary>
        public global::cowl.CowlAnnotProp Label
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->label, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->label = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>rdfs:seeAlso</summary>
        public global::cowl.CowlAnnotProp SeeAlso
        {
            get
            {
                var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(((__Internal*)__Instance)->see_also, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->see_also = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>The RDFS vocabulary.</summary>
    public unsafe partial class CowlRDFSVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal __IntPtr ns;
            internal __IntPtr prefix;
            internal global::cowl.CowlRDFSIRIVocab.__Internal iri;
            internal global::cowl.CowlRDFSDatatypeVocab.__Internal dt;
            internal global::cowl.CowlRDFSAnnotPropVocab.__Internal annot_prop;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlRDFSVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlRDFSVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlRDFSVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlRDFSVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlRDFSVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlRDFSVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlRDFSVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlRDFSVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlRDFSVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlRDFSVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlRDFSVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlRDFSVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlRDFSVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlRDFSVocab(global::cowl.CowlRDFSVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlRDFSVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlRDFSVocab.__Internal*) __Instance) = *((global::cowl.CowlRDFSVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>RDFS namespace.</summary>
        public global::cowl.CowlString Ns
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->ns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>RDFS prefix.</summary>
        public global::cowl.CowlString Prefix
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->prefix, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prefix = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>IRIs sub-vocabulary.</summary>
        public global::cowl.CowlRDFSIRIVocab Iri
        {
            get
            {
                return global::cowl.CowlRDFSIRIVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->iri));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->iri = *(global::cowl.CowlRDFSIRIVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Datatypes sub-vocabulary.</summary>
        public global::cowl.CowlRDFSDatatypeVocab Dt
        {
            get
            {
                return global::cowl.CowlRDFSDatatypeVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dt = *(global::cowl.CowlRDFSDatatypeVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Annotation properties sub-vocabulary.</summary>
        public global::cowl.CowlRDFSAnnotPropVocab AnnotProp
        {
            get
            {
                return global::cowl.CowlRDFSAnnotPropVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->annot_prop));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->annot_prop = *(global::cowl.CowlRDFSAnnotPropVocab.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_rdfs_vocab
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_rdfs_vocab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlRdfsVocab();
        }

        /// <summary>Returns the RDFS vocabulary.</summary>
        /// <returns>The RDFS vocabulary.</returns>
        public static global::cowl.CowlRDFSVocab CowlRdfsVocab()
        {
            var ___ret = __Internal.CowlRdfsVocab();
            var __result0 = global::cowl.CowlRDFSVocab.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlSubAnnotPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubAnnotPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubAnnotPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSubAnnotPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSubAnnotPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSubAnnotPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSubAnnotPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlSubAnnotPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSubAnnotPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSubAnnotPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSubAnnotPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSubAnnotPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSubAnnotPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_sub_annot_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_annot_prop_axiom@@YAPEAUCowlSubAnnotPropAxiom@@PEAUCowlAnnotProp@@0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubAnnotPropAxiom(__IntPtr sub, __IntPtr super, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_annot_prop_axiom_get_sub@@YAPEAUCowlAnnotProp@@PEAUCowlSubAnnotPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubAnnotPropAxiomGetSub(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_annot_prop_axiom_get_super@@YAPEAUCowlAnnotProp@@PEAUCowlSubAnnotPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubAnnotPropAxiomGetSuper(__IntPtr axiom);
        }

        /// <summary>Returns an annotation subproperty axiom.</summary>
        /// <param name="sub">The subproperty.</param>
        /// <param name="super">The superproperty.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlSubAnnotPropAxiom CowlSubAnnotPropAxiom(global::cowl.CowlAnnotProp sub, global::cowl.CowlAnnotProp super, global::cowl.CowlVector annot)
        {
            var __arg0 = sub is null ? __IntPtr.Zero : sub.__Instance;
            var __arg1 = super is null ? __IntPtr.Zero : super.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlSubAnnotPropAxiom(__arg0, __arg1, __arg2);
            var __result0 = global::cowl.CowlSubAnnotPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the subproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The subproperty.</returns>
        public static global::cowl.CowlAnnotProp CowlSubAnnotPropAxiomGetSub(global::cowl.CowlSubAnnotPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubAnnotPropAxiomGetSub(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the superproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The superproperty.</returns>
        public static global::cowl.CowlAnnotProp CowlSubAnnotPropAxiomGetSuper(global::cowl.CowlSubAnnotPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubAnnotPropAxiomGetSuper(__arg0);
            var __result0 = global::cowl.CowlAnnotProp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlSubClsAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubClsAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubClsAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSubClsAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSubClsAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSubClsAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSubClsAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlSubClsAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSubClsAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSubClsAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSubClsAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSubClsAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSubClsAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_sub_cls_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_cls_axiom@@YAPEAUCowlSubClsAxiom@@PEAX0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubClsAxiom(__IntPtr sub, __IntPtr super, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_cls_axiom_get_sub@@YAPEAUCowlClsExp@@PEAUCowlSubClsAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubClsAxiomGetSub(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_cls_axiom_get_super@@YAPEAUCowlClsExp@@PEAUCowlSubClsAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubClsAxiomGetSuper(__IntPtr axiom);
        }

        /// <summary>Returns a subclass axiom.</summary>
        /// <param name="sub">The subclass.</param>
        /// <param name="super">The superclass.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlSubClsAxiom CowlSubClsAxiom(__IntPtr sub, __IntPtr super, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlSubClsAxiom(sub, super, __arg2);
            var __result0 = global::cowl.CowlSubClsAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the subclass.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The subclass.</returns>
        public static global::cowl.CowlClsExp CowlSubClsAxiomGetSub(global::cowl.CowlSubClsAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubClsAxiomGetSub(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the superclass.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The superclass.</returns>
        public static global::cowl.CowlClsExp CowlSubClsAxiomGetSuper(global::cowl.CowlSubClsAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubClsAxiomGetSuper(__arg0);
            var __result0 = global::cowl.CowlClsExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlSubDataPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubDataPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubDataPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSubDataPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSubDataPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSubDataPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSubDataPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlSubDataPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSubDataPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSubDataPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSubDataPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSubDataPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSubDataPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_sub_data_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_data_prop_axiom@@YAPEAUCowlSubDataPropAxiom@@PEAX0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubDataPropAxiom(__IntPtr sub, __IntPtr super, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_data_prop_axiom_get_sub@@YAPEAUCowlDataPropExp@@PEAUCowlSubDataPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubDataPropAxiomGetSub(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_data_prop_axiom_get_super@@YAPEAUCowlDataPropExp@@PEAUCowlSubDataPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubDataPropAxiomGetSuper(__IntPtr axiom);
        }

        /// <summary>Returns a data subproperty axiom.</summary>
        /// <param name="sub">The subproperty.</param>
        /// <param name="super">The superproperty.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlSubDataPropAxiom CowlSubDataPropAxiom(__IntPtr sub, __IntPtr super, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlSubDataPropAxiom(sub, super, __arg2);
            var __result0 = global::cowl.CowlSubDataPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the subproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The subproperty.</returns>
        public static global::cowl.CowlDataPropExp CowlSubDataPropAxiomGetSub(global::cowl.CowlSubDataPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubDataPropAxiomGetSub(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the superproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The superproperty.</returns>
        public static global::cowl.CowlDataPropExp CowlSubDataPropAxiomGetSuper(global::cowl.CowlSubDataPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubDataPropAxiomGetSuper(__arg0);
            var __result0 = global::cowl.CowlDataPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlSubObjPropAxiom
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubObjPropAxiom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlSubObjPropAxiom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlSubObjPropAxiom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlSubObjPropAxiom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlSubObjPropAxiom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlSubObjPropAxiom(native.ToPointer(), skipVTables);
        }

        internal static CowlSubObjPropAxiom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlSubObjPropAxiom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlSubObjPropAxiom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlSubObjPropAxiom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlSubObjPropAxiom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlSubObjPropAxiom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_sub_obj_prop_axiom
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_obj_prop_axiom@@YAPEAUCowlSubObjPropAxiom@@PEAX0PEAUCowlVector@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubObjPropAxiom(__IntPtr sub, __IntPtr super, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sub_obj_prop_chain_axiom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubObjPropChainAxiom(__IntPtr sub, __IntPtr super, __IntPtr annot);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_obj_prop_axiom_get_sub@@YAPEAXPEAUCowlSubObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubObjPropAxiomGetSub(__IntPtr axiom);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sub_obj_prop_axiom_get_super@@YAPEAUCowlObjPropExp@@PEAUCowlSubObjPropAxiom@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSubObjPropAxiomGetSuper(__IntPtr axiom);
        }

        /// <summary>Returns an object subproperty axiom.</summary>
        /// <param name="sub">The subproperty.</param>
        /// <param name="super">The superproperty.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlSubObjPropAxiom CowlSubObjPropAxiom(__IntPtr sub, __IntPtr super, global::cowl.CowlVector annot)
        {
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlSubObjPropAxiom(sub, super, __arg2);
            var __result0 = global::cowl.CowlSubObjPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns an object subproperty axiom where the subproperty is a chain of properties.</summary>
        /// <param name="sub">The chain of properties.</param>
        /// <param name="super">The superproperty.</param>
        /// <param name="annot">{optional} The annotations.</param>
        /// <returns>Axiom, or NULL on error.</returns>
        public static global::cowl.CowlSubObjPropAxiom CowlSubObjPropChainAxiom(global::cowl.CowlVector sub, __IntPtr super, global::cowl.CowlVector annot)
        {
            var __arg0 = sub is null ? __IntPtr.Zero : sub.__Instance;
            var __arg2 = annot is null ? __IntPtr.Zero : annot.__Instance;
            var ___ret = __Internal.CowlSubObjPropChainAxiom(__arg0, super, __arg2);
            var __result0 = global::cowl.CowlSubObjPropAxiom.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Gets the subproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The subproperty.</returns>
        /// <remarks>The subproperty can be either an object property expression or a property expression chain.</remarks>
        public static __IntPtr CowlSubObjPropAxiomGetSub(global::cowl.CowlSubObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubObjPropAxiomGetSub(__arg0);
            return ___ret;
        }

        /// <summary>Gets the superproperty.</summary>
        /// <param name="axiom">The axiom.</param>
        /// <returns>The superproperty.</returns>
        public static global::cowl.CowlObjPropExp CowlSubObjPropAxiomGetSuper(global::cowl.CowlSubObjPropAxiom axiom)
        {
            var __arg0 = axiom is null ? __IntPtr.Zero : axiom.__Instance;
            var ___ret = __Internal.CowlSubObjPropAxiomGetSuper(__arg0);
            var __result0 = global::cowl.CowlObjPropExp.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class CowlTable
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlTable(native.ToPointer(), skipVTables);
        }

        internal static CowlTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class cowl_sym_table
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_get_prefix_ns_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableGetPrefixNsMap(__IntPtr st, bool reverse);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_get_ns", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableGetNs(__IntPtr st, __IntPtr prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_get_prefix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableGetPrefix(__IntPtr st, __IntPtr ns);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_register_prefix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlSymTableRegisterPrefix(__IntPtr st, __IntPtr prefix, __IntPtr ns, bool overwrite);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_register_prefix_raw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlSymTableRegisterPrefixRaw(__IntPtr st, global::cowl.UString.__Internal prefix, global::cowl.UString.__Internal ns, bool overwrite);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_unregister_prefix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlSymTableUnregisterPrefix(__IntPtr st, __IntPtr prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_unregister_ns", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlSymTableUnregisterNs(__IntPtr st, __IntPtr ns);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_merge", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.CowlRet CowlSymTableMerge(__IntPtr dst, __IntPtr src, bool overwrite);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_get_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableGetIri(__IntPtr st, global::cowl.UString.__Internal prefix, global::cowl.UString.__Internal rem);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_parse_short_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableParseShortIri(__IntPtr st, global::cowl.UString.__Internal short_iri);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_sym_table_parse_iri", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableParseIri(__IntPtr st, global::cowl.UString.__Internal str);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sym_table_get_full_iri@@YAPEAUCowlIRI@@PEAUCowlSymTable@@UUString@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableGetFullIri(__IntPtr st, global::cowl.UString.__Internal ns, global::cowl.UString.__Internal rem);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_sym_table_parse_full_iri@@YAPEAUCowlIRI@@PEAUCowlSymTable@@UUString@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlSymTableParseFullIri(__IntPtr st, global::cowl.UString.__Internal short_iri);
        }

        /// <summary>Gets the map that associates prefixes to namespaces.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="reverse">If true, the reversed map (namespaces to prefixes) is returned.</param>
        /// <returns>Prefix to namespace map, or NULL on error.</returns>
        public static global::cowl.CowlTable CowlSymTableGetPrefixNsMap(global::cowl.CowlSymTable st, bool reverse)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var ___ret = __Internal.CowlSymTableGetPrefixNsMap(__arg0, reverse);
            var __result0 = global::cowl.CowlTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the namespace associated with the specified prefix.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="prefix">The prefix.</param>
        /// <returns>Namespace associated with the prefix, or NULL if the prefix cannot be found.</returns>
        public static global::cowl.CowlString CowlSymTableGetNs(global::cowl.CowlSymTable st, global::cowl.CowlString prefix)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var __arg1 = prefix is null ? __IntPtr.Zero : prefix.__Instance;
            var ___ret = __Internal.CowlSymTableGetNs(__arg0, __arg1);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the prefix associated with the specified namespace.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="ns">The namespace.</param>
        /// <returns>Prefix associated with the namespace, or NULL if the prefix cannot be found.</returns>
        public static global::cowl.CowlString CowlSymTableGetPrefix(global::cowl.CowlSymTable st, global::cowl.CowlString ns)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var __arg1 = ns is null ? __IntPtr.Zero : ns.__Instance;
            var ___ret = __Internal.CowlSymTableGetPrefix(__arg0, __arg1);
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Registers the specified prefix-namespace mapping.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="prefix">The prefix.</param>
        /// <param name="ns">The namespace.</param>
        /// <param name="overwrite">If true, the new mapping overwrites the previous one.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlSymTableRegisterPrefix(global::cowl.CowlSymTable st, global::cowl.CowlString prefix, global::cowl.CowlString ns, bool overwrite)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var __arg1 = prefix is null ? __IntPtr.Zero : prefix.__Instance;
            var __arg2 = ns is null ? __IntPtr.Zero : ns.__Instance;
            var ___ret = __Internal.CowlSymTableRegisterPrefix(__arg0, __arg1, __arg2, overwrite);
            return ___ret;
        }

        /// <summary>Registers the specified prefix-namespace mapping.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="prefix">The prefix.</param>
        /// <param name="ns">The namespace.</param>
        /// <param name="overwrite">If true, the new mapping overwrites the previous one.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlSymTableRegisterPrefixRaw(global::cowl.CowlSymTable st, global::cowl.UString prefix, global::cowl.UString ns, bool overwrite)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(prefix, null))
                throw new global::System.ArgumentNullException("prefix", "Cannot be null because it is passed by value.");
            var __arg1 = prefix.__Instance;
            if (ReferenceEquals(ns, null))
                throw new global::System.ArgumentNullException("ns", "Cannot be null because it is passed by value.");
            var __arg2 = ns.__Instance;
            var ___ret = __Internal.CowlSymTableRegisterPrefixRaw(__arg0, *(global::cowl.UString.__Internal*) __arg1, *(global::cowl.UString.__Internal*) __arg2, overwrite);
            return ___ret;
        }

        /// <summary>Unregisters the specified prefix.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="prefix">The prefix.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlSymTableUnregisterPrefix(global::cowl.CowlSymTable st, global::cowl.CowlString prefix)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var __arg1 = prefix is null ? __IntPtr.Zero : prefix.__Instance;
            var ___ret = __Internal.CowlSymTableUnregisterPrefix(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Unregisters the specified namespace.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="ns">The namespace.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlSymTableUnregisterNs(global::cowl.CowlSymTable st, global::cowl.CowlString ns)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            var __arg1 = ns is null ? __IntPtr.Zero : ns.__Instance;
            var ___ret = __Internal.CowlSymTableUnregisterNs(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Merges the contents of a symbol table in the current one.</summary>
        /// <param name="dst">The destination symbol table.</param>
        /// <param name="src">The source symbol table.</param>
        /// <param name="overwrite">If true, conflicting prefixes are overwritten in the destination.</param>
        /// <returns>Return code.</returns>
        public static global::cowl.CowlRet CowlSymTableMerge(global::cowl.CowlSymTable dst, global::cowl.CowlSymTable src, bool overwrite)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.CowlSymTableMerge(__arg0, __arg1, overwrite);
            return ___ret;
        }

        /// <summary>Retrieves the full IRI associated with the specified short IRI prefix and remainder.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="prefix">The prefix.</param>
        /// <param name="rem">The remainder.</param>
        /// <returns>IRI instance, or NULL on error.</returns>
        public static global::cowl.CowlIRI CowlSymTableGetIri(global::cowl.CowlSymTable st, global::cowl.UString prefix, global::cowl.UString rem)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(prefix, null))
                throw new global::System.ArgumentNullException("prefix", "Cannot be null because it is passed by value.");
            var __arg1 = prefix.__Instance;
            if (ReferenceEquals(rem, null))
                throw new global::System.ArgumentNullException("rem", "Cannot be null because it is passed by value.");
            var __arg2 = rem.__Instance;
            var ___ret = __Internal.CowlSymTableGetIri(__arg0, *(global::cowl.UString.__Internal*) __arg1, *(global::cowl.UString.__Internal*) __arg2);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Parses an IRI from the specified short IRI.</summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="short_iri">The short IRI.</param>
        /// <returns>IRI instance, or NULL on error.</returns>
        public static global::cowl.CowlIRI CowlSymTableParseShortIri(global::cowl.CowlSymTable st, global::cowl.UString short_iri)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(short_iri, null))
                throw new global::System.ArgumentNullException("short_iri", "Cannot be null because it is passed by value.");
            var __arg1 = short_iri.__Instance;
            var ___ret = __Internal.CowlSymTableParseShortIri(__arg0, *(global::cowl.UString.__Internal*) __arg1);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Parses an IRI from the specified string, which must be the representation of either</para>
        /// <para>a short or a full IRI.</para>
        /// </summary>
        /// <param name="st">The symbol table.</param>
        /// <param name="str">The IRI string.</param>
        /// <returns>IRI instance, or NULL on error.</returns>
        public static global::cowl.CowlIRI CowlSymTableParseIri(global::cowl.CowlSymTable st, global::cowl.UString str)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(str, null))
                throw new global::System.ArgumentNullException("str", "Cannot be null because it is passed by value.");
            var __arg1 = str.__Instance;
            var ___ret = __Internal.CowlSymTableParseIri(__arg0, *(global::cowl.UString.__Internal*) __arg1);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::cowl.CowlIRI CowlSymTableGetFullIri(global::cowl.CowlSymTable st, global::cowl.UString ns, global::cowl.UString rem)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(ns, null))
                throw new global::System.ArgumentNullException("ns", "Cannot be null because it is passed by value.");
            var __arg1 = ns.__Instance;
            if (ReferenceEquals(rem, null))
                throw new global::System.ArgumentNullException("rem", "Cannot be null because it is passed by value.");
            var __arg2 = rem.__Instance;
            var ___ret = __Internal.CowlSymTableGetFullIri(__arg0, *(global::cowl.UString.__Internal*) __arg1, *(global::cowl.UString.__Internal*) __arg2);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::cowl.CowlIRI CowlSymTableParseFullIri(global::cowl.CowlSymTable st, global::cowl.UString short_iri)
        {
            var __arg0 = st is null ? __IntPtr.Zero : st.__Instance;
            if (ReferenceEquals(short_iri, null))
                throw new global::System.ArgumentNullException("short_iri", "Cannot be null because it is passed by value.");
            var __arg1 = short_iri.__Instance;
            var ___ret = __Internal.CowlSymTableParseFullIri(__arg0, *(global::cowl.UString.__Internal*) __arg1);
            var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class UHashCowlObjectTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal uint _size;
            internal uint _occupied;
            internal uint _count;
            internal __IntPtr _flags;
            internal __IntPtr _keys;
            internal __IntPtr _vals;
            internal __IntPtr _hfunc;
            internal __IntPtr _efunc;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_CowlObjectTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashCowlObjectTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashCowlObjectTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashCowlObjectTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashCowlObjectTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashCowlObjectTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashCowlObjectTable(native.ToPointer(), skipVTables);
        }

        internal static UHashCowlObjectTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashCowlObjectTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashCowlObjectTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashCowlObjectTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashCowlObjectTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashCowlObjectTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashCowlObjectTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashCowlObjectTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashCowlObjectTable(global::cowl.UHashCowlObjectTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashCowlObjectTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashCowlObjectTable.__Internal*) __Instance) = *((global::cowl.UHashCowlObjectTable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->_size;
            }

            set
            {
                ((__Internal*)__Instance)->_size = value;
            }
        }

        public uint Occupied
        {
            get
            {
                return ((__Internal*)__Instance)->_occupied;
            }

            set
            {
                ((__Internal*)__Instance)->_occupied = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->_count;
            }

            set
            {
                ((__Internal*)__Instance)->_count = value;
            }
        }

        public uint* Flags
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->_flags;
            }

            set
            {
                ((__Internal*)__Instance)->_flags = (__IntPtr) value;
            }
        }

        public __IntPtr* Keys
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_keys;
            }

            set
            {
                ((__Internal*)__Instance)->_keys = (__IntPtr) value;
            }
        }

        public __IntPtr* Vals
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->_vals;
            }

            set
            {
                ((__Internal*)__Instance)->_vals = (__IntPtr) value;
            }
        }

        public global::cowl.Delegates.Func_uint___IntPtr Hfunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_hfunc;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_uint___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_uint___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->_hfunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::cowl.Delegates.Func_bool___IntPtr___IntPtr Efunc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->_efunc;
                return __ptr0 == IntPtr.Zero? null : (global::cowl.Delegates.Func_bool___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::cowl.Delegates.Func_bool___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->_efunc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class UHashLoopCowlObjectTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr h;
            internal __IntPtr key;
            internal __IntPtr val;
            internal uint i;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0UHash_Loop_CowlObjectTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoopCowlObjectTable> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.UHashLoopCowlObjectTable>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.UHashLoopCowlObjectTable managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.UHashLoopCowlObjectTable managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UHashLoopCowlObjectTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UHashLoopCowlObjectTable(native.ToPointer(), skipVTables);
        }

        internal static UHashLoopCowlObjectTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UHashLoopCowlObjectTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UHashLoopCowlObjectTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UHashLoopCowlObjectTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UHashLoopCowlObjectTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UHashLoopCowlObjectTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UHashLoopCowlObjectTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoopCowlObjectTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UHashLoopCowlObjectTable(global::cowl.UHashLoopCowlObjectTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.UHashLoopCowlObjectTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.UHashLoopCowlObjectTable.__Internal*) __Instance) = *((global::cowl.UHashLoopCowlObjectTable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::cowl.UHashCowlObjectTable H
        {
            get
            {
                var __result0 = global::cowl.UHashCowlObjectTable.__GetOrCreateInstance(((__Internal*)__Instance)->h, false);
                return __result0;
            }
        }

        public __IntPtr* Key
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = (__IntPtr) value;
            }
        }

        public __IntPtr* Val
        {
            get
            {
                return (__IntPtr*)((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = (__IntPtr) value;
            }
        }

        public uint I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }
    }

    public unsafe partial class cowl_table
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_deinit_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeinitCowlObjectTable(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyCowlObjectTable(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_copy_as_set_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashCopyAsSetCowlObjectTable(__IntPtr src, __IntPtr dest);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_clear_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashClearCowlObjectTable(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_get_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashGetCowlObjectTable(__IntPtr h, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_resize_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashResizeCowlObjectTable(__IntPtr h, uint new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_put_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhashPutCowlObjectTable(__IntPtr h, __IntPtr key, uint* idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhash_delete_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashDeleteCowlObjectTable(__IntPtr h, uint x);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapCowlObjectTable(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_get_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhmapGetCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr if_missing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_set_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapSetCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_add_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhmapAddCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_replace_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapReplaceCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr value, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_remove_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhmapRemoveCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr* r_key, __IntPtr* r_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetCowlObjectTable(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr* existing);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_insert_all_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetInsertAllCowlObjectTable(__IntPtr h, __IntPtr* items, uint n);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_replace_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetReplaceCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr* replaced);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_remove_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetRemoveCowlObjectTable(__IntPtr h, __IntPtr key, __IntPtr* removed);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_is_superset_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetIsSupersetCowlObjectTable(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_union_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::cowl.UhashRet UhsetUnionCowlObjectTable(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_intersect_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetIntersectCowlObjectTable(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_hash_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhsetHashCowlObjectTable(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_get_any_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr UhsetGetAnyCowlObjectTable(__IntPtr h, __IntPtr if_empty);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhmap_pi_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhmapPiCowlObjectTable(__IntPtr @return, __IntPtr hash_func, __IntPtr equal_func);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "uhset_pi_CowlObjectTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhsetPiCowlObjectTable(__IntPtr @return, __IntPtr hash_func, __IntPtr equal_func);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_is_map_CowlObjectTable@@YA_NPEBUUHash_CowlObjectTable@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhashIsMapCowlObjectTable(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_move_CowlObjectTable@@YA?AUUHash_CowlObjectTable@@PEAU1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UhashMoveCowlObjectTable(__IntPtr @return, __IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhash_next_CowlObjectTable@@YAIPEBUUHash_CowlObjectTable@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint UhashNextCowlObjectTable(__IntPtr h, uint i);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?uhset_equals_CowlObjectTable@@YA_NPEBUUHash_CowlObjectTable@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool UhsetEqualsCowlObjectTable(__IntPtr h1, __IntPtr h2);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?p_uhash_occupied_CowlObjectTable@@YAIPEBUUHash_CowlObjectTable@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint PUhashOccupiedCowlObjectTable(__IntPtr h);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_table", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlTable(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_table_get_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlTableGetData(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_table_count@@YAIPEAUCowlTable@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CowlTableCount(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_table_get_value@@YAPEAXPEAUCowlTable@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlTableGetValue(__IntPtr table, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_table_get_any@@YAPEAXPEAUCowlTable@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlTableGetAny(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "?cowl_table_contains@@YA_NPEAUCowlTable@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlTableContains(__IntPtr table, __IntPtr key);
        }

        public static void UhashDeinitCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeinitCowlObjectTable(__arg0);
        }

        public static global::cowl.UhashRet UhashCopyCowlObjectTable(global::cowl.UHashCowlObjectTable src, global::cowl.UHashCowlObjectTable dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyCowlObjectTable(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashCopyAsSetCowlObjectTable(global::cowl.UHashCowlObjectTable src, global::cowl.UHashCowlObjectTable dest)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var ___ret = __Internal.UhashCopyAsSetCowlObjectTable(__arg0, __arg1);
            return ___ret;
        }

        public static void UhashClearCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashClearCowlObjectTable(__arg0);
        }

        public static uint UhashGetCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashGetCowlObjectTable(__arg0, key);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashResizeCowlObjectTable(global::cowl.UHashCowlObjectTable h, uint new_size)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashResizeCowlObjectTable(__arg0, new_size);
            return ___ret;
        }

        public static global::cowl.UhashRet UhashPutCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, ref uint idx)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            fixed (uint* __idx2 = &idx)
            {
                var __arg2 = __idx2;
                var ___ret = __Internal.UhashPutCowlObjectTable(__arg0, key, __arg2);
                return ___ret;
            }
        }

        public static void UhashDeleteCowlObjectTable(global::cowl.UHashCowlObjectTable h, uint x)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            __Internal.UhashDeleteCowlObjectTable(__arg0, x);
        }

        public static global::cowl.UHashCowlObjectTable UhmapCowlObjectTable()
        {
            var ___ret = new global::cowl.UHashCowlObjectTable.__Internal();
            __Internal.UhmapCowlObjectTable(new IntPtr(&___ret));
            return global::cowl.UHashCowlObjectTable.__CreateInstance(___ret);
        }

        public static __IntPtr UhmapGetCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr if_missing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapGetCowlObjectTable(__arg0, key, if_missing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapSetCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapSetCowlObjectTable(__arg0, key, value, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhmapAddCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr value, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapAddCowlObjectTable(__arg0, key, value, existing);
            return ___ret;
        }

        public static bool UhmapReplaceCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr value, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapReplaceCowlObjectTable(__arg0, key, value, replaced);
            return ___ret;
        }

        public static bool UhmapRemoveCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr* r_key, __IntPtr* r_val)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhmapRemoveCowlObjectTable(__arg0, key, r_key, r_val);
            return ___ret;
        }

        public static global::cowl.UHashCowlObjectTable UhsetCowlObjectTable()
        {
            var ___ret = new global::cowl.UHashCowlObjectTable.__Internal();
            __Internal.UhsetCowlObjectTable(new IntPtr(&___ret));
            return global::cowl.UHashCowlObjectTable.__CreateInstance(___ret);
        }

        public static global::cowl.UhashRet UhsetInsertCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr* existing)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetInsertCowlObjectTable(__arg0, key, existing);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetInsertAllCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr* items, uint n)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetInsertAllCowlObjectTable(__arg0, items, n);
            return ___ret;
        }

        public static bool UhsetReplaceCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr* replaced)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetReplaceCowlObjectTable(__arg0, key, replaced);
            return ___ret;
        }

        public static bool UhsetRemoveCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr key, __IntPtr* removed)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetRemoveCowlObjectTable(__arg0, key, removed);
            return ___ret;
        }

        public static bool UhsetIsSupersetCowlObjectTable(global::cowl.UHashCowlObjectTable h1, global::cowl.UHashCowlObjectTable h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetIsSupersetCowlObjectTable(__arg0, __arg1);
            return ___ret;
        }

        public static global::cowl.UhashRet UhsetUnionCowlObjectTable(global::cowl.UHashCowlObjectTable h1, global::cowl.UHashCowlObjectTable h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetUnionCowlObjectTable(__arg0, __arg1);
            return ___ret;
        }

        public static void UhsetIntersectCowlObjectTable(global::cowl.UHashCowlObjectTable h1, global::cowl.UHashCowlObjectTable h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            __Internal.UhsetIntersectCowlObjectTable(__arg0, __arg1);
        }

        public static uint UhsetHashCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetHashCowlObjectTable(__arg0);
            return ___ret;
        }

        public static __IntPtr UhsetGetAnyCowlObjectTable(global::cowl.UHashCowlObjectTable h, __IntPtr if_empty)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhsetGetAnyCowlObjectTable(__arg0, if_empty);
            return ___ret;
        }

        public static global::cowl.UHashCowlObjectTable UhmapPiCowlObjectTable(global::cowl.Delegates.Func_uint___IntPtr hash_func, global::cowl.Delegates.Func_bool___IntPtr___IntPtr equal_func)
        {
            var __arg0 = hash_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(hash_func);
            var __arg1 = equal_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(equal_func);
            var ___ret = new global::cowl.UHashCowlObjectTable.__Internal();
            __Internal.UhmapPiCowlObjectTable(new IntPtr(&___ret), __arg0, __arg1);
            return global::cowl.UHashCowlObjectTable.__CreateInstance(___ret);
        }

        public static global::cowl.UHashCowlObjectTable UhsetPiCowlObjectTable(global::cowl.Delegates.Func_uint___IntPtr hash_func, global::cowl.Delegates.Func_bool___IntPtr___IntPtr equal_func)
        {
            var __arg0 = hash_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(hash_func);
            var __arg1 = equal_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(equal_func);
            var ___ret = new global::cowl.UHashCowlObjectTable.__Internal();
            __Internal.UhsetPiCowlObjectTable(new IntPtr(&___ret), __arg0, __arg1);
            return global::cowl.UHashCowlObjectTable.__CreateInstance(___ret);
        }

        public static bool UhashIsMapCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashIsMapCowlObjectTable(__arg0);
            return ___ret;
        }

        public static global::cowl.UHashCowlObjectTable UhashMoveCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = new global::cowl.UHashCowlObjectTable.__Internal();
            __Internal.UhashMoveCowlObjectTable(new IntPtr(&___ret), __arg0);
            return global::cowl.UHashCowlObjectTable.__CreateInstance(___ret);
        }

        public static uint UhashNextCowlObjectTable(global::cowl.UHashCowlObjectTable h, uint i)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.UhashNextCowlObjectTable(__arg0, i);
            return ___ret;
        }

        public static bool UhsetEqualsCowlObjectTable(global::cowl.UHashCowlObjectTable h1, global::cowl.UHashCowlObjectTable h2)
        {
            var __arg0 = h1 is null ? __IntPtr.Zero : h1.__Instance;
            var __arg1 = h2 is null ? __IntPtr.Zero : h2.__Instance;
            var ___ret = __Internal.UhsetEqualsCowlObjectTable(__arg0, __arg1);
            return ___ret;
        }

        public static uint PUhashOccupiedCowlObjectTable(global::cowl.UHashCowlObjectTable h)
        {
            var __arg0 = h is null ? __IntPtr.Zero : h.__Instance;
            var ___ret = __Internal.PUhashOccupiedCowlObjectTable(__arg0);
            return ___ret;
        }

        /// <summary>Returns an hash table.</summary>
        /// <param name="table">Underlying raw hash table.</param>
        /// <returns>Hash table, or NULL on error.</returns>
        /// <remarks>
        /// <para>You must not use the raw hash table after passing it to this function.</para>
        /// <para>Keys and values in the raw table are retained by this constructor.</para>
        /// </remarks>
        public static global::cowl.CowlTable CowlTable(global::cowl.UHashCowlObjectTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTable(__arg0);
            var __result0 = global::cowl.CowlTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the underlying raw hash table.</summary>
        /// <param name="table">The hash table.</param>
        /// <returns>Underlying raw hash table.</returns>
        public static global::cowl.UHashCowlObjectTable CowlTableGetData(global::cowl.CowlTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTableGetData(__arg0);
            var __result0 = global::cowl.UHashCowlObjectTable.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the number of elements in the hash table.</summary>
        /// <param name="table">The hash table.</param>
        /// <returns>Number of elements in The hash table.</returns>
        public static uint CowlTableCount(global::cowl.CowlTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTableCount(__arg0);
            return ___ret;
        }

        /// <summary>Returns the value associated with the specified key.</summary>
        /// <param name="table">The hash table.</param>
        /// <param name="key">The key.</param>
        /// <returns>Value associated with the key, or NULL if the key is not present.</returns>
        public static __IntPtr CowlTableGetValue(global::cowl.CowlTable table, __IntPtr key)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTableGetValue(__arg0, key);
            return ___ret;
        }

        /// <summary>Returns one of the keys in the hash table.</summary>
        /// <param name="table">The hash table.</param>
        /// <returns>One of the keys in the hash table.</returns>
        public static __IntPtr CowlTableGetAny(global::cowl.CowlTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTableGetAny(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the hash table contains the specified key.</summary>
        /// <param name="table">The hash table.</param>
        /// <param name="key">The key.</param>
        /// <returns>True if the object is contained in the hash table, false otherwise.</returns>
        public static bool CowlTableContains(global::cowl.CowlTable table, __IntPtr key)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var ___ret = __Internal.CowlTableContains(__arg0, key);
            return ___ret;
        }
    }

    public unsafe partial class cowl_version
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CowlGetVersion(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_get_version_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlGetVersionString();
        }

        /// <summary>Returns the version of the library.</summary>
        /// <returns>Library version.</returns>
        public static global::cowl.UVersion CowlGetVersion()
        {
            var ___ret = new global::cowl.UVersion.__Internal();
            __Internal.CowlGetVersion(new IntPtr(&___ret));
            return global::cowl.UVersion.__CreateInstance(___ret);
        }

        /// <summary>Returns the string representation of the library version.</summary>
        /// <returns>String representation.</returns>
        public static global::cowl.CowlString CowlGetVersionString()
        {
            var ___ret = __Internal.CowlGetVersionString();
            var __result0 = global::cowl.CowlString.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Vocabulary of XSD IRIs.</summary>
    /// <summary>Vocabulary of XSD datatypes.</summary>
    /// <summary>The XSD vocabulary.</summary>
    /// <summary>Vocabulary of XSD IRIs.</summary>
    public unsafe partial class CowlXSDIRIVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 480)]
        public partial struct __Internal
        {
            internal __IntPtr any_atomic_type;
            internal __IntPtr any_simple_type;
            internal __IntPtr any_type;
            internal __IntPtr any_uri;
            internal __IntPtr base64_binary;
            internal __IntPtr boolean;
            internal __IntPtr @byte;
            internal __IntPtr date;
            internal __IntPtr date_time;
            internal __IntPtr date_timestamp;
            internal __IntPtr day_time_duration;
            internal __IntPtr @decimal;
            internal __IntPtr xsd_double;
            internal __IntPtr duration;
            internal __IntPtr entities;
            internal __IntPtr entity;
            internal __IntPtr xsd_float;
            internal __IntPtr g_day;
            internal __IntPtr g_month;
            internal __IntPtr g_month_day;
            internal __IntPtr g_year;
            internal __IntPtr g_year_month;
            internal __IntPtr hex_binary;
            internal __IntPtr id;
            internal __IntPtr id_ref;
            internal __IntPtr id_refs;
            internal __IntPtr xsd_int;
            internal __IntPtr integer;
            internal __IntPtr language;
            internal __IntPtr xsd_long;
            internal __IntPtr name;
            internal __IntPtr ncname;
            internal __IntPtr negative_int;
            internal __IntPtr nmtoken;
            internal __IntPtr nmtokens;
            internal __IntPtr non_negative_int;
            internal __IntPtr non_positive_int;
            internal __IntPtr norm_string;
            internal __IntPtr notation;
            internal __IntPtr positive_int;
            internal __IntPtr q_name;
            internal __IntPtr xsd_short;
            internal __IntPtr @string;
            internal __IntPtr time;
            internal __IntPtr token;
            internal __IntPtr unsigned_byte;
            internal __IntPtr unsigned_int;
            internal __IntPtr unsigned_long;
            internal __IntPtr unsigned_short;
            internal __IntPtr year_month_duration;
            internal __IntPtr length;
            internal __IntPtr min_length;
            internal __IntPtr max_length;
            internal __IntPtr pattern;
            internal __IntPtr min_inclusive;
            internal __IntPtr min_exclusive;
            internal __IntPtr max_inclusive;
            internal __IntPtr max_exclusive;
            internal __IntPtr total_digits;
            internal __IntPtr fraction_digits;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlXSDIRIVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDIRIVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDIRIVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlXSDIRIVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlXSDIRIVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlXSDIRIVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlXSDIRIVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlXSDIRIVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlXSDIRIVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlXSDIRIVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlXSDIRIVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlXSDIRIVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlXSDIRIVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlXSDIRIVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlXSDIRIVocab(global::cowl.CowlXSDIRIVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDIRIVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlXSDIRIVocab.__Internal*) __Instance) = *((global::cowl.CowlXSDIRIVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>xsd:anyAtomicType</summary>
        public global::cowl.CowlIRI AnyAtomicType
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->any_atomic_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_atomic_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anySimpleType</summary>
        public global::cowl.CowlIRI AnySimpleType
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->any_simple_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_simple_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anyType</summary>
        public global::cowl.CowlIRI AnyType
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->any_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anyURI</summary>
        public global::cowl.CowlIRI AnyUri
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->any_uri, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_uri = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:base64Binary</summary>
        public global::cowl.CowlIRI Base64Binary
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->base64_binary, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->base64_binary = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:boolean</summary>
        public global::cowl.CowlIRI Boolean
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->boolean, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->boolean = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:byte</summary>
        public global::cowl.CowlIRI Byte
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->@byte, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@byte = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:date</summary>
        public global::cowl.CowlIRI Date
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->date, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dateTime</summary>
        public global::cowl.CowlIRI DateTime
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->date_time, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date_time = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dateTimeStamp</summary>
        public global::cowl.CowlIRI DateTimestamp
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->date_timestamp, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date_timestamp = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dayTimeDuration</summary>
        public global::cowl.CowlIRI DayTimeDuration
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->day_time_duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->day_time_duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:decimal</summary>
        public global::cowl.CowlIRI Decimal
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->@decimal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@decimal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:double</summary>
        public global::cowl.CowlIRI XsdDouble
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_double, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_double = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:duration</summary>
        public global::cowl.CowlIRI Duration
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ENTITIES</summary>
        public global::cowl.CowlIRI Entities
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->entities, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->entities = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ENTITY</summary>
        public global::cowl.CowlIRI Entity
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->entity, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->entity = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:float</summary>
        public global::cowl.CowlIRI XsdFloat
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_float, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_float = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gDay</summary>
        public global::cowl.CowlIRI GDay
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->g_day, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_day = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gMonth</summary>
        public global::cowl.CowlIRI GMonth
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->g_month, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_month = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gMonthDay</summary>
        public global::cowl.CowlIRI GMonthDay
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->g_month_day, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_month_day = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gYear</summary>
        public global::cowl.CowlIRI GYear
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->g_year, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_year = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gYearMonth</summary>
        public global::cowl.CowlIRI GYearMonth
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->g_year_month, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_year_month = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:hexBinary</summary>
        public global::cowl.CowlIRI HexBinary
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->hex_binary, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->hex_binary = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ID</summary>
        public global::cowl.CowlIRI Id
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->id, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:IDREF</summary>
        public global::cowl.CowlIRI IdRef
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->id_ref, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id_ref = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:IDREFS</summary>
        public global::cowl.CowlIRI IdRefs
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->id_refs, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id_refs = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:int</summary>
        public global::cowl.CowlIRI XsdInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:integer</summary>
        public global::cowl.CowlIRI Integer
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->integer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->integer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:language</summary>
        public global::cowl.CowlIRI Language
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->language, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->language = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:long</summary>
        public global::cowl.CowlIRI XsdLong
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_long, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_long = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:Name</summary>
        public global::cowl.CowlIRI Name
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->name, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->name = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NCName</summary>
        public global::cowl.CowlIRI Ncname
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->ncname, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ncname = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:negativeInteger</summary>
        public global::cowl.CowlIRI NegativeInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->negative_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->negative_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NMTOKEN</summary>
        public global::cowl.CowlIRI Nmtoken
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->nmtoken, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nmtoken = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NMTOKENS</summary>
        public global::cowl.CowlIRI Nmtokens
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->nmtokens, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nmtokens = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:nonNegativeInteger</summary>
        public global::cowl.CowlIRI NonNegativeInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->non_negative_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->non_negative_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:nonPositiveInteger</summary>
        public global::cowl.CowlIRI NonPositiveInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->non_positive_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->non_positive_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:normalizedString</summary>
        public global::cowl.CowlIRI NormString
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->norm_string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->norm_string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NOTATION</summary>
        public global::cowl.CowlIRI Notation
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->notation, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->notation = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:positiveInteger</summary>
        public global::cowl.CowlIRI PositiveInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->positive_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->positive_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:QName</summary>
        public global::cowl.CowlIRI QName
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->q_name, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->q_name = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:short</summary>
        public global::cowl.CowlIRI XsdShort
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_short, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_short = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:string</summary>
        public global::cowl.CowlIRI String
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->@string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:time</summary>
        public global::cowl.CowlIRI Time
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->time, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->time = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:token</summary>
        public global::cowl.CowlIRI Token
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->token, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->token = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedByte</summary>
        public global::cowl.CowlIRI UnsignedByte
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_byte, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_byte = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedInt</summary>
        public global::cowl.CowlIRI UnsignedInt
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedLong</summary>
        public global::cowl.CowlIRI UnsignedLong
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_long, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_long = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedShort</summary>
        public global::cowl.CowlIRI UnsignedShort
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_short, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_short = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:yearMonthDuration</summary>
        public global::cowl.CowlIRI YearMonthDuration
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->year_month_duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->year_month_duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:length</summary>
        public global::cowl.CowlIRI Length
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->length, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->length = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:minLength</summary>
        public global::cowl.CowlIRI MinLength
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->min_length, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->min_length = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:maxLength</summary>
        public global::cowl.CowlIRI MaxLength
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->max_length, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->max_length = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:pattern</summary>
        public global::cowl.CowlIRI Pattern
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->pattern, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->pattern = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:minInclusive</summary>
        public global::cowl.CowlIRI MinInclusive
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->min_inclusive, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->min_inclusive = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:minExclusive</summary>
        public global::cowl.CowlIRI MinExclusive
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->min_exclusive, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->min_exclusive = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:maxInclusive</summary>
        public global::cowl.CowlIRI MaxInclusive
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->max_inclusive, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->max_inclusive = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:maxExclusive</summary>
        public global::cowl.CowlIRI MaxExclusive
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->max_exclusive, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->max_exclusive = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:totalDigits</summary>
        public global::cowl.CowlIRI TotalDigits
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->total_digits, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->total_digits = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:fractionDigits</summary>
        public global::cowl.CowlIRI FractionDigits
        {
            get
            {
                var __result0 = global::cowl.CowlIRI.__GetOrCreateInstance(((__Internal*)__Instance)->fraction_digits, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->fraction_digits = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Vocabulary of XSD datatypes.</summary>
    public unsafe partial class CowlXSDDatatypeVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 400)]
        public partial struct __Internal
        {
            internal __IntPtr any_atomic_type;
            internal __IntPtr any_simple_type;
            internal __IntPtr any_type;
            internal __IntPtr any_uri;
            internal __IntPtr base64_binary;
            internal __IntPtr boolean;
            internal __IntPtr @byte;
            internal __IntPtr date;
            internal __IntPtr date_time;
            internal __IntPtr date_timestamp;
            internal __IntPtr day_time_duration;
            internal __IntPtr @decimal;
            internal __IntPtr xsd_double;
            internal __IntPtr duration;
            internal __IntPtr entities;
            internal __IntPtr entity;
            internal __IntPtr xsd_float;
            internal __IntPtr g_day;
            internal __IntPtr g_month;
            internal __IntPtr g_month_day;
            internal __IntPtr g_year;
            internal __IntPtr g_year_month;
            internal __IntPtr hex_binary;
            internal __IntPtr id;
            internal __IntPtr id_ref;
            internal __IntPtr id_refs;
            internal __IntPtr xsd_int;
            internal __IntPtr integer;
            internal __IntPtr language;
            internal __IntPtr xsd_long;
            internal __IntPtr name;
            internal __IntPtr ncname;
            internal __IntPtr negative_int;
            internal __IntPtr nmtoken;
            internal __IntPtr nmtokens;
            internal __IntPtr non_negative_int;
            internal __IntPtr non_positive_int;
            internal __IntPtr norm_string;
            internal __IntPtr notation;
            internal __IntPtr positive_int;
            internal __IntPtr q_name;
            internal __IntPtr xsd_short;
            internal __IntPtr @string;
            internal __IntPtr time;
            internal __IntPtr token;
            internal __IntPtr unsigned_byte;
            internal __IntPtr unsigned_int;
            internal __IntPtr unsigned_long;
            internal __IntPtr unsigned_short;
            internal __IntPtr year_month_duration;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlXSDDatatypeVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDDatatypeVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDDatatypeVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlXSDDatatypeVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlXSDDatatypeVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlXSDDatatypeVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlXSDDatatypeVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlXSDDatatypeVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlXSDDatatypeVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlXSDDatatypeVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlXSDDatatypeVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlXSDDatatypeVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlXSDDatatypeVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlXSDDatatypeVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlXSDDatatypeVocab(global::cowl.CowlXSDDatatypeVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDDatatypeVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlXSDDatatypeVocab.__Internal*) __Instance) = *((global::cowl.CowlXSDDatatypeVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>xsd:anyAtomicType</summary>
        public global::cowl.CowlDatatype AnyAtomicType
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->any_atomic_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_atomic_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anySimpleType</summary>
        public global::cowl.CowlDatatype AnySimpleType
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->any_simple_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_simple_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anyType</summary>
        public global::cowl.CowlDatatype AnyType
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->any_type, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_type = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:anyURI</summary>
        public global::cowl.CowlDatatype AnyUri
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->any_uri, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->any_uri = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:base64Binary</summary>
        public global::cowl.CowlDatatype Base64Binary
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->base64_binary, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->base64_binary = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:boolean</summary>
        public global::cowl.CowlDatatype Boolean
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->boolean, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->boolean = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:byte</summary>
        public global::cowl.CowlDatatype Byte
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->@byte, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@byte = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:date</summary>
        public global::cowl.CowlDatatype Date
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->date, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dateTime</summary>
        public global::cowl.CowlDatatype DateTime
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->date_time, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date_time = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dateTimeStamp</summary>
        public global::cowl.CowlDatatype DateTimestamp
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->date_timestamp, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->date_timestamp = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:dayTimeDuration</summary>
        public global::cowl.CowlDatatype DayTimeDuration
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->day_time_duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->day_time_duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:decimal</summary>
        public global::cowl.CowlDatatype Decimal
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->@decimal, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@decimal = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:double</summary>
        public global::cowl.CowlDatatype XsdDouble
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_double, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_double = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:duration</summary>
        public global::cowl.CowlDatatype Duration
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ENTITIES</summary>
        public global::cowl.CowlDatatype Entities
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->entities, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->entities = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ENTITY</summary>
        public global::cowl.CowlDatatype Entity
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->entity, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->entity = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:float</summary>
        public global::cowl.CowlDatatype XsdFloat
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_float, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_float = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gDay</summary>
        public global::cowl.CowlDatatype GDay
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->g_day, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_day = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gMonth</summary>
        public global::cowl.CowlDatatype GMonth
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->g_month, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_month = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gMonthDay</summary>
        public global::cowl.CowlDatatype GMonthDay
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->g_month_day, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_month_day = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gYear</summary>
        public global::cowl.CowlDatatype GYear
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->g_year, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_year = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:gYearMonth</summary>
        public global::cowl.CowlDatatype GYearMonth
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->g_year_month, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->g_year_month = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:hexBinary</summary>
        public global::cowl.CowlDatatype HexBinary
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->hex_binary, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->hex_binary = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:ID</summary>
        public global::cowl.CowlDatatype Id
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->id, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:IDREF</summary>
        public global::cowl.CowlDatatype IdRef
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->id_ref, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id_ref = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:IDREFS</summary>
        public global::cowl.CowlDatatype IdRefs
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->id_refs, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->id_refs = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:int</summary>
        public global::cowl.CowlDatatype XsdInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:integer</summary>
        public global::cowl.CowlDatatype Integer
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->integer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->integer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:language</summary>
        public global::cowl.CowlDatatype Language
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->language, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->language = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:long</summary>
        public global::cowl.CowlDatatype XsdLong
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_long, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_long = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:Name</summary>
        public global::cowl.CowlDatatype Name
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->name, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->name = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NCName</summary>
        public global::cowl.CowlDatatype Ncname
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->ncname, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ncname = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:negativeInteger</summary>
        public global::cowl.CowlDatatype NegativeInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->negative_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->negative_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NMTOKEN</summary>
        public global::cowl.CowlDatatype Nmtoken
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->nmtoken, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nmtoken = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NMTOKENS</summary>
        public global::cowl.CowlDatatype Nmtokens
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->nmtokens, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->nmtokens = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:nonNegativeInteger</summary>
        public global::cowl.CowlDatatype NonNegativeInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->non_negative_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->non_negative_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:nonPositiveInteger</summary>
        public global::cowl.CowlDatatype NonPositiveInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->non_positive_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->non_positive_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:normalizedString</summary>
        public global::cowl.CowlDatatype NormString
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->norm_string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->norm_string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:NOTATION</summary>
        public global::cowl.CowlDatatype Notation
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->notation, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->notation = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:positiveInteger</summary>
        public global::cowl.CowlDatatype PositiveInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->positive_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->positive_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:QName</summary>
        public global::cowl.CowlDatatype QName
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->q_name, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->q_name = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:short</summary>
        public global::cowl.CowlDatatype XsdShort
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->xsd_short, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->xsd_short = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:string</summary>
        public global::cowl.CowlDatatype String
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->@string, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->@string = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:time</summary>
        public global::cowl.CowlDatatype Time
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->time, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->time = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:token</summary>
        public global::cowl.CowlDatatype Token
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->token, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->token = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedByte</summary>
        public global::cowl.CowlDatatype UnsignedByte
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_byte, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_byte = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedInt</summary>
        public global::cowl.CowlDatatype UnsignedInt
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_int, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_int = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedLong</summary>
        public global::cowl.CowlDatatype UnsignedLong
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_long, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_long = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:unsignedShort</summary>
        public global::cowl.CowlDatatype UnsignedShort
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->unsigned_short, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unsigned_short = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>xsd:yearMonthDuration</summary>
        public global::cowl.CowlDatatype YearMonthDuration
        {
            get
            {
                var __result0 = global::cowl.CowlDatatype.__GetOrCreateInstance(((__Internal*)__Instance)->year_month_duration, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->year_month_duration = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>The XSD vocabulary.</summary>
    public unsafe partial class CowlXSDVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 896)]
        public partial struct __Internal
        {
            internal __IntPtr ns;
            internal __IntPtr prefix;
            internal global::cowl.CowlXSDIRIVocab.__Internal iri;
            internal global::cowl.CowlXSDDatatypeVocab.__Internal dt;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlXSDVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlXSDVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlXSDVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlXSDVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlXSDVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlXSDVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlXSDVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlXSDVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlXSDVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlXSDVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlXSDVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlXSDVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlXSDVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlXSDVocab(global::cowl.CowlXSDVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlXSDVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlXSDVocab.__Internal*) __Instance) = *((global::cowl.CowlXSDVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>XSD namespace.</summary>
        public global::cowl.CowlString Ns
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->ns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>XSD prefix.</summary>
        public global::cowl.CowlString Prefix
        {
            get
            {
                var __result0 = global::cowl.CowlString.__GetOrCreateInstance(((__Internal*)__Instance)->prefix, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prefix = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>IRIs sub-vocabulary.</summary>
        public global::cowl.CowlXSDIRIVocab Iri
        {
            get
            {
                return global::cowl.CowlXSDIRIVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->iri));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->iri = *(global::cowl.CowlXSDIRIVocab.__Internal*) value.__Instance;
            }
        }

        /// <summary>Datatypes sub-vocabulary.</summary>
        public global::cowl.CowlXSDDatatypeVocab Dt
        {
            get
            {
                return global::cowl.CowlXSDDatatypeVocab.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dt = *(global::cowl.CowlXSDDatatypeVocab.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class cowl_xsd_vocab
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_xsd_vocab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CowlXsdVocab();
        }

        /// <summary>Returns the XSD vocabulary.</summary>
        /// <returns>The XSD vocabulary.</returns>
        public static global::cowl.CowlXSDVocab CowlXsdVocab()
        {
            var ___ret = __Internal.CowlXsdVocab();
            var __result0 = global::cowl.CowlXSDVocab.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Vocabulary of reserved terms.</summary>
    /// <summary>Vocabulary of reserved terms.</summary>
    public unsafe partial class CowlVocab : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr owl;
            internal __IntPtr rdf;
            internal __IntPtr rdfs;
            internal __IntPtr xsd;

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "??0CowlVocab@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlVocab> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::cowl.CowlVocab>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::cowl.CowlVocab managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::cowl.CowlVocab managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CowlVocab __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CowlVocab(native.ToPointer(), skipVTables);
        }

        internal static CowlVocab __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CowlVocab)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CowlVocab __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CowlVocab(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CowlVocab(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CowlVocab(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CowlVocab()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CowlVocab(global::cowl.CowlVocab _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::cowl.CowlVocab.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::cowl.CowlVocab.__Internal*) __Instance) = *((global::cowl.CowlVocab.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>OWL vocabulary.</summary>
        public global::cowl.CowlOWLVocab Owl
        {
            get
            {
                var __result0 = global::cowl.CowlOWLVocab.__GetOrCreateInstance(((__Internal*)__Instance)->owl, false);
                return __result0;
            }
        }

        /// <summary>RDF vocabulary.</summary>
        public global::cowl.CowlRDFVocab Rdf
        {
            get
            {
                var __result0 = global::cowl.CowlRDFVocab.__GetOrCreateInstance(((__Internal*)__Instance)->rdf, false);
                return __result0;
            }
        }

        /// <summary>RDFS vocabulary.</summary>
        public global::cowl.CowlRDFSVocab Rdfs
        {
            get
            {
                var __result0 = global::cowl.CowlRDFSVocab.__GetOrCreateInstance(((__Internal*)__Instance)->rdfs, false);
                return __result0;
            }
        }

        /// <summary>XSD vocabulary.</summary>
        public global::cowl.CowlXSDVocab Xsd
        {
            get
            {
                var __result0 = global::cowl.CowlXSDVocab.__GetOrCreateInstance(((__Internal*)__Instance)->xsd, false);
                return __result0;
            }
        }
    }

    public unsafe partial class cowl_vocab
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vocab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cowl_vocab();

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vocab_is_reserved_prefix", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlVocabIsReservedPrefix(__IntPtr prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vocab_is_reserved_ns", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlVocabIsReservedNs(__IntPtr ns);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vocab_is_reserved_prefix_raw", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlVocabIsReservedPrefixRaw(__IntPtr prefix);

            [SuppressUnmanagedCodeSecurity, DllImport("cowl", EntryPoint = "cowl_vocab_is_reserved_ns_raw", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CowlVocabIsReservedNsRaw(__IntPtr ns);
        }

        /// <summary>Returns the vocabulary of reserved terms.</summary>
        /// <returns>Vocabulary of reserved terms.</returns>
        public static global::cowl.CowlVocab cowl_vocab_()
        {
            var ___ret = __Internal.cowl_vocab();
            var __result0 = global::cowl.CowlVocab.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Checks whether the specified prefix is in the reserved vocabulary.</summary>
        /// <param name="prefix">The prefix.</param>
        /// <returns>True if the prefix is reserved, false otherwise.</returns>
        public static bool CowlVocabIsReservedPrefix(global::cowl.CowlString prefix)
        {
            var __arg0 = prefix is null ? __IntPtr.Zero : prefix.__Instance;
            var ___ret = __Internal.CowlVocabIsReservedPrefix(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the specified namespace is in the reserved vocabulary.</summary>
        /// <param name="ns">The namespace.</param>
        /// <returns>True if the namespace is reserved, false otherwise.</returns>
        public static bool CowlVocabIsReservedNs(global::cowl.CowlString ns)
        {
            var __arg0 = ns is null ? __IntPtr.Zero : ns.__Instance;
            var ___ret = __Internal.CowlVocabIsReservedNs(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the specified prefix is in the reserved vocabulary.</summary>
        /// <param name="prefix">The prefix.</param>
        /// <returns>True if the prefix is reserved, false otherwise.</returns>
        public static bool CowlVocabIsReservedPrefixRaw(global::cowl.UString prefix)
        {
            if (ReferenceEquals(prefix, null))
                throw new global::System.ArgumentNullException("prefix", "Cannot be null because it is passed by value.");
            var __arg0 = prefix.__Instance;
            var ___ret = __Internal.CowlVocabIsReservedPrefixRaw(__arg0);
            return ___ret;
        }

        /// <summary>Checks whether the specified namespace is in the reserved vocabulary.</summary>
        /// <param name="ns">The namespace.</param>
        /// <returns>True if the namespace is reserved, false otherwise.</returns>
        public static bool CowlVocabIsReservedNsRaw(global::cowl.UString ns)
        {
            if (ReferenceEquals(ns, null))
                throw new global::System.ArgumentNullException("ns", "Cannot be null because it is passed by value.");
            var __arg0 = ns.__Instance;
            var ___ret = __Internal.CowlVocabIsReservedNsRaw(__arg0);
            return ___ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.UstreamRet Func_cowl_ustream_ret___IntPtr___IntPtr_ulong_ulongPtr(__IntPtr ctx, __IntPtr buf, ulong count, ulong* read);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.UstreamRet Func_cowl_ustream_ret___IntPtr(__IntPtr ctx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.UstreamRet Func_cowl_ustream_ret___IntPtr_ulongPtr_string8_Object(__IntPtr ctx, ulong* written, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, global::System.Object args);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr___IntPtr(__IntPtr ctx, __IntPtr @object);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint___IntPtr(__IntPtr key);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr ctx, __IntPtr error);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr ctx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr ctx, __IntPtr iri);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.CowlRet Func_cowl_cowl_ret___IntPtr___IntPtr(__IntPtr istream, __IntPtr stream);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.CowlRet Func_cowl_cowl_ret___IntPtr___IntPtr_cowl_CowlOntologyHeader___Internal(__IntPtr stream, __IntPtr st, global::cowl.CowlOntologyHeader.__Internal header);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::cowl.CowlRet Func_cowl_cowl_ret___IntPtr___IntPtr___IntPtr(__IntPtr stream, __IntPtr st, __IntPtr axiom);
    }
}
namespace cowl.__Symbols
{
    internal class cowl
    {
        public static IntPtr _ustring_null { get; }
        public static IntPtr _ustring_empty { get; }
        static cowl()
        {
            var path = "cowl";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _ustring_null = CppSharp.SymbolResolver.ResolveSymbol(image, "ustring_null");
            _ustring_empty = CppSharp.SymbolResolver.ResolveSymbol(image, "ustring_empty");
        }
    }
}

